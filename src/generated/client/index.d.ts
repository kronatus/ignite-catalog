
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Topic
 * 
 */
export type Topic = $Result.DefaultSelection<Prisma.$TopicPayload>
/**
 * Model SessionTopic
 * 
 */
export type SessionTopic = $Result.DefaultSelection<Prisma.$SessionTopicPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model SessionTag
 * 
 */
export type SessionTag = $Result.DefaultSelection<Prisma.$SessionTagPayload>
/**
 * Model Level
 * 
 */
export type Level = $Result.DefaultSelection<Prisma.$LevelPayload>
/**
 * Model SessionLevelOnSession
 * 
 */
export type SessionLevelOnSession = $Result.DefaultSelection<Prisma.$SessionLevelOnSessionPayload>
/**
 * Model AudienceType
 * 
 */
export type AudienceType = $Result.DefaultSelection<Prisma.$AudienceTypePayload>
/**
 * Model SessionAudienceTypeOnSession
 * 
 */
export type SessionAudienceTypeOnSession = $Result.DefaultSelection<Prisma.$SessionAudienceTypeOnSessionPayload>
/**
 * Model Industry
 * 
 */
export type Industry = $Result.DefaultSelection<Prisma.$IndustryPayload>
/**
 * Model SessionIndustryOnSession
 * 
 */
export type SessionIndustryOnSession = $Result.DefaultSelection<Prisma.$SessionIndustryOnSessionPayload>
/**
 * Model DeliveryType
 * 
 */
export type DeliveryType = $Result.DefaultSelection<Prisma.$DeliveryTypePayload>
/**
 * Model SessionDeliveryTypeOnSession
 * 
 */
export type SessionDeliveryTypeOnSession = $Result.DefaultSelection<Prisma.$SessionDeliveryTypeOnSessionPayload>
/**
 * Model ViewingOption
 * 
 */
export type ViewingOption = $Result.DefaultSelection<Prisma.$ViewingOptionPayload>
/**
 * Model SessionViewingOptionOnSession
 * 
 */
export type SessionViewingOptionOnSession = $Result.DefaultSelection<Prisma.$SessionViewingOptionOnSessionPayload>
/**
 * Model Speaker
 * 
 */
export type Speaker = $Result.DefaultSelection<Prisma.$SpeakerPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model SpeakerCompany
 * 
 */
export type SpeakerCompany = $Result.DefaultSelection<Prisma.$SpeakerCompanyPayload>
/**
 * Model SessionSpeaker
 * 
 */
export type SessionSpeaker = $Result.DefaultSelection<Prisma.$SessionSpeakerPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Sessions
 * const sessions = await prisma.session.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Sessions
   * const sessions = await prisma.session.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.topic`: Exposes CRUD operations for the **Topic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Topics
    * const topics = await prisma.topic.findMany()
    * ```
    */
  get topic(): Prisma.TopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionTopic`: Exposes CRUD operations for the **SessionTopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionTopics
    * const sessionTopics = await prisma.sessionTopic.findMany()
    * ```
    */
  get sessionTopic(): Prisma.SessionTopicDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionTag`: Exposes CRUD operations for the **SessionTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionTags
    * const sessionTags = await prisma.sessionTag.findMany()
    * ```
    */
  get sessionTag(): Prisma.SessionTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.level`: Exposes CRUD operations for the **Level** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Levels
    * const levels = await prisma.level.findMany()
    * ```
    */
  get level(): Prisma.LevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionLevelOnSession`: Exposes CRUD operations for the **SessionLevelOnSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionLevelOnSessions
    * const sessionLevelOnSessions = await prisma.sessionLevelOnSession.findMany()
    * ```
    */
  get sessionLevelOnSession(): Prisma.SessionLevelOnSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.audienceType`: Exposes CRUD operations for the **AudienceType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AudienceTypes
    * const audienceTypes = await prisma.audienceType.findMany()
    * ```
    */
  get audienceType(): Prisma.AudienceTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionAudienceTypeOnSession`: Exposes CRUD operations for the **SessionAudienceTypeOnSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionAudienceTypeOnSessions
    * const sessionAudienceTypeOnSessions = await prisma.sessionAudienceTypeOnSession.findMany()
    * ```
    */
  get sessionAudienceTypeOnSession(): Prisma.SessionAudienceTypeOnSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.industry`: Exposes CRUD operations for the **Industry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Industries
    * const industries = await prisma.industry.findMany()
    * ```
    */
  get industry(): Prisma.IndustryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionIndustryOnSession`: Exposes CRUD operations for the **SessionIndustryOnSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionIndustryOnSessions
    * const sessionIndustryOnSessions = await prisma.sessionIndustryOnSession.findMany()
    * ```
    */
  get sessionIndustryOnSession(): Prisma.SessionIndustryOnSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deliveryType`: Exposes CRUD operations for the **DeliveryType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeliveryTypes
    * const deliveryTypes = await prisma.deliveryType.findMany()
    * ```
    */
  get deliveryType(): Prisma.DeliveryTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionDeliveryTypeOnSession`: Exposes CRUD operations for the **SessionDeliveryTypeOnSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionDeliveryTypeOnSessions
    * const sessionDeliveryTypeOnSessions = await prisma.sessionDeliveryTypeOnSession.findMany()
    * ```
    */
  get sessionDeliveryTypeOnSession(): Prisma.SessionDeliveryTypeOnSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.viewingOption`: Exposes CRUD operations for the **ViewingOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViewingOptions
    * const viewingOptions = await prisma.viewingOption.findMany()
    * ```
    */
  get viewingOption(): Prisma.ViewingOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionViewingOptionOnSession`: Exposes CRUD operations for the **SessionViewingOptionOnSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionViewingOptionOnSessions
    * const sessionViewingOptionOnSessions = await prisma.sessionViewingOptionOnSession.findMany()
    * ```
    */
  get sessionViewingOptionOnSession(): Prisma.SessionViewingOptionOnSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speaker`: Exposes CRUD operations for the **Speaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Speakers
    * const speakers = await prisma.speaker.findMany()
    * ```
    */
  get speaker(): Prisma.SpeakerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.speakerCompany`: Exposes CRUD operations for the **SpeakerCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpeakerCompanies
    * const speakerCompanies = await prisma.speakerCompany.findMany()
    * ```
    */
  get speakerCompany(): Prisma.SpeakerCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessionSpeaker`: Exposes CRUD operations for the **SessionSpeaker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessionSpeakers
    * const sessionSpeakers = await prisma.sessionSpeaker.findMany()
    * ```
    */
  get sessionSpeaker(): Prisma.SessionSpeakerDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Session: 'Session',
    Topic: 'Topic',
    SessionTopic: 'SessionTopic',
    Tag: 'Tag',
    SessionTag: 'SessionTag',
    Level: 'Level',
    SessionLevelOnSession: 'SessionLevelOnSession',
    AudienceType: 'AudienceType',
    SessionAudienceTypeOnSession: 'SessionAudienceTypeOnSession',
    Industry: 'Industry',
    SessionIndustryOnSession: 'SessionIndustryOnSession',
    DeliveryType: 'DeliveryType',
    SessionDeliveryTypeOnSession: 'SessionDeliveryTypeOnSession',
    ViewingOption: 'ViewingOption',
    SessionViewingOptionOnSession: 'SessionViewingOptionOnSession',
    Speaker: 'Speaker',
    Company: 'Company',
    SpeakerCompany: 'SpeakerCompany',
    SessionSpeaker: 'SessionSpeaker'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "session" | "topic" | "sessionTopic" | "tag" | "sessionTag" | "level" | "sessionLevelOnSession" | "audienceType" | "sessionAudienceTypeOnSession" | "industry" | "sessionIndustryOnSession" | "deliveryType" | "sessionDeliveryTypeOnSession" | "viewingOption" | "sessionViewingOptionOnSession" | "speaker" | "company" | "speakerCompany" | "sessionSpeaker"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Topic: {
        payload: Prisma.$TopicPayload<ExtArgs>
        fields: Prisma.TopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findFirst: {
            args: Prisma.TopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          findMany: {
            args: Prisma.TopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          create: {
            args: Prisma.TopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          createMany: {
            args: Prisma.TopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          delete: {
            args: Prisma.TopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          update: {
            args: Prisma.TopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          deleteMany: {
            args: Prisma.TopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>[]
          }
          upsert: {
            args: Prisma.TopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TopicPayload>
          }
          aggregate: {
            args: Prisma.TopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTopic>
          }
          groupBy: {
            args: Prisma.TopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<TopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.TopicCountArgs<ExtArgs>
            result: $Utils.Optional<TopicCountAggregateOutputType> | number
          }
        }
      }
      SessionTopic: {
        payload: Prisma.$SessionTopicPayload<ExtArgs>
        fields: Prisma.SessionTopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionTopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionTopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>
          }
          findFirst: {
            args: Prisma.SessionTopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionTopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>
          }
          findMany: {
            args: Prisma.SessionTopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>[]
          }
          create: {
            args: Prisma.SessionTopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>
          }
          createMany: {
            args: Prisma.SessionTopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionTopicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>[]
          }
          delete: {
            args: Prisma.SessionTopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>
          }
          update: {
            args: Prisma.SessionTopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>
          }
          deleteMany: {
            args: Prisma.SessionTopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionTopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionTopicUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>[]
          }
          upsert: {
            args: Prisma.SessionTopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTopicPayload>
          }
          aggregate: {
            args: Prisma.SessionTopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionTopic>
          }
          groupBy: {
            args: Prisma.SessionTopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionTopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionTopicCountArgs<ExtArgs>
            result: $Utils.Optional<SessionTopicCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      SessionTag: {
        payload: Prisma.$SessionTagPayload<ExtArgs>
        fields: Prisma.SessionTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          findFirst: {
            args: Prisma.SessionTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          findMany: {
            args: Prisma.SessionTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>[]
          }
          create: {
            args: Prisma.SessionTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          createMany: {
            args: Prisma.SessionTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>[]
          }
          delete: {
            args: Prisma.SessionTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          update: {
            args: Prisma.SessionTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          deleteMany: {
            args: Prisma.SessionTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>[]
          }
          upsert: {
            args: Prisma.SessionTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionTagPayload>
          }
          aggregate: {
            args: Prisma.SessionTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionTag>
          }
          groupBy: {
            args: Prisma.SessionTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionTagCountArgs<ExtArgs>
            result: $Utils.Optional<SessionTagCountAggregateOutputType> | number
          }
        }
      }
      Level: {
        payload: Prisma.$LevelPayload<ExtArgs>
        fields: Prisma.LevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findFirst: {
            args: Prisma.LevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          findMany: {
            args: Prisma.LevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          create: {
            args: Prisma.LevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          createMany: {
            args: Prisma.LevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          delete: {
            args: Prisma.LevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          update: {
            args: Prisma.LevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          deleteMany: {
            args: Prisma.LevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>[]
          }
          upsert: {
            args: Prisma.LevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LevelPayload>
          }
          aggregate: {
            args: Prisma.LevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLevel>
          }
          groupBy: {
            args: Prisma.LevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<LevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.LevelCountArgs<ExtArgs>
            result: $Utils.Optional<LevelCountAggregateOutputType> | number
          }
        }
      }
      SessionLevelOnSession: {
        payload: Prisma.$SessionLevelOnSessionPayload<ExtArgs>
        fields: Prisma.SessionLevelOnSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionLevelOnSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionLevelOnSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>
          }
          findFirst: {
            args: Prisma.SessionLevelOnSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionLevelOnSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>
          }
          findMany: {
            args: Prisma.SessionLevelOnSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>[]
          }
          create: {
            args: Prisma.SessionLevelOnSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>
          }
          createMany: {
            args: Prisma.SessionLevelOnSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionLevelOnSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>[]
          }
          delete: {
            args: Prisma.SessionLevelOnSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>
          }
          update: {
            args: Prisma.SessionLevelOnSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionLevelOnSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionLevelOnSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionLevelOnSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionLevelOnSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionLevelOnSessionPayload>
          }
          aggregate: {
            args: Prisma.SessionLevelOnSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionLevelOnSession>
          }
          groupBy: {
            args: Prisma.SessionLevelOnSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionLevelOnSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionLevelOnSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionLevelOnSessionCountAggregateOutputType> | number
          }
        }
      }
      AudienceType: {
        payload: Prisma.$AudienceTypePayload<ExtArgs>
        fields: Prisma.AudienceTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AudienceTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AudienceTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>
          }
          findFirst: {
            args: Prisma.AudienceTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AudienceTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>
          }
          findMany: {
            args: Prisma.AudienceTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>[]
          }
          create: {
            args: Prisma.AudienceTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>
          }
          createMany: {
            args: Prisma.AudienceTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AudienceTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>[]
          }
          delete: {
            args: Prisma.AudienceTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>
          }
          update: {
            args: Prisma.AudienceTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>
          }
          deleteMany: {
            args: Prisma.AudienceTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AudienceTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AudienceTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>[]
          }
          upsert: {
            args: Prisma.AudienceTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AudienceTypePayload>
          }
          aggregate: {
            args: Prisma.AudienceTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAudienceType>
          }
          groupBy: {
            args: Prisma.AudienceTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<AudienceTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.AudienceTypeCountArgs<ExtArgs>
            result: $Utils.Optional<AudienceTypeCountAggregateOutputType> | number
          }
        }
      }
      SessionAudienceTypeOnSession: {
        payload: Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>
        fields: Prisma.SessionAudienceTypeOnSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionAudienceTypeOnSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionAudienceTypeOnSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>
          }
          findFirst: {
            args: Prisma.SessionAudienceTypeOnSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionAudienceTypeOnSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>
          }
          findMany: {
            args: Prisma.SessionAudienceTypeOnSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>[]
          }
          create: {
            args: Prisma.SessionAudienceTypeOnSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>
          }
          createMany: {
            args: Prisma.SessionAudienceTypeOnSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionAudienceTypeOnSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>[]
          }
          delete: {
            args: Prisma.SessionAudienceTypeOnSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>
          }
          update: {
            args: Prisma.SessionAudienceTypeOnSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionAudienceTypeOnSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionAudienceTypeOnSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionAudienceTypeOnSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionAudienceTypeOnSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionAudienceTypeOnSessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAudienceTypeOnSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionAudienceTypeOnSession>
          }
          groupBy: {
            args: Prisma.SessionAudienceTypeOnSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionAudienceTypeOnSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionAudienceTypeOnSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionAudienceTypeOnSessionCountAggregateOutputType> | number
          }
        }
      }
      Industry: {
        payload: Prisma.$IndustryPayload<ExtArgs>
        fields: Prisma.IndustryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IndustryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IndustryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          findFirst: {
            args: Prisma.IndustryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IndustryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          findMany: {
            args: Prisma.IndustryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          create: {
            args: Prisma.IndustryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          createMany: {
            args: Prisma.IndustryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IndustryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          delete: {
            args: Prisma.IndustryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          update: {
            args: Prisma.IndustryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          deleteMany: {
            args: Prisma.IndustryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IndustryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IndustryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>[]
          }
          upsert: {
            args: Prisma.IndustryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IndustryPayload>
          }
          aggregate: {
            args: Prisma.IndustryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIndustry>
          }
          groupBy: {
            args: Prisma.IndustryGroupByArgs<ExtArgs>
            result: $Utils.Optional<IndustryGroupByOutputType>[]
          }
          count: {
            args: Prisma.IndustryCountArgs<ExtArgs>
            result: $Utils.Optional<IndustryCountAggregateOutputType> | number
          }
        }
      }
      SessionIndustryOnSession: {
        payload: Prisma.$SessionIndustryOnSessionPayload<ExtArgs>
        fields: Prisma.SessionIndustryOnSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionIndustryOnSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionIndustryOnSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>
          }
          findFirst: {
            args: Prisma.SessionIndustryOnSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionIndustryOnSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>
          }
          findMany: {
            args: Prisma.SessionIndustryOnSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>[]
          }
          create: {
            args: Prisma.SessionIndustryOnSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>
          }
          createMany: {
            args: Prisma.SessionIndustryOnSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionIndustryOnSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>[]
          }
          delete: {
            args: Prisma.SessionIndustryOnSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>
          }
          update: {
            args: Prisma.SessionIndustryOnSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionIndustryOnSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionIndustryOnSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionIndustryOnSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionIndustryOnSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionIndustryOnSessionPayload>
          }
          aggregate: {
            args: Prisma.SessionIndustryOnSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionIndustryOnSession>
          }
          groupBy: {
            args: Prisma.SessionIndustryOnSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionIndustryOnSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionIndustryOnSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionIndustryOnSessionCountAggregateOutputType> | number
          }
        }
      }
      DeliveryType: {
        payload: Prisma.$DeliveryTypePayload<ExtArgs>
        fields: Prisma.DeliveryTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeliveryTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeliveryTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>
          }
          findFirst: {
            args: Prisma.DeliveryTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeliveryTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>
          }
          findMany: {
            args: Prisma.DeliveryTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>[]
          }
          create: {
            args: Prisma.DeliveryTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>
          }
          createMany: {
            args: Prisma.DeliveryTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeliveryTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>[]
          }
          delete: {
            args: Prisma.DeliveryTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>
          }
          update: {
            args: Prisma.DeliveryTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>
          }
          deleteMany: {
            args: Prisma.DeliveryTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeliveryTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeliveryTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>[]
          }
          upsert: {
            args: Prisma.DeliveryTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeliveryTypePayload>
          }
          aggregate: {
            args: Prisma.DeliveryTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeliveryType>
          }
          groupBy: {
            args: Prisma.DeliveryTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeliveryTypeCountArgs<ExtArgs>
            result: $Utils.Optional<DeliveryTypeCountAggregateOutputType> | number
          }
        }
      }
      SessionDeliveryTypeOnSession: {
        payload: Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>
        fields: Prisma.SessionDeliveryTypeOnSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionDeliveryTypeOnSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionDeliveryTypeOnSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>
          }
          findFirst: {
            args: Prisma.SessionDeliveryTypeOnSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionDeliveryTypeOnSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>
          }
          findMany: {
            args: Prisma.SessionDeliveryTypeOnSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>[]
          }
          create: {
            args: Prisma.SessionDeliveryTypeOnSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>
          }
          createMany: {
            args: Prisma.SessionDeliveryTypeOnSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionDeliveryTypeOnSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeliveryTypeOnSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>
          }
          update: {
            args: Prisma.SessionDeliveryTypeOnSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeliveryTypeOnSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionDeliveryTypeOnSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionDeliveryTypeOnSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionDeliveryTypeOnSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionDeliveryTypeOnSessionPayload>
          }
          aggregate: {
            args: Prisma.SessionDeliveryTypeOnSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionDeliveryTypeOnSession>
          }
          groupBy: {
            args: Prisma.SessionDeliveryTypeOnSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionDeliveryTypeOnSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionDeliveryTypeOnSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionDeliveryTypeOnSessionCountAggregateOutputType> | number
          }
        }
      }
      ViewingOption: {
        payload: Prisma.$ViewingOptionPayload<ExtArgs>
        fields: Prisma.ViewingOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViewingOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViewingOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>
          }
          findFirst: {
            args: Prisma.ViewingOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViewingOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>
          }
          findMany: {
            args: Prisma.ViewingOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>[]
          }
          create: {
            args: Prisma.ViewingOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>
          }
          createMany: {
            args: Prisma.ViewingOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ViewingOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>[]
          }
          delete: {
            args: Prisma.ViewingOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>
          }
          update: {
            args: Prisma.ViewingOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>
          }
          deleteMany: {
            args: Prisma.ViewingOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ViewingOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ViewingOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>[]
          }
          upsert: {
            args: Prisma.ViewingOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ViewingOptionPayload>
          }
          aggregate: {
            args: Prisma.ViewingOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateViewingOption>
          }
          groupBy: {
            args: Prisma.ViewingOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ViewingOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViewingOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ViewingOptionCountAggregateOutputType> | number
          }
        }
      }
      SessionViewingOptionOnSession: {
        payload: Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>
        fields: Prisma.SessionViewingOptionOnSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionViewingOptionOnSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionViewingOptionOnSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>
          }
          findFirst: {
            args: Prisma.SessionViewingOptionOnSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionViewingOptionOnSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>
          }
          findMany: {
            args: Prisma.SessionViewingOptionOnSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>[]
          }
          create: {
            args: Prisma.SessionViewingOptionOnSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>
          }
          createMany: {
            args: Prisma.SessionViewingOptionOnSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionViewingOptionOnSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>[]
          }
          delete: {
            args: Prisma.SessionViewingOptionOnSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>
          }
          update: {
            args: Prisma.SessionViewingOptionOnSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionViewingOptionOnSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionViewingOptionOnSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionViewingOptionOnSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionViewingOptionOnSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionViewingOptionOnSessionPayload>
          }
          aggregate: {
            args: Prisma.SessionViewingOptionOnSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionViewingOptionOnSession>
          }
          groupBy: {
            args: Prisma.SessionViewingOptionOnSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionViewingOptionOnSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionViewingOptionOnSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionViewingOptionOnSessionCountAggregateOutputType> | number
          }
        }
      }
      Speaker: {
        payload: Prisma.$SpeakerPayload<ExtArgs>
        fields: Prisma.SpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          findFirst: {
            args: Prisma.SpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          findMany: {
            args: Prisma.SpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
          }
          create: {
            args: Prisma.SpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          createMany: {
            args: Prisma.SpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeakerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
          }
          delete: {
            args: Prisma.SpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          update: {
            args: Prisma.SpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          deleteMany: {
            args: Prisma.SpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpeakerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>[]
          }
          upsert: {
            args: Prisma.SpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerPayload>
          }
          aggregate: {
            args: Prisma.SpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeaker>
          }
          groupBy: {
            args: Prisma.SpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakerCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      SpeakerCompany: {
        payload: Prisma.$SpeakerCompanyPayload<ExtArgs>
        fields: Prisma.SpeakerCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpeakerCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpeakerCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>
          }
          findFirst: {
            args: Prisma.SpeakerCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpeakerCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>
          }
          findMany: {
            args: Prisma.SpeakerCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>[]
          }
          create: {
            args: Prisma.SpeakerCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>
          }
          createMany: {
            args: Prisma.SpeakerCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpeakerCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>[]
          }
          delete: {
            args: Prisma.SpeakerCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>
          }
          update: {
            args: Prisma.SpeakerCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>
          }
          deleteMany: {
            args: Prisma.SpeakerCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpeakerCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SpeakerCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>[]
          }
          upsert: {
            args: Prisma.SpeakerCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpeakerCompanyPayload>
          }
          aggregate: {
            args: Prisma.SpeakerCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpeakerCompany>
          }
          groupBy: {
            args: Prisma.SpeakerCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpeakerCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpeakerCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<SpeakerCompanyCountAggregateOutputType> | number
          }
        }
      }
      SessionSpeaker: {
        payload: Prisma.$SessionSpeakerPayload<ExtArgs>
        fields: Prisma.SessionSpeakerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionSpeakerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionSpeakerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
          }
          findFirst: {
            args: Prisma.SessionSpeakerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionSpeakerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
          }
          findMany: {
            args: Prisma.SessionSpeakerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>[]
          }
          create: {
            args: Prisma.SessionSpeakerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
          }
          createMany: {
            args: Prisma.SessionSpeakerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionSpeakerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>[]
          }
          delete: {
            args: Prisma.SessionSpeakerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
          }
          update: {
            args: Prisma.SessionSpeakerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
          }
          deleteMany: {
            args: Prisma.SessionSpeakerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionSpeakerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionSpeakerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>[]
          }
          upsert: {
            args: Prisma.SessionSpeakerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionSpeakerPayload>
          }
          aggregate: {
            args: Prisma.SessionSpeakerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessionSpeaker>
          }
          groupBy: {
            args: Prisma.SessionSpeakerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionSpeakerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionSpeakerCountArgs<ExtArgs>
            result: $Utils.Optional<SessionSpeakerCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    session?: SessionOmit
    topic?: TopicOmit
    sessionTopic?: SessionTopicOmit
    tag?: TagOmit
    sessionTag?: SessionTagOmit
    level?: LevelOmit
    sessionLevelOnSession?: SessionLevelOnSessionOmit
    audienceType?: AudienceTypeOmit
    sessionAudienceTypeOnSession?: SessionAudienceTypeOnSessionOmit
    industry?: IndustryOmit
    sessionIndustryOnSession?: SessionIndustryOnSessionOmit
    deliveryType?: DeliveryTypeOmit
    sessionDeliveryTypeOnSession?: SessionDeliveryTypeOnSessionOmit
    viewingOption?: ViewingOptionOmit
    sessionViewingOptionOnSession?: SessionViewingOptionOnSessionOmit
    speaker?: SpeakerOmit
    company?: CompanyOmit
    speakerCompany?: SpeakerCompanyOmit
    sessionSpeaker?: SessionSpeakerOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SessionCountOutputType
   */

  export type SessionCountOutputType = {
    sessionTopics: number
    sessionTags: number
    sessionLevels: number
    sessionAudienceTypes: number
    sessionIndustries: number
    sessionDeliveryTypes: number
    sessionViewingOpts: number
    sessionSpeakers: number
  }

  export type SessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionTopics?: boolean | SessionCountOutputTypeCountSessionTopicsArgs
    sessionTags?: boolean | SessionCountOutputTypeCountSessionTagsArgs
    sessionLevels?: boolean | SessionCountOutputTypeCountSessionLevelsArgs
    sessionAudienceTypes?: boolean | SessionCountOutputTypeCountSessionAudienceTypesArgs
    sessionIndustries?: boolean | SessionCountOutputTypeCountSessionIndustriesArgs
    sessionDeliveryTypes?: boolean | SessionCountOutputTypeCountSessionDeliveryTypesArgs
    sessionViewingOpts?: boolean | SessionCountOutputTypeCountSessionViewingOptsArgs
    sessionSpeakers?: boolean | SessionCountOutputTypeCountSessionSpeakersArgs
  }

  // Custom InputTypes
  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionCountOutputType
     */
    select?: SessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTopicWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTagWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLevelOnSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionAudienceTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAudienceTypeOnSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionIndustriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionIndustryOnSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionDeliveryTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionDeliveryTypeOnSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionViewingOptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionViewingOptionOnSessionWhereInput
  }

  /**
   * SessionCountOutputType without action
   */
  export type SessionCountOutputTypeCountSessionSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionSpeakerWhereInput
  }


  /**
   * Count Type TopicCountOutputType
   */

  export type TopicCountOutputType = {
    sessions: number
  }

  export type TopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TopicCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TopicCountOutputType
     */
    select?: TopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TopicCountOutputType without action
   */
  export type TopicCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTopicWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    sessions: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TagCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTagWhereInput
  }


  /**
   * Count Type LevelCountOutputType
   */

  export type LevelCountOutputType = {
    sessions: number
  }

  export type LevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | LevelCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LevelCountOutputType
     */
    select?: LevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LevelCountOutputType without action
   */
  export type LevelCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLevelOnSessionWhereInput
  }


  /**
   * Count Type AudienceTypeCountOutputType
   */

  export type AudienceTypeCountOutputType = {
    sessions: number
  }

  export type AudienceTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AudienceTypeCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * AudienceTypeCountOutputType without action
   */
  export type AudienceTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceTypeCountOutputType
     */
    select?: AudienceTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AudienceTypeCountOutputType without action
   */
  export type AudienceTypeCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAudienceTypeOnSessionWhereInput
  }


  /**
   * Count Type IndustryCountOutputType
   */

  export type IndustryCountOutputType = {
    sessions: number
  }

  export type IndustryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | IndustryCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IndustryCountOutputType
     */
    select?: IndustryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IndustryCountOutputType without action
   */
  export type IndustryCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionIndustryOnSessionWhereInput
  }


  /**
   * Count Type DeliveryTypeCountOutputType
   */

  export type DeliveryTypeCountOutputType = {
    sessions: number
  }

  export type DeliveryTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | DeliveryTypeCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * DeliveryTypeCountOutputType without action
   */
  export type DeliveryTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryTypeCountOutputType
     */
    select?: DeliveryTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DeliveryTypeCountOutputType without action
   */
  export type DeliveryTypeCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionDeliveryTypeOnSessionWhereInput
  }


  /**
   * Count Type ViewingOptionCountOutputType
   */

  export type ViewingOptionCountOutputType = {
    sessions: number
  }

  export type ViewingOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ViewingOptionCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * ViewingOptionCountOutputType without action
   */
  export type ViewingOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOptionCountOutputType
     */
    select?: ViewingOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ViewingOptionCountOutputType without action
   */
  export type ViewingOptionCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionViewingOptionOnSessionWhereInput
  }


  /**
   * Count Type SpeakerCountOutputType
   */

  export type SpeakerCountOutputType = {
    sessionSpeakers: number
    speakerCompanies: number
  }

  export type SpeakerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionSpeakers?: boolean | SpeakerCountOutputTypeCountSessionSpeakersArgs
    speakerCompanies?: boolean | SpeakerCountOutputTypeCountSpeakerCompaniesArgs
  }

  // Custom InputTypes
  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCountOutputType
     */
    select?: SpeakerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeCountSessionSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionSpeakerWhereInput
  }

  /**
   * SpeakerCountOutputType without action
   */
  export type SpeakerCountOutputTypeCountSpeakerCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerCompanyWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    speakerCompanies: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speakerCompanies?: boolean | CompanyCountOutputTypeCountSpeakerCompaniesArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSpeakerCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerCompanyWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionAvgAggregateOutputType = {
    id: number | null
    durationInMinutes: number | null
  }

  export type SessionSumAggregateOutputType = {
    id: number | null
    durationInMinutes: number | null
  }

  export type SessionMinAggregateOutputType = {
    id: number | null
    sessionId: string | null
    sessionInstanceId: string | null
    localizedId: string | null
    sessionCode: string | null
    langLocale: string | null
    title: string | null
    sortTitle: string | null
    description: string | null
    aiDescription: string | null
    location: string | null
    timeSlot: string | null
    startDateTime: Date | null
    endDateTime: Date | null
    durationInMinutes: number | null
    sessionTypeDisplay: string | null
    sessionTypeLogical: string | null
    reportingTopic: string | null
    onDemandUrl: string | null
    downloadVideoUrl: string | null
    captionFileUrl: string | null
    thumbnailUrl: string | null
    registrationLink: string | null
    hasOnDemand: boolean | null
    isPopular: boolean | null
    heroSession: boolean | null
  }

  export type SessionMaxAggregateOutputType = {
    id: number | null
    sessionId: string | null
    sessionInstanceId: string | null
    localizedId: string | null
    sessionCode: string | null
    langLocale: string | null
    title: string | null
    sortTitle: string | null
    description: string | null
    aiDescription: string | null
    location: string | null
    timeSlot: string | null
    startDateTime: Date | null
    endDateTime: Date | null
    durationInMinutes: number | null
    sessionTypeDisplay: string | null
    sessionTypeLogical: string | null
    reportingTopic: string | null
    onDemandUrl: string | null
    downloadVideoUrl: string | null
    captionFileUrl: string | null
    thumbnailUrl: string | null
    registrationLink: string | null
    hasOnDemand: boolean | null
    isPopular: boolean | null
    heroSession: boolean | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionId: number
    sessionInstanceId: number
    localizedId: number
    sessionCode: number
    langLocale: number
    title: number
    sortTitle: number
    description: number
    aiDescription: number
    location: number
    timeSlot: number
    startDateTime: number
    endDateTime: number
    durationInMinutes: number
    sessionTypeDisplay: number
    sessionTypeLogical: number
    reportingTopic: number
    onDemandUrl: number
    downloadVideoUrl: number
    captionFileUrl: number
    thumbnailUrl: number
    registrationLink: number
    hasOnDemand: number
    isPopular: number
    heroSession: number
    _all: number
  }


  export type SessionAvgAggregateInputType = {
    id?: true
    durationInMinutes?: true
  }

  export type SessionSumAggregateInputType = {
    id?: true
    durationInMinutes?: true
  }

  export type SessionMinAggregateInputType = {
    id?: true
    sessionId?: true
    sessionInstanceId?: true
    localizedId?: true
    sessionCode?: true
    langLocale?: true
    title?: true
    sortTitle?: true
    description?: true
    aiDescription?: true
    location?: true
    timeSlot?: true
    startDateTime?: true
    endDateTime?: true
    durationInMinutes?: true
    sessionTypeDisplay?: true
    sessionTypeLogical?: true
    reportingTopic?: true
    onDemandUrl?: true
    downloadVideoUrl?: true
    captionFileUrl?: true
    thumbnailUrl?: true
    registrationLink?: true
    hasOnDemand?: true
    isPopular?: true
    heroSession?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionId?: true
    sessionInstanceId?: true
    localizedId?: true
    sessionCode?: true
    langLocale?: true
    title?: true
    sortTitle?: true
    description?: true
    aiDescription?: true
    location?: true
    timeSlot?: true
    startDateTime?: true
    endDateTime?: true
    durationInMinutes?: true
    sessionTypeDisplay?: true
    sessionTypeLogical?: true
    reportingTopic?: true
    onDemandUrl?: true
    downloadVideoUrl?: true
    captionFileUrl?: true
    thumbnailUrl?: true
    registrationLink?: true
    hasOnDemand?: true
    isPopular?: true
    heroSession?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionId?: true
    sessionInstanceId?: true
    localizedId?: true
    sessionCode?: true
    langLocale?: true
    title?: true
    sortTitle?: true
    description?: true
    aiDescription?: true
    location?: true
    timeSlot?: true
    startDateTime?: true
    endDateTime?: true
    durationInMinutes?: true
    sessionTypeDisplay?: true
    sessionTypeLogical?: true
    reportingTopic?: true
    onDemandUrl?: true
    downloadVideoUrl?: true
    captionFileUrl?: true
    thumbnailUrl?: true
    registrationLink?: true
    hasOnDemand?: true
    isPopular?: true
    heroSession?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _avg?: SessionAvgAggregateInputType
    _sum?: SessionSumAggregateInputType
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: number
    sessionId: string
    sessionInstanceId: string | null
    localizedId: string | null
    sessionCode: string | null
    langLocale: string | null
    title: string
    sortTitle: string | null
    description: string | null
    aiDescription: string | null
    location: string | null
    timeSlot: string | null
    startDateTime: Date | null
    endDateTime: Date | null
    durationInMinutes: number | null
    sessionTypeDisplay: string | null
    sessionTypeLogical: string | null
    reportingTopic: string | null
    onDemandUrl: string | null
    downloadVideoUrl: string | null
    captionFileUrl: string | null
    thumbnailUrl: string | null
    registrationLink: string | null
    hasOnDemand: boolean
    isPopular: boolean
    heroSession: boolean
    _count: SessionCountAggregateOutputType | null
    _avg: SessionAvgAggregateOutputType | null
    _sum: SessionSumAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionInstanceId?: boolean
    localizedId?: boolean
    sessionCode?: boolean
    langLocale?: boolean
    title?: boolean
    sortTitle?: boolean
    description?: boolean
    aiDescription?: boolean
    location?: boolean
    timeSlot?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    durationInMinutes?: boolean
    sessionTypeDisplay?: boolean
    sessionTypeLogical?: boolean
    reportingTopic?: boolean
    onDemandUrl?: boolean
    downloadVideoUrl?: boolean
    captionFileUrl?: boolean
    thumbnailUrl?: boolean
    registrationLink?: boolean
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: boolean | Session$sessionTopicsArgs<ExtArgs>
    sessionTags?: boolean | Session$sessionTagsArgs<ExtArgs>
    sessionLevels?: boolean | Session$sessionLevelsArgs<ExtArgs>
    sessionAudienceTypes?: boolean | Session$sessionAudienceTypesArgs<ExtArgs>
    sessionIndustries?: boolean | Session$sessionIndustriesArgs<ExtArgs>
    sessionDeliveryTypes?: boolean | Session$sessionDeliveryTypesArgs<ExtArgs>
    sessionViewingOpts?: boolean | Session$sessionViewingOptsArgs<ExtArgs>
    sessionSpeakers?: boolean | Session$sessionSpeakersArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionInstanceId?: boolean
    localizedId?: boolean
    sessionCode?: boolean
    langLocale?: boolean
    title?: boolean
    sortTitle?: boolean
    description?: boolean
    aiDescription?: boolean
    location?: boolean
    timeSlot?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    durationInMinutes?: boolean
    sessionTypeDisplay?: boolean
    sessionTypeLogical?: boolean
    reportingTopic?: boolean
    onDemandUrl?: boolean
    downloadVideoUrl?: boolean
    captionFileUrl?: boolean
    thumbnailUrl?: boolean
    registrationLink?: boolean
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    sessionInstanceId?: boolean
    localizedId?: boolean
    sessionCode?: boolean
    langLocale?: boolean
    title?: boolean
    sortTitle?: boolean
    description?: boolean
    aiDescription?: boolean
    location?: boolean
    timeSlot?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    durationInMinutes?: boolean
    sessionTypeDisplay?: boolean
    sessionTypeLogical?: boolean
    reportingTopic?: boolean
    onDemandUrl?: boolean
    downloadVideoUrl?: boolean
    captionFileUrl?: boolean
    thumbnailUrl?: boolean
    registrationLink?: boolean
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionId?: boolean
    sessionInstanceId?: boolean
    localizedId?: boolean
    sessionCode?: boolean
    langLocale?: boolean
    title?: boolean
    sortTitle?: boolean
    description?: boolean
    aiDescription?: boolean
    location?: boolean
    timeSlot?: boolean
    startDateTime?: boolean
    endDateTime?: boolean
    durationInMinutes?: boolean
    sessionTypeDisplay?: boolean
    sessionTypeLogical?: boolean
    reportingTopic?: boolean
    onDemandUrl?: boolean
    downloadVideoUrl?: boolean
    captionFileUrl?: boolean
    thumbnailUrl?: boolean
    registrationLink?: boolean
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionId" | "sessionInstanceId" | "localizedId" | "sessionCode" | "langLocale" | "title" | "sortTitle" | "description" | "aiDescription" | "location" | "timeSlot" | "startDateTime" | "endDateTime" | "durationInMinutes" | "sessionTypeDisplay" | "sessionTypeLogical" | "reportingTopic" | "onDemandUrl" | "downloadVideoUrl" | "captionFileUrl" | "thumbnailUrl" | "registrationLink" | "hasOnDemand" | "isPopular" | "heroSession", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionTopics?: boolean | Session$sessionTopicsArgs<ExtArgs>
    sessionTags?: boolean | Session$sessionTagsArgs<ExtArgs>
    sessionLevels?: boolean | Session$sessionLevelsArgs<ExtArgs>
    sessionAudienceTypes?: boolean | Session$sessionAudienceTypesArgs<ExtArgs>
    sessionIndustries?: boolean | Session$sessionIndustriesArgs<ExtArgs>
    sessionDeliveryTypes?: boolean | Session$sessionDeliveryTypesArgs<ExtArgs>
    sessionViewingOpts?: boolean | Session$sessionViewingOptsArgs<ExtArgs>
    sessionSpeakers?: boolean | Session$sessionSpeakersArgs<ExtArgs>
    _count?: boolean | SessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      sessionTopics: Prisma.$SessionTopicPayload<ExtArgs>[]
      sessionTags: Prisma.$SessionTagPayload<ExtArgs>[]
      sessionLevels: Prisma.$SessionLevelOnSessionPayload<ExtArgs>[]
      sessionAudienceTypes: Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>[]
      sessionIndustries: Prisma.$SessionIndustryOnSessionPayload<ExtArgs>[]
      sessionDeliveryTypes: Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>[]
      sessionViewingOpts: Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>[]
      sessionSpeakers: Prisma.$SessionSpeakerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessionId: string
      sessionInstanceId: string | null
      localizedId: string | null
      sessionCode: string | null
      langLocale: string | null
      title: string
      sortTitle: string | null
      description: string | null
      aiDescription: string | null
      location: string | null
      timeSlot: string | null
      startDateTime: Date | null
      endDateTime: Date | null
      durationInMinutes: number | null
      sessionTypeDisplay: string | null
      sessionTypeLogical: string | null
      reportingTopic: string | null
      onDemandUrl: string | null
      downloadVideoUrl: string | null
      captionFileUrl: string | null
      thumbnailUrl: string | null
      registrationLink: string | null
      hasOnDemand: boolean
      isPopular: boolean
      heroSession: boolean
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessionTopics<T extends Session$sessionTopicsArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionTopicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionTags<T extends Session$sessionTagsArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionLevels<T extends Session$sessionLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionAudienceTypes<T extends Session$sessionAudienceTypesArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionAudienceTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionIndustries<T extends Session$sessionIndustriesArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionIndustriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionDeliveryTypes<T extends Session$sessionDeliveryTypesArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionDeliveryTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionViewingOpts<T extends Session$sessionViewingOptsArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionViewingOptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessionSpeakers<T extends Session$sessionSpeakersArgs<ExtArgs> = {}>(args?: Subset<T, Session$sessionSpeakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'Int'>
    readonly sessionId: FieldRef<"Session", 'String'>
    readonly sessionInstanceId: FieldRef<"Session", 'String'>
    readonly localizedId: FieldRef<"Session", 'String'>
    readonly sessionCode: FieldRef<"Session", 'String'>
    readonly langLocale: FieldRef<"Session", 'String'>
    readonly title: FieldRef<"Session", 'String'>
    readonly sortTitle: FieldRef<"Session", 'String'>
    readonly description: FieldRef<"Session", 'String'>
    readonly aiDescription: FieldRef<"Session", 'String'>
    readonly location: FieldRef<"Session", 'String'>
    readonly timeSlot: FieldRef<"Session", 'String'>
    readonly startDateTime: FieldRef<"Session", 'DateTime'>
    readonly endDateTime: FieldRef<"Session", 'DateTime'>
    readonly durationInMinutes: FieldRef<"Session", 'Int'>
    readonly sessionTypeDisplay: FieldRef<"Session", 'String'>
    readonly sessionTypeLogical: FieldRef<"Session", 'String'>
    readonly reportingTopic: FieldRef<"Session", 'String'>
    readonly onDemandUrl: FieldRef<"Session", 'String'>
    readonly downloadVideoUrl: FieldRef<"Session", 'String'>
    readonly captionFileUrl: FieldRef<"Session", 'String'>
    readonly thumbnailUrl: FieldRef<"Session", 'String'>
    readonly registrationLink: FieldRef<"Session", 'String'>
    readonly hasOnDemand: FieldRef<"Session", 'Boolean'>
    readonly isPopular: FieldRef<"Session", 'Boolean'>
    readonly heroSession: FieldRef<"Session", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session.sessionTopics
   */
  export type Session$sessionTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    where?: SessionTopicWhereInput
    orderBy?: SessionTopicOrderByWithRelationInput | SessionTopicOrderByWithRelationInput[]
    cursor?: SessionTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionTopicScalarFieldEnum | SessionTopicScalarFieldEnum[]
  }

  /**
   * Session.sessionTags
   */
  export type Session$sessionTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    where?: SessionTagWhereInput
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    cursor?: SessionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * Session.sessionLevels
   */
  export type Session$sessionLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    where?: SessionLevelOnSessionWhereInput
    orderBy?: SessionLevelOnSessionOrderByWithRelationInput | SessionLevelOnSessionOrderByWithRelationInput[]
    cursor?: SessionLevelOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionLevelOnSessionScalarFieldEnum | SessionLevelOnSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionAudienceTypes
   */
  export type Session$sessionAudienceTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    where?: SessionAudienceTypeOnSessionWhereInput
    orderBy?: SessionAudienceTypeOnSessionOrderByWithRelationInput | SessionAudienceTypeOnSessionOrderByWithRelationInput[]
    cursor?: SessionAudienceTypeOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionAudienceTypeOnSessionScalarFieldEnum | SessionAudienceTypeOnSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionIndustries
   */
  export type Session$sessionIndustriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    where?: SessionIndustryOnSessionWhereInput
    orderBy?: SessionIndustryOnSessionOrderByWithRelationInput | SessionIndustryOnSessionOrderByWithRelationInput[]
    cursor?: SessionIndustryOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionIndustryOnSessionScalarFieldEnum | SessionIndustryOnSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionDeliveryTypes
   */
  export type Session$sessionDeliveryTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    where?: SessionDeliveryTypeOnSessionWhereInput
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithRelationInput | SessionDeliveryTypeOnSessionOrderByWithRelationInput[]
    cursor?: SessionDeliveryTypeOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionDeliveryTypeOnSessionScalarFieldEnum | SessionDeliveryTypeOnSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionViewingOpts
   */
  export type Session$sessionViewingOptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    where?: SessionViewingOptionOnSessionWhereInput
    orderBy?: SessionViewingOptionOnSessionOrderByWithRelationInput | SessionViewingOptionOnSessionOrderByWithRelationInput[]
    cursor?: SessionViewingOptionOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionViewingOptionOnSessionScalarFieldEnum | SessionViewingOptionOnSessionScalarFieldEnum[]
  }

  /**
   * Session.sessionSpeakers
   */
  export type Session$sessionSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    where?: SessionSpeakerWhereInput
    orderBy?: SessionSpeakerOrderByWithRelationInput | SessionSpeakerOrderByWithRelationInput[]
    cursor?: SessionSpeakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionSpeakerScalarFieldEnum | SessionSpeakerScalarFieldEnum[]
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Topic
   */

  export type AggregateTopic = {
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  export type TopicAvgAggregateOutputType = {
    id: number | null
  }

  export type TopicSumAggregateOutputType = {
    id: number | null
  }

  export type TopicMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type TopicMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type TopicCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type TopicAvgAggregateInputType = {
    id?: true
  }

  export type TopicSumAggregateInputType = {
    id?: true
  }

  export type TopicMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type TopicMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type TopicCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type TopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topic to aggregate.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Topics
    **/
    _count?: true | TopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TopicMaxAggregateInputType
  }

  export type GetTopicAggregateType<T extends TopicAggregateArgs> = {
        [P in keyof T & keyof AggregateTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTopic[P]>
      : GetScalarType<T[P], AggregateTopic[P]>
  }




  export type TopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TopicWhereInput
    orderBy?: TopicOrderByWithAggregationInput | TopicOrderByWithAggregationInput[]
    by: TopicScalarFieldEnum[] | TopicScalarFieldEnum
    having?: TopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TopicCountAggregateInputType | true
    _avg?: TopicAvgAggregateInputType
    _sum?: TopicSumAggregateInputType
    _min?: TopicMinAggregateInputType
    _max?: TopicMaxAggregateInputType
  }

  export type TopicGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: TopicCountAggregateOutputType | null
    _avg: TopicAvgAggregateOutputType | null
    _sum: TopicSumAggregateOutputType | null
    _min: TopicMinAggregateOutputType | null
    _max: TopicMaxAggregateOutputType | null
  }

  type GetTopicGroupByPayload<T extends TopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TopicGroupByOutputType[P]>
            : GetScalarType<T[P], TopicGroupByOutputType[P]>
        }
      >
    >


  export type TopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | Topic$sessionsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["topic"]>

  export type TopicSelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type TopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["topic"]>
  export type TopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Topic$sessionsArgs<ExtArgs>
    _count?: boolean | TopicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Topic"
    objects: {
      sessions: Prisma.$SessionTopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["topic"]>
    composites: {}
  }

  type TopicGetPayload<S extends boolean | null | undefined | TopicDefaultArgs> = $Result.GetResult<Prisma.$TopicPayload, S>

  type TopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TopicCountAggregateInputType | true
    }

  export interface TopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Topic'], meta: { name: 'Topic' } }
    /**
     * Find zero or one Topic that matches the filter.
     * @param {TopicFindUniqueArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TopicFindUniqueArgs>(args: SelectSubset<T, TopicFindUniqueArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Topic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TopicFindUniqueOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TopicFindUniqueOrThrowArgs>(args: SelectSubset<T, TopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TopicFindFirstArgs>(args?: SelectSubset<T, TopicFindFirstArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Topic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindFirstOrThrowArgs} args - Arguments to find a Topic
     * @example
     * // Get one Topic
     * const topic = await prisma.topic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TopicFindFirstOrThrowArgs>(args?: SelectSubset<T, TopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Topics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Topics
     * const topics = await prisma.topic.findMany()
     * 
     * // Get first 10 Topics
     * const topics = await prisma.topic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const topicWithIdOnly = await prisma.topic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TopicFindManyArgs>(args?: SelectSubset<T, TopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Topic.
     * @param {TopicCreateArgs} args - Arguments to create a Topic.
     * @example
     * // Create one Topic
     * const Topic = await prisma.topic.create({
     *   data: {
     *     // ... data to create a Topic
     *   }
     * })
     * 
     */
    create<T extends TopicCreateArgs>(args: SelectSubset<T, TopicCreateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Topics.
     * @param {TopicCreateManyArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TopicCreateManyArgs>(args?: SelectSubset<T, TopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Topics and returns the data saved in the database.
     * @param {TopicCreateManyAndReturnArgs} args - Arguments to create many Topics.
     * @example
     * // Create many Topics
     * const topic = await prisma.topic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TopicCreateManyAndReturnArgs>(args?: SelectSubset<T, TopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Topic.
     * @param {TopicDeleteArgs} args - Arguments to delete one Topic.
     * @example
     * // Delete one Topic
     * const Topic = await prisma.topic.delete({
     *   where: {
     *     // ... filter to delete one Topic
     *   }
     * })
     * 
     */
    delete<T extends TopicDeleteArgs>(args: SelectSubset<T, TopicDeleteArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Topic.
     * @param {TopicUpdateArgs} args - Arguments to update one Topic.
     * @example
     * // Update one Topic
     * const topic = await prisma.topic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TopicUpdateArgs>(args: SelectSubset<T, TopicUpdateArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Topics.
     * @param {TopicDeleteManyArgs} args - Arguments to filter Topics to delete.
     * @example
     * // Delete a few Topics
     * const { count } = await prisma.topic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TopicDeleteManyArgs>(args?: SelectSubset<T, TopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TopicUpdateManyArgs>(args: SelectSubset<T, TopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Topics and returns the data updated in the database.
     * @param {TopicUpdateManyAndReturnArgs} args - Arguments to update many Topics.
     * @example
     * // Update many Topics
     * const topic = await prisma.topic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Topics and only return the `id`
     * const topicWithIdOnly = await prisma.topic.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TopicUpdateManyAndReturnArgs>(args: SelectSubset<T, TopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Topic.
     * @param {TopicUpsertArgs} args - Arguments to update or create a Topic.
     * @example
     * // Update or create a Topic
     * const topic = await prisma.topic.upsert({
     *   create: {
     *     // ... data to create a Topic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Topic we want to update
     *   }
     * })
     */
    upsert<T extends TopicUpsertArgs>(args: SelectSubset<T, TopicUpsertArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Topics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicCountArgs} args - Arguments to filter Topics to count.
     * @example
     * // Count the number of Topics
     * const count = await prisma.topic.count({
     *   where: {
     *     // ... the filter for the Topics we want to count
     *   }
     * })
    **/
    count<T extends TopicCountArgs>(
      args?: Subset<T, TopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TopicAggregateArgs>(args: Subset<T, TopicAggregateArgs>): Prisma.PrismaPromise<GetTopicAggregateType<T>>

    /**
     * Group by Topic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TopicGroupByArgs['orderBy'] }
        : { orderBy?: TopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Topic model
   */
  readonly fields: TopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Topic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Topic$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Topic$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Topic model
   */
  interface TopicFieldRefs {
    readonly id: FieldRef<"Topic", 'Int'>
    readonly logicalValue: FieldRef<"Topic", 'String'>
    readonly displayValue: FieldRef<"Topic", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Topic findUnique
   */
  export type TopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findUniqueOrThrow
   */
  export type TopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic findFirst
   */
  export type TopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findFirstOrThrow
   */
  export type TopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topic to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Topics.
     */
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic findMany
   */
  export type TopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter, which Topics to fetch.
     */
    where?: TopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Topics to fetch.
     */
    orderBy?: TopicOrderByWithRelationInput | TopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Topics.
     */
    cursor?: TopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Topics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Topics.
     */
    skip?: number
    distinct?: TopicScalarFieldEnum | TopicScalarFieldEnum[]
  }

  /**
   * Topic create
   */
  export type TopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to create a Topic.
     */
    data: XOR<TopicCreateInput, TopicUncheckedCreateInput>
  }

  /**
   * Topic createMany
   */
  export type TopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
  }

  /**
   * Topic createManyAndReturn
   */
  export type TopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to create many Topics.
     */
    data: TopicCreateManyInput | TopicCreateManyInput[]
  }

  /**
   * Topic update
   */
  export type TopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The data needed to update a Topic.
     */
    data: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
    /**
     * Choose, which Topic to update.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic updateMany
   */
  export type TopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic updateManyAndReturn
   */
  export type TopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * The data used to update Topics.
     */
    data: XOR<TopicUpdateManyMutationInput, TopicUncheckedUpdateManyInput>
    /**
     * Filter which Topics to update
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to update.
     */
    limit?: number
  }

  /**
   * Topic upsert
   */
  export type TopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * The filter to search for the Topic to update in case it exists.
     */
    where: TopicWhereUniqueInput
    /**
     * In case the Topic found by the `where` argument doesn't exist, create a new Topic with this data.
     */
    create: XOR<TopicCreateInput, TopicUncheckedCreateInput>
    /**
     * In case the Topic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TopicUpdateInput, TopicUncheckedUpdateInput>
  }

  /**
   * Topic delete
   */
  export type TopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
    /**
     * Filter which Topic to delete.
     */
    where: TopicWhereUniqueInput
  }

  /**
   * Topic deleteMany
   */
  export type TopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Topics to delete
     */
    where?: TopicWhereInput
    /**
     * Limit how many Topics to delete.
     */
    limit?: number
  }

  /**
   * Topic.sessions
   */
  export type Topic$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    where?: SessionTopicWhereInput
    orderBy?: SessionTopicOrderByWithRelationInput | SessionTopicOrderByWithRelationInput[]
    cursor?: SessionTopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionTopicScalarFieldEnum | SessionTopicScalarFieldEnum[]
  }

  /**
   * Topic without action
   */
  export type TopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Topic
     */
    select?: TopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Topic
     */
    omit?: TopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TopicInclude<ExtArgs> | null
  }


  /**
   * Model SessionTopic
   */

  export type AggregateSessionTopic = {
    _count: SessionTopicCountAggregateOutputType | null
    _avg: SessionTopicAvgAggregateOutputType | null
    _sum: SessionTopicSumAggregateOutputType | null
    _min: SessionTopicMinAggregateOutputType | null
    _max: SessionTopicMaxAggregateOutputType | null
  }

  export type SessionTopicAvgAggregateOutputType = {
    sessionId: number | null
    topicId: number | null
  }

  export type SessionTopicSumAggregateOutputType = {
    sessionId: number | null
    topicId: number | null
  }

  export type SessionTopicMinAggregateOutputType = {
    sessionId: number | null
    topicId: number | null
  }

  export type SessionTopicMaxAggregateOutputType = {
    sessionId: number | null
    topicId: number | null
  }

  export type SessionTopicCountAggregateOutputType = {
    sessionId: number
    topicId: number
    _all: number
  }


  export type SessionTopicAvgAggregateInputType = {
    sessionId?: true
    topicId?: true
  }

  export type SessionTopicSumAggregateInputType = {
    sessionId?: true
    topicId?: true
  }

  export type SessionTopicMinAggregateInputType = {
    sessionId?: true
    topicId?: true
  }

  export type SessionTopicMaxAggregateInputType = {
    sessionId?: true
    topicId?: true
  }

  export type SessionTopicCountAggregateInputType = {
    sessionId?: true
    topicId?: true
    _all?: true
  }

  export type SessionTopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTopic to aggregate.
     */
    where?: SessionTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTopics to fetch.
     */
    orderBy?: SessionTopicOrderByWithRelationInput | SessionTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionTopics
    **/
    _count?: true | SessionTopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionTopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionTopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionTopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionTopicMaxAggregateInputType
  }

  export type GetSessionTopicAggregateType<T extends SessionTopicAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionTopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionTopic[P]>
      : GetScalarType<T[P], AggregateSessionTopic[P]>
  }




  export type SessionTopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTopicWhereInput
    orderBy?: SessionTopicOrderByWithAggregationInput | SessionTopicOrderByWithAggregationInput[]
    by: SessionTopicScalarFieldEnum[] | SessionTopicScalarFieldEnum
    having?: SessionTopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionTopicCountAggregateInputType | true
    _avg?: SessionTopicAvgAggregateInputType
    _sum?: SessionTopicSumAggregateInputType
    _min?: SessionTopicMinAggregateInputType
    _max?: SessionTopicMaxAggregateInputType
  }

  export type SessionTopicGroupByOutputType = {
    sessionId: number
    topicId: number
    _count: SessionTopicCountAggregateOutputType | null
    _avg: SessionTopicAvgAggregateOutputType | null
    _sum: SessionTopicSumAggregateOutputType | null
    _min: SessionTopicMinAggregateOutputType | null
    _max: SessionTopicMaxAggregateOutputType | null
  }

  type GetSessionTopicGroupByPayload<T extends SessionTopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionTopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionTopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionTopicGroupByOutputType[P]>
            : GetScalarType<T[P], SessionTopicGroupByOutputType[P]>
        }
      >
    >


  export type SessionTopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    topicId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTopic"]>

  export type SessionTopicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    topicId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTopic"]>

  export type SessionTopicSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    topicId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTopic"]>

  export type SessionTopicSelectScalar = {
    sessionId?: boolean
    topicId?: boolean
  }

  export type SessionTopicOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "topicId", ExtArgs["result"]["sessionTopic"]>
  export type SessionTopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type SessionTopicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }
  export type SessionTopicIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    topic?: boolean | TopicDefaultArgs<ExtArgs>
  }

  export type $SessionTopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionTopic"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      topic: Prisma.$TopicPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      topicId: number
    }, ExtArgs["result"]["sessionTopic"]>
    composites: {}
  }

  type SessionTopicGetPayload<S extends boolean | null | undefined | SessionTopicDefaultArgs> = $Result.GetResult<Prisma.$SessionTopicPayload, S>

  type SessionTopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionTopicFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionTopicCountAggregateInputType | true
    }

  export interface SessionTopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionTopic'], meta: { name: 'SessionTopic' } }
    /**
     * Find zero or one SessionTopic that matches the filter.
     * @param {SessionTopicFindUniqueArgs} args - Arguments to find a SessionTopic
     * @example
     * // Get one SessionTopic
     * const sessionTopic = await prisma.sessionTopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionTopicFindUniqueArgs>(args: SelectSubset<T, SessionTopicFindUniqueArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionTopic that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionTopicFindUniqueOrThrowArgs} args - Arguments to find a SessionTopic
     * @example
     * // Get one SessionTopic
     * const sessionTopic = await prisma.sessionTopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionTopicFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionTopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicFindFirstArgs} args - Arguments to find a SessionTopic
     * @example
     * // Get one SessionTopic
     * const sessionTopic = await prisma.sessionTopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionTopicFindFirstArgs>(args?: SelectSubset<T, SessionTopicFindFirstArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicFindFirstOrThrowArgs} args - Arguments to find a SessionTopic
     * @example
     * // Get one SessionTopic
     * const sessionTopic = await prisma.sessionTopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionTopicFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionTopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionTopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionTopics
     * const sessionTopics = await prisma.sessionTopic.findMany()
     * 
     * // Get first 10 SessionTopics
     * const sessionTopics = await prisma.sessionTopic.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionTopicWithSessionIdOnly = await prisma.sessionTopic.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionTopicFindManyArgs>(args?: SelectSubset<T, SessionTopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionTopic.
     * @param {SessionTopicCreateArgs} args - Arguments to create a SessionTopic.
     * @example
     * // Create one SessionTopic
     * const SessionTopic = await prisma.sessionTopic.create({
     *   data: {
     *     // ... data to create a SessionTopic
     *   }
     * })
     * 
     */
    create<T extends SessionTopicCreateArgs>(args: SelectSubset<T, SessionTopicCreateArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionTopics.
     * @param {SessionTopicCreateManyArgs} args - Arguments to create many SessionTopics.
     * @example
     * // Create many SessionTopics
     * const sessionTopic = await prisma.sessionTopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionTopicCreateManyArgs>(args?: SelectSubset<T, SessionTopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionTopics and returns the data saved in the database.
     * @param {SessionTopicCreateManyAndReturnArgs} args - Arguments to create many SessionTopics.
     * @example
     * // Create many SessionTopics
     * const sessionTopic = await prisma.sessionTopic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionTopics and only return the `sessionId`
     * const sessionTopicWithSessionIdOnly = await prisma.sessionTopic.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionTopicCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionTopicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionTopic.
     * @param {SessionTopicDeleteArgs} args - Arguments to delete one SessionTopic.
     * @example
     * // Delete one SessionTopic
     * const SessionTopic = await prisma.sessionTopic.delete({
     *   where: {
     *     // ... filter to delete one SessionTopic
     *   }
     * })
     * 
     */
    delete<T extends SessionTopicDeleteArgs>(args: SelectSubset<T, SessionTopicDeleteArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionTopic.
     * @param {SessionTopicUpdateArgs} args - Arguments to update one SessionTopic.
     * @example
     * // Update one SessionTopic
     * const sessionTopic = await prisma.sessionTopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionTopicUpdateArgs>(args: SelectSubset<T, SessionTopicUpdateArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionTopics.
     * @param {SessionTopicDeleteManyArgs} args - Arguments to filter SessionTopics to delete.
     * @example
     * // Delete a few SessionTopics
     * const { count } = await prisma.sessionTopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionTopicDeleteManyArgs>(args?: SelectSubset<T, SessionTopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionTopics
     * const sessionTopic = await prisma.sessionTopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionTopicUpdateManyArgs>(args: SelectSubset<T, SessionTopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTopics and returns the data updated in the database.
     * @param {SessionTopicUpdateManyAndReturnArgs} args - Arguments to update many SessionTopics.
     * @example
     * // Update many SessionTopics
     * const sessionTopic = await prisma.sessionTopic.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionTopics and only return the `sessionId`
     * const sessionTopicWithSessionIdOnly = await prisma.sessionTopic.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionTopicUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionTopicUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionTopic.
     * @param {SessionTopicUpsertArgs} args - Arguments to update or create a SessionTopic.
     * @example
     * // Update or create a SessionTopic
     * const sessionTopic = await prisma.sessionTopic.upsert({
     *   create: {
     *     // ... data to create a SessionTopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionTopic we want to update
     *   }
     * })
     */
    upsert<T extends SessionTopicUpsertArgs>(args: SelectSubset<T, SessionTopicUpsertArgs<ExtArgs>>): Prisma__SessionTopicClient<$Result.GetResult<Prisma.$SessionTopicPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionTopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicCountArgs} args - Arguments to filter SessionTopics to count.
     * @example
     * // Count the number of SessionTopics
     * const count = await prisma.sessionTopic.count({
     *   where: {
     *     // ... the filter for the SessionTopics we want to count
     *   }
     * })
    **/
    count<T extends SessionTopicCountArgs>(
      args?: Subset<T, SessionTopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionTopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionTopicAggregateArgs>(args: Subset<T, SessionTopicAggregateArgs>): Prisma.PrismaPromise<GetSessionTopicAggregateType<T>>

    /**
     * Group by SessionTopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionTopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionTopicGroupByArgs['orderBy'] }
        : { orderBy?: SessionTopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionTopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionTopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionTopic model
   */
  readonly fields: SessionTopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionTopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionTopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    topic<T extends TopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TopicDefaultArgs<ExtArgs>>): Prisma__TopicClient<$Result.GetResult<Prisma.$TopicPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionTopic model
   */
  interface SessionTopicFieldRefs {
    readonly sessionId: FieldRef<"SessionTopic", 'Int'>
    readonly topicId: FieldRef<"SessionTopic", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionTopic findUnique
   */
  export type SessionTopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * Filter, which SessionTopic to fetch.
     */
    where: SessionTopicWhereUniqueInput
  }

  /**
   * SessionTopic findUniqueOrThrow
   */
  export type SessionTopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * Filter, which SessionTopic to fetch.
     */
    where: SessionTopicWhereUniqueInput
  }

  /**
   * SessionTopic findFirst
   */
  export type SessionTopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * Filter, which SessionTopic to fetch.
     */
    where?: SessionTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTopics to fetch.
     */
    orderBy?: SessionTopicOrderByWithRelationInput | SessionTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTopics.
     */
    cursor?: SessionTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTopics.
     */
    distinct?: SessionTopicScalarFieldEnum | SessionTopicScalarFieldEnum[]
  }

  /**
   * SessionTopic findFirstOrThrow
   */
  export type SessionTopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * Filter, which SessionTopic to fetch.
     */
    where?: SessionTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTopics to fetch.
     */
    orderBy?: SessionTopicOrderByWithRelationInput | SessionTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTopics.
     */
    cursor?: SessionTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTopics.
     */
    distinct?: SessionTopicScalarFieldEnum | SessionTopicScalarFieldEnum[]
  }

  /**
   * SessionTopic findMany
   */
  export type SessionTopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * Filter, which SessionTopics to fetch.
     */
    where?: SessionTopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTopics to fetch.
     */
    orderBy?: SessionTopicOrderByWithRelationInput | SessionTopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionTopics.
     */
    cursor?: SessionTopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTopics.
     */
    skip?: number
    distinct?: SessionTopicScalarFieldEnum | SessionTopicScalarFieldEnum[]
  }

  /**
   * SessionTopic create
   */
  export type SessionTopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionTopic.
     */
    data: XOR<SessionTopicCreateInput, SessionTopicUncheckedCreateInput>
  }

  /**
   * SessionTopic createMany
   */
  export type SessionTopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionTopics.
     */
    data: SessionTopicCreateManyInput | SessionTopicCreateManyInput[]
  }

  /**
   * SessionTopic createManyAndReturn
   */
  export type SessionTopicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * The data used to create many SessionTopics.
     */
    data: SessionTopicCreateManyInput | SessionTopicCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTopic update
   */
  export type SessionTopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionTopic.
     */
    data: XOR<SessionTopicUpdateInput, SessionTopicUncheckedUpdateInput>
    /**
     * Choose, which SessionTopic to update.
     */
    where: SessionTopicWhereUniqueInput
  }

  /**
   * SessionTopic updateMany
   */
  export type SessionTopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionTopics.
     */
    data: XOR<SessionTopicUpdateManyMutationInput, SessionTopicUncheckedUpdateManyInput>
    /**
     * Filter which SessionTopics to update
     */
    where?: SessionTopicWhereInput
    /**
     * Limit how many SessionTopics to update.
     */
    limit?: number
  }

  /**
   * SessionTopic updateManyAndReturn
   */
  export type SessionTopicUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * The data used to update SessionTopics.
     */
    data: XOR<SessionTopicUpdateManyMutationInput, SessionTopicUncheckedUpdateManyInput>
    /**
     * Filter which SessionTopics to update
     */
    where?: SessionTopicWhereInput
    /**
     * Limit how many SessionTopics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTopic upsert
   */
  export type SessionTopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionTopic to update in case it exists.
     */
    where: SessionTopicWhereUniqueInput
    /**
     * In case the SessionTopic found by the `where` argument doesn't exist, create a new SessionTopic with this data.
     */
    create: XOR<SessionTopicCreateInput, SessionTopicUncheckedCreateInput>
    /**
     * In case the SessionTopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionTopicUpdateInput, SessionTopicUncheckedUpdateInput>
  }

  /**
   * SessionTopic delete
   */
  export type SessionTopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
    /**
     * Filter which SessionTopic to delete.
     */
    where: SessionTopicWhereUniqueInput
  }

  /**
   * SessionTopic deleteMany
   */
  export type SessionTopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTopics to delete
     */
    where?: SessionTopicWhereInput
    /**
     * Limit how many SessionTopics to delete.
     */
    limit?: number
  }

  /**
   * SessionTopic without action
   */
  export type SessionTopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTopic
     */
    select?: SessionTopicSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTopic
     */
    omit?: SessionTopicOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTopicInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | Tag$sessionsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Tag$sessionsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      sessions: Prisma.$SessionTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Tag$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly logicalValue: FieldRef<"Tag", 'String'>
    readonly displayValue: FieldRef<"Tag", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.sessions
   */
  export type Tag$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    where?: SessionTagWhereInput
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    cursor?: SessionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model SessionTag
   */

  export type AggregateSessionTag = {
    _count: SessionTagCountAggregateOutputType | null
    _avg: SessionTagAvgAggregateOutputType | null
    _sum: SessionTagSumAggregateOutputType | null
    _min: SessionTagMinAggregateOutputType | null
    _max: SessionTagMaxAggregateOutputType | null
  }

  export type SessionTagAvgAggregateOutputType = {
    sessionId: number | null
    tagId: number | null
  }

  export type SessionTagSumAggregateOutputType = {
    sessionId: number | null
    tagId: number | null
  }

  export type SessionTagMinAggregateOutputType = {
    sessionId: number | null
    tagId: number | null
  }

  export type SessionTagMaxAggregateOutputType = {
    sessionId: number | null
    tagId: number | null
  }

  export type SessionTagCountAggregateOutputType = {
    sessionId: number
    tagId: number
    _all: number
  }


  export type SessionTagAvgAggregateInputType = {
    sessionId?: true
    tagId?: true
  }

  export type SessionTagSumAggregateInputType = {
    sessionId?: true
    tagId?: true
  }

  export type SessionTagMinAggregateInputType = {
    sessionId?: true
    tagId?: true
  }

  export type SessionTagMaxAggregateInputType = {
    sessionId?: true
    tagId?: true
  }

  export type SessionTagCountAggregateInputType = {
    sessionId?: true
    tagId?: true
    _all?: true
  }

  export type SessionTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTag to aggregate.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionTags
    **/
    _count?: true | SessionTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionTagMaxAggregateInputType
  }

  export type GetSessionTagAggregateType<T extends SessionTagAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionTag[P]>
      : GetScalarType<T[P], AggregateSessionTag[P]>
  }




  export type SessionTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionTagWhereInput
    orderBy?: SessionTagOrderByWithAggregationInput | SessionTagOrderByWithAggregationInput[]
    by: SessionTagScalarFieldEnum[] | SessionTagScalarFieldEnum
    having?: SessionTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionTagCountAggregateInputType | true
    _avg?: SessionTagAvgAggregateInputType
    _sum?: SessionTagSumAggregateInputType
    _min?: SessionTagMinAggregateInputType
    _max?: SessionTagMaxAggregateInputType
  }

  export type SessionTagGroupByOutputType = {
    sessionId: number
    tagId: number
    _count: SessionTagCountAggregateOutputType | null
    _avg: SessionTagAvgAggregateOutputType | null
    _sum: SessionTagSumAggregateOutputType | null
    _min: SessionTagMinAggregateOutputType | null
    _max: SessionTagMaxAggregateOutputType | null
  }

  type GetSessionTagGroupByPayload<T extends SessionTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionTagGroupByOutputType[P]>
            : GetScalarType<T[P], SessionTagGroupByOutputType[P]>
        }
      >
    >


  export type SessionTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    tagId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTag"]>

  export type SessionTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    tagId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTag"]>

  export type SessionTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    tagId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionTag"]>

  export type SessionTagSelectScalar = {
    sessionId?: boolean
    tagId?: boolean
  }

  export type SessionTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "tagId", ExtArgs["result"]["sessionTag"]>
  export type SessionTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type SessionTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type SessionTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $SessionTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionTag"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      tagId: number
    }, ExtArgs["result"]["sessionTag"]>
    composites: {}
  }

  type SessionTagGetPayload<S extends boolean | null | undefined | SessionTagDefaultArgs> = $Result.GetResult<Prisma.$SessionTagPayload, S>

  type SessionTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionTagCountAggregateInputType | true
    }

  export interface SessionTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionTag'], meta: { name: 'SessionTag' } }
    /**
     * Find zero or one SessionTag that matches the filter.
     * @param {SessionTagFindUniqueArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionTagFindUniqueArgs>(args: SelectSubset<T, SessionTagFindUniqueArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionTagFindUniqueOrThrowArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionTagFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagFindFirstArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionTagFindFirstArgs>(args?: SelectSubset<T, SessionTagFindFirstArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagFindFirstOrThrowArgs} args - Arguments to find a SessionTag
     * @example
     * // Get one SessionTag
     * const sessionTag = await prisma.sessionTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionTagFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionTags
     * const sessionTags = await prisma.sessionTag.findMany()
     * 
     * // Get first 10 SessionTags
     * const sessionTags = await prisma.sessionTag.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionTagWithSessionIdOnly = await prisma.sessionTag.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionTagFindManyArgs>(args?: SelectSubset<T, SessionTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionTag.
     * @param {SessionTagCreateArgs} args - Arguments to create a SessionTag.
     * @example
     * // Create one SessionTag
     * const SessionTag = await prisma.sessionTag.create({
     *   data: {
     *     // ... data to create a SessionTag
     *   }
     * })
     * 
     */
    create<T extends SessionTagCreateArgs>(args: SelectSubset<T, SessionTagCreateArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionTags.
     * @param {SessionTagCreateManyArgs} args - Arguments to create many SessionTags.
     * @example
     * // Create many SessionTags
     * const sessionTag = await prisma.sessionTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionTagCreateManyArgs>(args?: SelectSubset<T, SessionTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionTags and returns the data saved in the database.
     * @param {SessionTagCreateManyAndReturnArgs} args - Arguments to create many SessionTags.
     * @example
     * // Create many SessionTags
     * const sessionTag = await prisma.sessionTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionTags and only return the `sessionId`
     * const sessionTagWithSessionIdOnly = await prisma.sessionTag.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionTagCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionTag.
     * @param {SessionTagDeleteArgs} args - Arguments to delete one SessionTag.
     * @example
     * // Delete one SessionTag
     * const SessionTag = await prisma.sessionTag.delete({
     *   where: {
     *     // ... filter to delete one SessionTag
     *   }
     * })
     * 
     */
    delete<T extends SessionTagDeleteArgs>(args: SelectSubset<T, SessionTagDeleteArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionTag.
     * @param {SessionTagUpdateArgs} args - Arguments to update one SessionTag.
     * @example
     * // Update one SessionTag
     * const sessionTag = await prisma.sessionTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionTagUpdateArgs>(args: SelectSubset<T, SessionTagUpdateArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionTags.
     * @param {SessionTagDeleteManyArgs} args - Arguments to filter SessionTags to delete.
     * @example
     * // Delete a few SessionTags
     * const { count } = await prisma.sessionTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionTagDeleteManyArgs>(args?: SelectSubset<T, SessionTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionTags
     * const sessionTag = await prisma.sessionTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionTagUpdateManyArgs>(args: SelectSubset<T, SessionTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionTags and returns the data updated in the database.
     * @param {SessionTagUpdateManyAndReturnArgs} args - Arguments to update many SessionTags.
     * @example
     * // Update many SessionTags
     * const sessionTag = await prisma.sessionTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionTags and only return the `sessionId`
     * const sessionTagWithSessionIdOnly = await prisma.sessionTag.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionTagUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionTag.
     * @param {SessionTagUpsertArgs} args - Arguments to update or create a SessionTag.
     * @example
     * // Update or create a SessionTag
     * const sessionTag = await prisma.sessionTag.upsert({
     *   create: {
     *     // ... data to create a SessionTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionTag we want to update
     *   }
     * })
     */
    upsert<T extends SessionTagUpsertArgs>(args: SelectSubset<T, SessionTagUpsertArgs<ExtArgs>>): Prisma__SessionTagClient<$Result.GetResult<Prisma.$SessionTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagCountArgs} args - Arguments to filter SessionTags to count.
     * @example
     * // Count the number of SessionTags
     * const count = await prisma.sessionTag.count({
     *   where: {
     *     // ... the filter for the SessionTags we want to count
     *   }
     * })
    **/
    count<T extends SessionTagCountArgs>(
      args?: Subset<T, SessionTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionTagAggregateArgs>(args: Subset<T, SessionTagAggregateArgs>): Prisma.PrismaPromise<GetSessionTagAggregateType<T>>

    /**
     * Group by SessionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionTagGroupByArgs['orderBy'] }
        : { orderBy?: SessionTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionTag model
   */
  readonly fields: SessionTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionTag model
   */
  interface SessionTagFieldRefs {
    readonly sessionId: FieldRef<"SessionTag", 'Int'>
    readonly tagId: FieldRef<"SessionTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionTag findUnique
   */
  export type SessionTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag findUniqueOrThrow
   */
  export type SessionTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag findFirst
   */
  export type SessionTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTags.
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTags.
     */
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * SessionTag findFirstOrThrow
   */
  export type SessionTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTag to fetch.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionTags.
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionTags.
     */
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * SessionTag findMany
   */
  export type SessionTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter, which SessionTags to fetch.
     */
    where?: SessionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionTags to fetch.
     */
    orderBy?: SessionTagOrderByWithRelationInput | SessionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionTags.
     */
    cursor?: SessionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionTags.
     */
    skip?: number
    distinct?: SessionTagScalarFieldEnum | SessionTagScalarFieldEnum[]
  }

  /**
   * SessionTag create
   */
  export type SessionTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionTag.
     */
    data: XOR<SessionTagCreateInput, SessionTagUncheckedCreateInput>
  }

  /**
   * SessionTag createMany
   */
  export type SessionTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionTags.
     */
    data: SessionTagCreateManyInput | SessionTagCreateManyInput[]
  }

  /**
   * SessionTag createManyAndReturn
   */
  export type SessionTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * The data used to create many SessionTags.
     */
    data: SessionTagCreateManyInput | SessionTagCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTag update
   */
  export type SessionTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionTag.
     */
    data: XOR<SessionTagUpdateInput, SessionTagUncheckedUpdateInput>
    /**
     * Choose, which SessionTag to update.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag updateMany
   */
  export type SessionTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionTags.
     */
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyInput>
    /**
     * Filter which SessionTags to update
     */
    where?: SessionTagWhereInput
    /**
     * Limit how many SessionTags to update.
     */
    limit?: number
  }

  /**
   * SessionTag updateManyAndReturn
   */
  export type SessionTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * The data used to update SessionTags.
     */
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyInput>
    /**
     * Filter which SessionTags to update
     */
    where?: SessionTagWhereInput
    /**
     * Limit how many SessionTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionTag upsert
   */
  export type SessionTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionTag to update in case it exists.
     */
    where: SessionTagWhereUniqueInput
    /**
     * In case the SessionTag found by the `where` argument doesn't exist, create a new SessionTag with this data.
     */
    create: XOR<SessionTagCreateInput, SessionTagUncheckedCreateInput>
    /**
     * In case the SessionTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionTagUpdateInput, SessionTagUncheckedUpdateInput>
  }

  /**
   * SessionTag delete
   */
  export type SessionTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
    /**
     * Filter which SessionTag to delete.
     */
    where: SessionTagWhereUniqueInput
  }

  /**
   * SessionTag deleteMany
   */
  export type SessionTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionTags to delete
     */
    where?: SessionTagWhereInput
    /**
     * Limit how many SessionTags to delete.
     */
    limit?: number
  }

  /**
   * SessionTag without action
   */
  export type SessionTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionTag
     */
    select?: SessionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionTag
     */
    omit?: SessionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionTagInclude<ExtArgs> | null
  }


  /**
   * Model Level
   */

  export type AggregateLevel = {
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  export type LevelAvgAggregateOutputType = {
    id: number | null
  }

  export type LevelSumAggregateOutputType = {
    id: number | null
  }

  export type LevelMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type LevelMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type LevelCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type LevelAvgAggregateInputType = {
    id?: true
  }

  export type LevelSumAggregateInputType = {
    id?: true
  }

  export type LevelMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type LevelMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type LevelCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type LevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Level to aggregate.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Levels
    **/
    _count?: true | LevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LevelMaxAggregateInputType
  }

  export type GetLevelAggregateType<T extends LevelAggregateArgs> = {
        [P in keyof T & keyof AggregateLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLevel[P]>
      : GetScalarType<T[P], AggregateLevel[P]>
  }




  export type LevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LevelWhereInput
    orderBy?: LevelOrderByWithAggregationInput | LevelOrderByWithAggregationInput[]
    by: LevelScalarFieldEnum[] | LevelScalarFieldEnum
    having?: LevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LevelCountAggregateInputType | true
    _avg?: LevelAvgAggregateInputType
    _sum?: LevelSumAggregateInputType
    _min?: LevelMinAggregateInputType
    _max?: LevelMaxAggregateInputType
  }

  export type LevelGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: LevelCountAggregateOutputType | null
    _avg: LevelAvgAggregateOutputType | null
    _sum: LevelSumAggregateOutputType | null
    _min: LevelMinAggregateOutputType | null
    _max: LevelMaxAggregateOutputType | null
  }

  type GetLevelGroupByPayload<T extends LevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LevelGroupByOutputType[P]>
            : GetScalarType<T[P], LevelGroupByOutputType[P]>
        }
      >
    >


  export type LevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | Level$sessionsArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["level"]>

  export type LevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["level"]>

  export type LevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["level"]>

  export type LevelSelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type LevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["level"]>
  export type LevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Level$sessionsArgs<ExtArgs>
    _count?: boolean | LevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type LevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Level"
    objects: {
      sessions: Prisma.$SessionLevelOnSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["level"]>
    composites: {}
  }

  type LevelGetPayload<S extends boolean | null | undefined | LevelDefaultArgs> = $Result.GetResult<Prisma.$LevelPayload, S>

  type LevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LevelCountAggregateInputType | true
    }

  export interface LevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Level'], meta: { name: 'Level' } }
    /**
     * Find zero or one Level that matches the filter.
     * @param {LevelFindUniqueArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LevelFindUniqueArgs>(args: SelectSubset<T, LevelFindUniqueArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Level that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LevelFindUniqueOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LevelFindUniqueOrThrowArgs>(args: SelectSubset<T, LevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LevelFindFirstArgs>(args?: SelectSubset<T, LevelFindFirstArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Level that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindFirstOrThrowArgs} args - Arguments to find a Level
     * @example
     * // Get one Level
     * const level = await prisma.level.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LevelFindFirstOrThrowArgs>(args?: SelectSubset<T, LevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Levels
     * const levels = await prisma.level.findMany()
     * 
     * // Get first 10 Levels
     * const levels = await prisma.level.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const levelWithIdOnly = await prisma.level.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LevelFindManyArgs>(args?: SelectSubset<T, LevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Level.
     * @param {LevelCreateArgs} args - Arguments to create a Level.
     * @example
     * // Create one Level
     * const Level = await prisma.level.create({
     *   data: {
     *     // ... data to create a Level
     *   }
     * })
     * 
     */
    create<T extends LevelCreateArgs>(args: SelectSubset<T, LevelCreateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Levels.
     * @param {LevelCreateManyArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LevelCreateManyArgs>(args?: SelectSubset<T, LevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Levels and returns the data saved in the database.
     * @param {LevelCreateManyAndReturnArgs} args - Arguments to create many Levels.
     * @example
     * // Create many Levels
     * const level = await prisma.level.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LevelCreateManyAndReturnArgs>(args?: SelectSubset<T, LevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Level.
     * @param {LevelDeleteArgs} args - Arguments to delete one Level.
     * @example
     * // Delete one Level
     * const Level = await prisma.level.delete({
     *   where: {
     *     // ... filter to delete one Level
     *   }
     * })
     * 
     */
    delete<T extends LevelDeleteArgs>(args: SelectSubset<T, LevelDeleteArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Level.
     * @param {LevelUpdateArgs} args - Arguments to update one Level.
     * @example
     * // Update one Level
     * const level = await prisma.level.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LevelUpdateArgs>(args: SelectSubset<T, LevelUpdateArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Levels.
     * @param {LevelDeleteManyArgs} args - Arguments to filter Levels to delete.
     * @example
     * // Delete a few Levels
     * const { count } = await prisma.level.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LevelDeleteManyArgs>(args?: SelectSubset<T, LevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LevelUpdateManyArgs>(args: SelectSubset<T, LevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Levels and returns the data updated in the database.
     * @param {LevelUpdateManyAndReturnArgs} args - Arguments to update many Levels.
     * @example
     * // Update many Levels
     * const level = await prisma.level.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Levels and only return the `id`
     * const levelWithIdOnly = await prisma.level.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LevelUpdateManyAndReturnArgs>(args: SelectSubset<T, LevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Level.
     * @param {LevelUpsertArgs} args - Arguments to update or create a Level.
     * @example
     * // Update or create a Level
     * const level = await prisma.level.upsert({
     *   create: {
     *     // ... data to create a Level
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Level we want to update
     *   }
     * })
     */
    upsert<T extends LevelUpsertArgs>(args: SelectSubset<T, LevelUpsertArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelCountArgs} args - Arguments to filter Levels to count.
     * @example
     * // Count the number of Levels
     * const count = await prisma.level.count({
     *   where: {
     *     // ... the filter for the Levels we want to count
     *   }
     * })
    **/
    count<T extends LevelCountArgs>(
      args?: Subset<T, LevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LevelAggregateArgs>(args: Subset<T, LevelAggregateArgs>): Prisma.PrismaPromise<GetLevelAggregateType<T>>

    /**
     * Group by Level.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LevelGroupByArgs['orderBy'] }
        : { orderBy?: LevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Level model
   */
  readonly fields: LevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Level.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Level$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Level$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Level model
   */
  interface LevelFieldRefs {
    readonly id: FieldRef<"Level", 'Int'>
    readonly logicalValue: FieldRef<"Level", 'String'>
    readonly displayValue: FieldRef<"Level", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Level findUnique
   */
  export type LevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findUniqueOrThrow
   */
  export type LevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level findFirst
   */
  export type LevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findFirstOrThrow
   */
  export type LevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Level to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Levels.
     */
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level findMany
   */
  export type LevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter, which Levels to fetch.
     */
    where?: LevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Levels to fetch.
     */
    orderBy?: LevelOrderByWithRelationInput | LevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Levels.
     */
    cursor?: LevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Levels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Levels.
     */
    skip?: number
    distinct?: LevelScalarFieldEnum | LevelScalarFieldEnum[]
  }

  /**
   * Level create
   */
  export type LevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to create a Level.
     */
    data: XOR<LevelCreateInput, LevelUncheckedCreateInput>
  }

  /**
   * Level createMany
   */
  export type LevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
  }

  /**
   * Level createManyAndReturn
   */
  export type LevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to create many Levels.
     */
    data: LevelCreateManyInput | LevelCreateManyInput[]
  }

  /**
   * Level update
   */
  export type LevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The data needed to update a Level.
     */
    data: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
    /**
     * Choose, which Level to update.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level updateMany
   */
  export type LevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level updateManyAndReturn
   */
  export type LevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * The data used to update Levels.
     */
    data: XOR<LevelUpdateManyMutationInput, LevelUncheckedUpdateManyInput>
    /**
     * Filter which Levels to update
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to update.
     */
    limit?: number
  }

  /**
   * Level upsert
   */
  export type LevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * The filter to search for the Level to update in case it exists.
     */
    where: LevelWhereUniqueInput
    /**
     * In case the Level found by the `where` argument doesn't exist, create a new Level with this data.
     */
    create: XOR<LevelCreateInput, LevelUncheckedCreateInput>
    /**
     * In case the Level was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LevelUpdateInput, LevelUncheckedUpdateInput>
  }

  /**
   * Level delete
   */
  export type LevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
    /**
     * Filter which Level to delete.
     */
    where: LevelWhereUniqueInput
  }

  /**
   * Level deleteMany
   */
  export type LevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Levels to delete
     */
    where?: LevelWhereInput
    /**
     * Limit how many Levels to delete.
     */
    limit?: number
  }

  /**
   * Level.sessions
   */
  export type Level$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    where?: SessionLevelOnSessionWhereInput
    orderBy?: SessionLevelOnSessionOrderByWithRelationInput | SessionLevelOnSessionOrderByWithRelationInput[]
    cursor?: SessionLevelOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionLevelOnSessionScalarFieldEnum | SessionLevelOnSessionScalarFieldEnum[]
  }

  /**
   * Level without action
   */
  export type LevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Level
     */
    select?: LevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Level
     */
    omit?: LevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LevelInclude<ExtArgs> | null
  }


  /**
   * Model SessionLevelOnSession
   */

  export type AggregateSessionLevelOnSession = {
    _count: SessionLevelOnSessionCountAggregateOutputType | null
    _avg: SessionLevelOnSessionAvgAggregateOutputType | null
    _sum: SessionLevelOnSessionSumAggregateOutputType | null
    _min: SessionLevelOnSessionMinAggregateOutputType | null
    _max: SessionLevelOnSessionMaxAggregateOutputType | null
  }

  export type SessionLevelOnSessionAvgAggregateOutputType = {
    sessionId: number | null
    levelId: number | null
  }

  export type SessionLevelOnSessionSumAggregateOutputType = {
    sessionId: number | null
    levelId: number | null
  }

  export type SessionLevelOnSessionMinAggregateOutputType = {
    sessionId: number | null
    levelId: number | null
  }

  export type SessionLevelOnSessionMaxAggregateOutputType = {
    sessionId: number | null
    levelId: number | null
  }

  export type SessionLevelOnSessionCountAggregateOutputType = {
    sessionId: number
    levelId: number
    _all: number
  }


  export type SessionLevelOnSessionAvgAggregateInputType = {
    sessionId?: true
    levelId?: true
  }

  export type SessionLevelOnSessionSumAggregateInputType = {
    sessionId?: true
    levelId?: true
  }

  export type SessionLevelOnSessionMinAggregateInputType = {
    sessionId?: true
    levelId?: true
  }

  export type SessionLevelOnSessionMaxAggregateInputType = {
    sessionId?: true
    levelId?: true
  }

  export type SessionLevelOnSessionCountAggregateInputType = {
    sessionId?: true
    levelId?: true
    _all?: true
  }

  export type SessionLevelOnSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionLevelOnSession to aggregate.
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLevelOnSessions to fetch.
     */
    orderBy?: SessionLevelOnSessionOrderByWithRelationInput | SessionLevelOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionLevelOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLevelOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLevelOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionLevelOnSessions
    **/
    _count?: true | SessionLevelOnSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionLevelOnSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionLevelOnSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionLevelOnSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionLevelOnSessionMaxAggregateInputType
  }

  export type GetSessionLevelOnSessionAggregateType<T extends SessionLevelOnSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionLevelOnSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionLevelOnSession[P]>
      : GetScalarType<T[P], AggregateSessionLevelOnSession[P]>
  }




  export type SessionLevelOnSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionLevelOnSessionWhereInput
    orderBy?: SessionLevelOnSessionOrderByWithAggregationInput | SessionLevelOnSessionOrderByWithAggregationInput[]
    by: SessionLevelOnSessionScalarFieldEnum[] | SessionLevelOnSessionScalarFieldEnum
    having?: SessionLevelOnSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionLevelOnSessionCountAggregateInputType | true
    _avg?: SessionLevelOnSessionAvgAggregateInputType
    _sum?: SessionLevelOnSessionSumAggregateInputType
    _min?: SessionLevelOnSessionMinAggregateInputType
    _max?: SessionLevelOnSessionMaxAggregateInputType
  }

  export type SessionLevelOnSessionGroupByOutputType = {
    sessionId: number
    levelId: number
    _count: SessionLevelOnSessionCountAggregateOutputType | null
    _avg: SessionLevelOnSessionAvgAggregateOutputType | null
    _sum: SessionLevelOnSessionSumAggregateOutputType | null
    _min: SessionLevelOnSessionMinAggregateOutputType | null
    _max: SessionLevelOnSessionMaxAggregateOutputType | null
  }

  type GetSessionLevelOnSessionGroupByPayload<T extends SessionLevelOnSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionLevelOnSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionLevelOnSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionLevelOnSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionLevelOnSessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionLevelOnSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    levelId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLevelOnSession"]>

  export type SessionLevelOnSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    levelId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLevelOnSession"]>

  export type SessionLevelOnSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    levelId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionLevelOnSession"]>

  export type SessionLevelOnSessionSelectScalar = {
    sessionId?: boolean
    levelId?: boolean
  }

  export type SessionLevelOnSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "levelId", ExtArgs["result"]["sessionLevelOnSession"]>
  export type SessionLevelOnSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }
  export type SessionLevelOnSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }
  export type SessionLevelOnSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    level?: boolean | LevelDefaultArgs<ExtArgs>
  }

  export type $SessionLevelOnSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionLevelOnSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      level: Prisma.$LevelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      levelId: number
    }, ExtArgs["result"]["sessionLevelOnSession"]>
    composites: {}
  }

  type SessionLevelOnSessionGetPayload<S extends boolean | null | undefined | SessionLevelOnSessionDefaultArgs> = $Result.GetResult<Prisma.$SessionLevelOnSessionPayload, S>

  type SessionLevelOnSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionLevelOnSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionLevelOnSessionCountAggregateInputType | true
    }

  export interface SessionLevelOnSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionLevelOnSession'], meta: { name: 'SessionLevelOnSession' } }
    /**
     * Find zero or one SessionLevelOnSession that matches the filter.
     * @param {SessionLevelOnSessionFindUniqueArgs} args - Arguments to find a SessionLevelOnSession
     * @example
     * // Get one SessionLevelOnSession
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionLevelOnSessionFindUniqueArgs>(args: SelectSubset<T, SessionLevelOnSessionFindUniqueArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionLevelOnSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionLevelOnSessionFindUniqueOrThrowArgs} args - Arguments to find a SessionLevelOnSession
     * @example
     * // Get one SessionLevelOnSession
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionLevelOnSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionLevelOnSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionLevelOnSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionFindFirstArgs} args - Arguments to find a SessionLevelOnSession
     * @example
     * // Get one SessionLevelOnSession
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionLevelOnSessionFindFirstArgs>(args?: SelectSubset<T, SessionLevelOnSessionFindFirstArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionLevelOnSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionFindFirstOrThrowArgs} args - Arguments to find a SessionLevelOnSession
     * @example
     * // Get one SessionLevelOnSession
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionLevelOnSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionLevelOnSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionLevelOnSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionLevelOnSessions
     * const sessionLevelOnSessions = await prisma.sessionLevelOnSession.findMany()
     * 
     * // Get first 10 SessionLevelOnSessions
     * const sessionLevelOnSessions = await prisma.sessionLevelOnSession.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionLevelOnSessionWithSessionIdOnly = await prisma.sessionLevelOnSession.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionLevelOnSessionFindManyArgs>(args?: SelectSubset<T, SessionLevelOnSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionLevelOnSession.
     * @param {SessionLevelOnSessionCreateArgs} args - Arguments to create a SessionLevelOnSession.
     * @example
     * // Create one SessionLevelOnSession
     * const SessionLevelOnSession = await prisma.sessionLevelOnSession.create({
     *   data: {
     *     // ... data to create a SessionLevelOnSession
     *   }
     * })
     * 
     */
    create<T extends SessionLevelOnSessionCreateArgs>(args: SelectSubset<T, SessionLevelOnSessionCreateArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionLevelOnSessions.
     * @param {SessionLevelOnSessionCreateManyArgs} args - Arguments to create many SessionLevelOnSessions.
     * @example
     * // Create many SessionLevelOnSessions
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionLevelOnSessionCreateManyArgs>(args?: SelectSubset<T, SessionLevelOnSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionLevelOnSessions and returns the data saved in the database.
     * @param {SessionLevelOnSessionCreateManyAndReturnArgs} args - Arguments to create many SessionLevelOnSessions.
     * @example
     * // Create many SessionLevelOnSessions
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionLevelOnSessions and only return the `sessionId`
     * const sessionLevelOnSessionWithSessionIdOnly = await prisma.sessionLevelOnSession.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionLevelOnSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionLevelOnSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionLevelOnSession.
     * @param {SessionLevelOnSessionDeleteArgs} args - Arguments to delete one SessionLevelOnSession.
     * @example
     * // Delete one SessionLevelOnSession
     * const SessionLevelOnSession = await prisma.sessionLevelOnSession.delete({
     *   where: {
     *     // ... filter to delete one SessionLevelOnSession
     *   }
     * })
     * 
     */
    delete<T extends SessionLevelOnSessionDeleteArgs>(args: SelectSubset<T, SessionLevelOnSessionDeleteArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionLevelOnSession.
     * @param {SessionLevelOnSessionUpdateArgs} args - Arguments to update one SessionLevelOnSession.
     * @example
     * // Update one SessionLevelOnSession
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionLevelOnSessionUpdateArgs>(args: SelectSubset<T, SessionLevelOnSessionUpdateArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionLevelOnSessions.
     * @param {SessionLevelOnSessionDeleteManyArgs} args - Arguments to filter SessionLevelOnSessions to delete.
     * @example
     * // Delete a few SessionLevelOnSessions
     * const { count } = await prisma.sessionLevelOnSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionLevelOnSessionDeleteManyArgs>(args?: SelectSubset<T, SessionLevelOnSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionLevelOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionLevelOnSessions
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionLevelOnSessionUpdateManyArgs>(args: SelectSubset<T, SessionLevelOnSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionLevelOnSessions and returns the data updated in the database.
     * @param {SessionLevelOnSessionUpdateManyAndReturnArgs} args - Arguments to update many SessionLevelOnSessions.
     * @example
     * // Update many SessionLevelOnSessions
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionLevelOnSessions and only return the `sessionId`
     * const sessionLevelOnSessionWithSessionIdOnly = await prisma.sessionLevelOnSession.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionLevelOnSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionLevelOnSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionLevelOnSession.
     * @param {SessionLevelOnSessionUpsertArgs} args - Arguments to update or create a SessionLevelOnSession.
     * @example
     * // Update or create a SessionLevelOnSession
     * const sessionLevelOnSession = await prisma.sessionLevelOnSession.upsert({
     *   create: {
     *     // ... data to create a SessionLevelOnSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionLevelOnSession we want to update
     *   }
     * })
     */
    upsert<T extends SessionLevelOnSessionUpsertArgs>(args: SelectSubset<T, SessionLevelOnSessionUpsertArgs<ExtArgs>>): Prisma__SessionLevelOnSessionClient<$Result.GetResult<Prisma.$SessionLevelOnSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionLevelOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionCountArgs} args - Arguments to filter SessionLevelOnSessions to count.
     * @example
     * // Count the number of SessionLevelOnSessions
     * const count = await prisma.sessionLevelOnSession.count({
     *   where: {
     *     // ... the filter for the SessionLevelOnSessions we want to count
     *   }
     * })
    **/
    count<T extends SessionLevelOnSessionCountArgs>(
      args?: Subset<T, SessionLevelOnSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionLevelOnSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionLevelOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionLevelOnSessionAggregateArgs>(args: Subset<T, SessionLevelOnSessionAggregateArgs>): Prisma.PrismaPromise<GetSessionLevelOnSessionAggregateType<T>>

    /**
     * Group by SessionLevelOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionLevelOnSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionLevelOnSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionLevelOnSessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionLevelOnSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionLevelOnSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionLevelOnSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionLevelOnSession model
   */
  readonly fields: SessionLevelOnSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionLevelOnSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionLevelOnSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    level<T extends LevelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LevelDefaultArgs<ExtArgs>>): Prisma__LevelClient<$Result.GetResult<Prisma.$LevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionLevelOnSession model
   */
  interface SessionLevelOnSessionFieldRefs {
    readonly sessionId: FieldRef<"SessionLevelOnSession", 'Int'>
    readonly levelId: FieldRef<"SessionLevelOnSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionLevelOnSession findUnique
   */
  export type SessionLevelOnSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionLevelOnSession to fetch.
     */
    where: SessionLevelOnSessionWhereUniqueInput
  }

  /**
   * SessionLevelOnSession findUniqueOrThrow
   */
  export type SessionLevelOnSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionLevelOnSession to fetch.
     */
    where: SessionLevelOnSessionWhereUniqueInput
  }

  /**
   * SessionLevelOnSession findFirst
   */
  export type SessionLevelOnSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionLevelOnSession to fetch.
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLevelOnSessions to fetch.
     */
    orderBy?: SessionLevelOnSessionOrderByWithRelationInput | SessionLevelOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionLevelOnSessions.
     */
    cursor?: SessionLevelOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLevelOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLevelOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionLevelOnSessions.
     */
    distinct?: SessionLevelOnSessionScalarFieldEnum | SessionLevelOnSessionScalarFieldEnum[]
  }

  /**
   * SessionLevelOnSession findFirstOrThrow
   */
  export type SessionLevelOnSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionLevelOnSession to fetch.
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLevelOnSessions to fetch.
     */
    orderBy?: SessionLevelOnSessionOrderByWithRelationInput | SessionLevelOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionLevelOnSessions.
     */
    cursor?: SessionLevelOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLevelOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLevelOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionLevelOnSessions.
     */
    distinct?: SessionLevelOnSessionScalarFieldEnum | SessionLevelOnSessionScalarFieldEnum[]
  }

  /**
   * SessionLevelOnSession findMany
   */
  export type SessionLevelOnSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionLevelOnSessions to fetch.
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionLevelOnSessions to fetch.
     */
    orderBy?: SessionLevelOnSessionOrderByWithRelationInput | SessionLevelOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionLevelOnSessions.
     */
    cursor?: SessionLevelOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionLevelOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionLevelOnSessions.
     */
    skip?: number
    distinct?: SessionLevelOnSessionScalarFieldEnum | SessionLevelOnSessionScalarFieldEnum[]
  }

  /**
   * SessionLevelOnSession create
   */
  export type SessionLevelOnSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionLevelOnSession.
     */
    data: XOR<SessionLevelOnSessionCreateInput, SessionLevelOnSessionUncheckedCreateInput>
  }

  /**
   * SessionLevelOnSession createMany
   */
  export type SessionLevelOnSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionLevelOnSessions.
     */
    data: SessionLevelOnSessionCreateManyInput | SessionLevelOnSessionCreateManyInput[]
  }

  /**
   * SessionLevelOnSession createManyAndReturn
   */
  export type SessionLevelOnSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SessionLevelOnSessions.
     */
    data: SessionLevelOnSessionCreateManyInput | SessionLevelOnSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionLevelOnSession update
   */
  export type SessionLevelOnSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionLevelOnSession.
     */
    data: XOR<SessionLevelOnSessionUpdateInput, SessionLevelOnSessionUncheckedUpdateInput>
    /**
     * Choose, which SessionLevelOnSession to update.
     */
    where: SessionLevelOnSessionWhereUniqueInput
  }

  /**
   * SessionLevelOnSession updateMany
   */
  export type SessionLevelOnSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionLevelOnSessions.
     */
    data: XOR<SessionLevelOnSessionUpdateManyMutationInput, SessionLevelOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionLevelOnSessions to update
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * Limit how many SessionLevelOnSessions to update.
     */
    limit?: number
  }

  /**
   * SessionLevelOnSession updateManyAndReturn
   */
  export type SessionLevelOnSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * The data used to update SessionLevelOnSessions.
     */
    data: XOR<SessionLevelOnSessionUpdateManyMutationInput, SessionLevelOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionLevelOnSessions to update
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * Limit how many SessionLevelOnSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionLevelOnSession upsert
   */
  export type SessionLevelOnSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionLevelOnSession to update in case it exists.
     */
    where: SessionLevelOnSessionWhereUniqueInput
    /**
     * In case the SessionLevelOnSession found by the `where` argument doesn't exist, create a new SessionLevelOnSession with this data.
     */
    create: XOR<SessionLevelOnSessionCreateInput, SessionLevelOnSessionUncheckedCreateInput>
    /**
     * In case the SessionLevelOnSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionLevelOnSessionUpdateInput, SessionLevelOnSessionUncheckedUpdateInput>
  }

  /**
   * SessionLevelOnSession delete
   */
  export type SessionLevelOnSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
    /**
     * Filter which SessionLevelOnSession to delete.
     */
    where: SessionLevelOnSessionWhereUniqueInput
  }

  /**
   * SessionLevelOnSession deleteMany
   */
  export type SessionLevelOnSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionLevelOnSessions to delete
     */
    where?: SessionLevelOnSessionWhereInput
    /**
     * Limit how many SessionLevelOnSessions to delete.
     */
    limit?: number
  }

  /**
   * SessionLevelOnSession without action
   */
  export type SessionLevelOnSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionLevelOnSession
     */
    select?: SessionLevelOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionLevelOnSession
     */
    omit?: SessionLevelOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionLevelOnSessionInclude<ExtArgs> | null
  }


  /**
   * Model AudienceType
   */

  export type AggregateAudienceType = {
    _count: AudienceTypeCountAggregateOutputType | null
    _avg: AudienceTypeAvgAggregateOutputType | null
    _sum: AudienceTypeSumAggregateOutputType | null
    _min: AudienceTypeMinAggregateOutputType | null
    _max: AudienceTypeMaxAggregateOutputType | null
  }

  export type AudienceTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type AudienceTypeSumAggregateOutputType = {
    id: number | null
  }

  export type AudienceTypeMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type AudienceTypeMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type AudienceTypeCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type AudienceTypeAvgAggregateInputType = {
    id?: true
  }

  export type AudienceTypeSumAggregateInputType = {
    id?: true
  }

  export type AudienceTypeMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type AudienceTypeMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type AudienceTypeCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type AudienceTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudienceType to aggregate.
     */
    where?: AudienceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceTypes to fetch.
     */
    orderBy?: AudienceTypeOrderByWithRelationInput | AudienceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AudienceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AudienceTypes
    **/
    _count?: true | AudienceTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AudienceTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AudienceTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AudienceTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AudienceTypeMaxAggregateInputType
  }

  export type GetAudienceTypeAggregateType<T extends AudienceTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateAudienceType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAudienceType[P]>
      : GetScalarType<T[P], AggregateAudienceType[P]>
  }




  export type AudienceTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AudienceTypeWhereInput
    orderBy?: AudienceTypeOrderByWithAggregationInput | AudienceTypeOrderByWithAggregationInput[]
    by: AudienceTypeScalarFieldEnum[] | AudienceTypeScalarFieldEnum
    having?: AudienceTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AudienceTypeCountAggregateInputType | true
    _avg?: AudienceTypeAvgAggregateInputType
    _sum?: AudienceTypeSumAggregateInputType
    _min?: AudienceTypeMinAggregateInputType
    _max?: AudienceTypeMaxAggregateInputType
  }

  export type AudienceTypeGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: AudienceTypeCountAggregateOutputType | null
    _avg: AudienceTypeAvgAggregateOutputType | null
    _sum: AudienceTypeSumAggregateOutputType | null
    _min: AudienceTypeMinAggregateOutputType | null
    _max: AudienceTypeMaxAggregateOutputType | null
  }

  type GetAudienceTypeGroupByPayload<T extends AudienceTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AudienceTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AudienceTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AudienceTypeGroupByOutputType[P]>
            : GetScalarType<T[P], AudienceTypeGroupByOutputType[P]>
        }
      >
    >


  export type AudienceTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | AudienceType$sessionsArgs<ExtArgs>
    _count?: boolean | AudienceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["audienceType"]>

  export type AudienceTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["audienceType"]>

  export type AudienceTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["audienceType"]>

  export type AudienceTypeSelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type AudienceTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["audienceType"]>
  export type AudienceTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | AudienceType$sessionsArgs<ExtArgs>
    _count?: boolean | AudienceTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AudienceTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AudienceTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AudienceTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AudienceType"
    objects: {
      sessions: Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["audienceType"]>
    composites: {}
  }

  type AudienceTypeGetPayload<S extends boolean | null | undefined | AudienceTypeDefaultArgs> = $Result.GetResult<Prisma.$AudienceTypePayload, S>

  type AudienceTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AudienceTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AudienceTypeCountAggregateInputType | true
    }

  export interface AudienceTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AudienceType'], meta: { name: 'AudienceType' } }
    /**
     * Find zero or one AudienceType that matches the filter.
     * @param {AudienceTypeFindUniqueArgs} args - Arguments to find a AudienceType
     * @example
     * // Get one AudienceType
     * const audienceType = await prisma.audienceType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AudienceTypeFindUniqueArgs>(args: SelectSubset<T, AudienceTypeFindUniqueArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AudienceType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AudienceTypeFindUniqueOrThrowArgs} args - Arguments to find a AudienceType
     * @example
     * // Get one AudienceType
     * const audienceType = await prisma.audienceType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AudienceTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, AudienceTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudienceType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeFindFirstArgs} args - Arguments to find a AudienceType
     * @example
     * // Get one AudienceType
     * const audienceType = await prisma.audienceType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AudienceTypeFindFirstArgs>(args?: SelectSubset<T, AudienceTypeFindFirstArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AudienceType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeFindFirstOrThrowArgs} args - Arguments to find a AudienceType
     * @example
     * // Get one AudienceType
     * const audienceType = await prisma.audienceType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AudienceTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, AudienceTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AudienceTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AudienceTypes
     * const audienceTypes = await prisma.audienceType.findMany()
     * 
     * // Get first 10 AudienceTypes
     * const audienceTypes = await prisma.audienceType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const audienceTypeWithIdOnly = await prisma.audienceType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AudienceTypeFindManyArgs>(args?: SelectSubset<T, AudienceTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AudienceType.
     * @param {AudienceTypeCreateArgs} args - Arguments to create a AudienceType.
     * @example
     * // Create one AudienceType
     * const AudienceType = await prisma.audienceType.create({
     *   data: {
     *     // ... data to create a AudienceType
     *   }
     * })
     * 
     */
    create<T extends AudienceTypeCreateArgs>(args: SelectSubset<T, AudienceTypeCreateArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AudienceTypes.
     * @param {AudienceTypeCreateManyArgs} args - Arguments to create many AudienceTypes.
     * @example
     * // Create many AudienceTypes
     * const audienceType = await prisma.audienceType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AudienceTypeCreateManyArgs>(args?: SelectSubset<T, AudienceTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AudienceTypes and returns the data saved in the database.
     * @param {AudienceTypeCreateManyAndReturnArgs} args - Arguments to create many AudienceTypes.
     * @example
     * // Create many AudienceTypes
     * const audienceType = await prisma.audienceType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AudienceTypes and only return the `id`
     * const audienceTypeWithIdOnly = await prisma.audienceType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AudienceTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, AudienceTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AudienceType.
     * @param {AudienceTypeDeleteArgs} args - Arguments to delete one AudienceType.
     * @example
     * // Delete one AudienceType
     * const AudienceType = await prisma.audienceType.delete({
     *   where: {
     *     // ... filter to delete one AudienceType
     *   }
     * })
     * 
     */
    delete<T extends AudienceTypeDeleteArgs>(args: SelectSubset<T, AudienceTypeDeleteArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AudienceType.
     * @param {AudienceTypeUpdateArgs} args - Arguments to update one AudienceType.
     * @example
     * // Update one AudienceType
     * const audienceType = await prisma.audienceType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AudienceTypeUpdateArgs>(args: SelectSubset<T, AudienceTypeUpdateArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AudienceTypes.
     * @param {AudienceTypeDeleteManyArgs} args - Arguments to filter AudienceTypes to delete.
     * @example
     * // Delete a few AudienceTypes
     * const { count } = await prisma.audienceType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AudienceTypeDeleteManyArgs>(args?: SelectSubset<T, AudienceTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudienceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AudienceTypes
     * const audienceType = await prisma.audienceType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AudienceTypeUpdateManyArgs>(args: SelectSubset<T, AudienceTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AudienceTypes and returns the data updated in the database.
     * @param {AudienceTypeUpdateManyAndReturnArgs} args - Arguments to update many AudienceTypes.
     * @example
     * // Update many AudienceTypes
     * const audienceType = await prisma.audienceType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AudienceTypes and only return the `id`
     * const audienceTypeWithIdOnly = await prisma.audienceType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AudienceTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, AudienceTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AudienceType.
     * @param {AudienceTypeUpsertArgs} args - Arguments to update or create a AudienceType.
     * @example
     * // Update or create a AudienceType
     * const audienceType = await prisma.audienceType.upsert({
     *   create: {
     *     // ... data to create a AudienceType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AudienceType we want to update
     *   }
     * })
     */
    upsert<T extends AudienceTypeUpsertArgs>(args: SelectSubset<T, AudienceTypeUpsertArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AudienceTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeCountArgs} args - Arguments to filter AudienceTypes to count.
     * @example
     * // Count the number of AudienceTypes
     * const count = await prisma.audienceType.count({
     *   where: {
     *     // ... the filter for the AudienceTypes we want to count
     *   }
     * })
    **/
    count<T extends AudienceTypeCountArgs>(
      args?: Subset<T, AudienceTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AudienceTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AudienceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AudienceTypeAggregateArgs>(args: Subset<T, AudienceTypeAggregateArgs>): Prisma.PrismaPromise<GetAudienceTypeAggregateType<T>>

    /**
     * Group by AudienceType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AudienceTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AudienceTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AudienceTypeGroupByArgs['orderBy'] }
        : { orderBy?: AudienceTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AudienceTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAudienceTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AudienceType model
   */
  readonly fields: AudienceTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AudienceType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AudienceTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends AudienceType$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, AudienceType$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AudienceType model
   */
  interface AudienceTypeFieldRefs {
    readonly id: FieldRef<"AudienceType", 'Int'>
    readonly logicalValue: FieldRef<"AudienceType", 'String'>
    readonly displayValue: FieldRef<"AudienceType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AudienceType findUnique
   */
  export type AudienceTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * Filter, which AudienceType to fetch.
     */
    where: AudienceTypeWhereUniqueInput
  }

  /**
   * AudienceType findUniqueOrThrow
   */
  export type AudienceTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * Filter, which AudienceType to fetch.
     */
    where: AudienceTypeWhereUniqueInput
  }

  /**
   * AudienceType findFirst
   */
  export type AudienceTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * Filter, which AudienceType to fetch.
     */
    where?: AudienceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceTypes to fetch.
     */
    orderBy?: AudienceTypeOrderByWithRelationInput | AudienceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudienceTypes.
     */
    cursor?: AudienceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudienceTypes.
     */
    distinct?: AudienceTypeScalarFieldEnum | AudienceTypeScalarFieldEnum[]
  }

  /**
   * AudienceType findFirstOrThrow
   */
  export type AudienceTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * Filter, which AudienceType to fetch.
     */
    where?: AudienceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceTypes to fetch.
     */
    orderBy?: AudienceTypeOrderByWithRelationInput | AudienceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AudienceTypes.
     */
    cursor?: AudienceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AudienceTypes.
     */
    distinct?: AudienceTypeScalarFieldEnum | AudienceTypeScalarFieldEnum[]
  }

  /**
   * AudienceType findMany
   */
  export type AudienceTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * Filter, which AudienceTypes to fetch.
     */
    where?: AudienceTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AudienceTypes to fetch.
     */
    orderBy?: AudienceTypeOrderByWithRelationInput | AudienceTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AudienceTypes.
     */
    cursor?: AudienceTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AudienceTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AudienceTypes.
     */
    skip?: number
    distinct?: AudienceTypeScalarFieldEnum | AudienceTypeScalarFieldEnum[]
  }

  /**
   * AudienceType create
   */
  export type AudienceTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a AudienceType.
     */
    data: XOR<AudienceTypeCreateInput, AudienceTypeUncheckedCreateInput>
  }

  /**
   * AudienceType createMany
   */
  export type AudienceTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AudienceTypes.
     */
    data: AudienceTypeCreateManyInput | AudienceTypeCreateManyInput[]
  }

  /**
   * AudienceType createManyAndReturn
   */
  export type AudienceTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * The data used to create many AudienceTypes.
     */
    data: AudienceTypeCreateManyInput | AudienceTypeCreateManyInput[]
  }

  /**
   * AudienceType update
   */
  export type AudienceTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a AudienceType.
     */
    data: XOR<AudienceTypeUpdateInput, AudienceTypeUncheckedUpdateInput>
    /**
     * Choose, which AudienceType to update.
     */
    where: AudienceTypeWhereUniqueInput
  }

  /**
   * AudienceType updateMany
   */
  export type AudienceTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AudienceTypes.
     */
    data: XOR<AudienceTypeUpdateManyMutationInput, AudienceTypeUncheckedUpdateManyInput>
    /**
     * Filter which AudienceTypes to update
     */
    where?: AudienceTypeWhereInput
    /**
     * Limit how many AudienceTypes to update.
     */
    limit?: number
  }

  /**
   * AudienceType updateManyAndReturn
   */
  export type AudienceTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * The data used to update AudienceTypes.
     */
    data: XOR<AudienceTypeUpdateManyMutationInput, AudienceTypeUncheckedUpdateManyInput>
    /**
     * Filter which AudienceTypes to update
     */
    where?: AudienceTypeWhereInput
    /**
     * Limit how many AudienceTypes to update.
     */
    limit?: number
  }

  /**
   * AudienceType upsert
   */
  export type AudienceTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the AudienceType to update in case it exists.
     */
    where: AudienceTypeWhereUniqueInput
    /**
     * In case the AudienceType found by the `where` argument doesn't exist, create a new AudienceType with this data.
     */
    create: XOR<AudienceTypeCreateInput, AudienceTypeUncheckedCreateInput>
    /**
     * In case the AudienceType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AudienceTypeUpdateInput, AudienceTypeUncheckedUpdateInput>
  }

  /**
   * AudienceType delete
   */
  export type AudienceTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
    /**
     * Filter which AudienceType to delete.
     */
    where: AudienceTypeWhereUniqueInput
  }

  /**
   * AudienceType deleteMany
   */
  export type AudienceTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AudienceTypes to delete
     */
    where?: AudienceTypeWhereInput
    /**
     * Limit how many AudienceTypes to delete.
     */
    limit?: number
  }

  /**
   * AudienceType.sessions
   */
  export type AudienceType$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    where?: SessionAudienceTypeOnSessionWhereInput
    orderBy?: SessionAudienceTypeOnSessionOrderByWithRelationInput | SessionAudienceTypeOnSessionOrderByWithRelationInput[]
    cursor?: SessionAudienceTypeOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionAudienceTypeOnSessionScalarFieldEnum | SessionAudienceTypeOnSessionScalarFieldEnum[]
  }

  /**
   * AudienceType without action
   */
  export type AudienceTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AudienceType
     */
    select?: AudienceTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AudienceType
     */
    omit?: AudienceTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AudienceTypeInclude<ExtArgs> | null
  }


  /**
   * Model SessionAudienceTypeOnSession
   */

  export type AggregateSessionAudienceTypeOnSession = {
    _count: SessionAudienceTypeOnSessionCountAggregateOutputType | null
    _avg: SessionAudienceTypeOnSessionAvgAggregateOutputType | null
    _sum: SessionAudienceTypeOnSessionSumAggregateOutputType | null
    _min: SessionAudienceTypeOnSessionMinAggregateOutputType | null
    _max: SessionAudienceTypeOnSessionMaxAggregateOutputType | null
  }

  export type SessionAudienceTypeOnSessionAvgAggregateOutputType = {
    sessionId: number | null
    audienceTypeId: number | null
  }

  export type SessionAudienceTypeOnSessionSumAggregateOutputType = {
    sessionId: number | null
    audienceTypeId: number | null
  }

  export type SessionAudienceTypeOnSessionMinAggregateOutputType = {
    sessionId: number | null
    audienceTypeId: number | null
  }

  export type SessionAudienceTypeOnSessionMaxAggregateOutputType = {
    sessionId: number | null
    audienceTypeId: number | null
  }

  export type SessionAudienceTypeOnSessionCountAggregateOutputType = {
    sessionId: number
    audienceTypeId: number
    _all: number
  }


  export type SessionAudienceTypeOnSessionAvgAggregateInputType = {
    sessionId?: true
    audienceTypeId?: true
  }

  export type SessionAudienceTypeOnSessionSumAggregateInputType = {
    sessionId?: true
    audienceTypeId?: true
  }

  export type SessionAudienceTypeOnSessionMinAggregateInputType = {
    sessionId?: true
    audienceTypeId?: true
  }

  export type SessionAudienceTypeOnSessionMaxAggregateInputType = {
    sessionId?: true
    audienceTypeId?: true
  }

  export type SessionAudienceTypeOnSessionCountAggregateInputType = {
    sessionId?: true
    audienceTypeId?: true
    _all?: true
  }

  export type SessionAudienceTypeOnSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionAudienceTypeOnSession to aggregate.
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAudienceTypeOnSessions to fetch.
     */
    orderBy?: SessionAudienceTypeOnSessionOrderByWithRelationInput | SessionAudienceTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionAudienceTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAudienceTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAudienceTypeOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionAudienceTypeOnSessions
    **/
    _count?: true | SessionAudienceTypeOnSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionAudienceTypeOnSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionAudienceTypeOnSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionAudienceTypeOnSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionAudienceTypeOnSessionMaxAggregateInputType
  }

  export type GetSessionAudienceTypeOnSessionAggregateType<T extends SessionAudienceTypeOnSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionAudienceTypeOnSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionAudienceTypeOnSession[P]>
      : GetScalarType<T[P], AggregateSessionAudienceTypeOnSession[P]>
  }




  export type SessionAudienceTypeOnSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionAudienceTypeOnSessionWhereInput
    orderBy?: SessionAudienceTypeOnSessionOrderByWithAggregationInput | SessionAudienceTypeOnSessionOrderByWithAggregationInput[]
    by: SessionAudienceTypeOnSessionScalarFieldEnum[] | SessionAudienceTypeOnSessionScalarFieldEnum
    having?: SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionAudienceTypeOnSessionCountAggregateInputType | true
    _avg?: SessionAudienceTypeOnSessionAvgAggregateInputType
    _sum?: SessionAudienceTypeOnSessionSumAggregateInputType
    _min?: SessionAudienceTypeOnSessionMinAggregateInputType
    _max?: SessionAudienceTypeOnSessionMaxAggregateInputType
  }

  export type SessionAudienceTypeOnSessionGroupByOutputType = {
    sessionId: number
    audienceTypeId: number
    _count: SessionAudienceTypeOnSessionCountAggregateOutputType | null
    _avg: SessionAudienceTypeOnSessionAvgAggregateOutputType | null
    _sum: SessionAudienceTypeOnSessionSumAggregateOutputType | null
    _min: SessionAudienceTypeOnSessionMinAggregateOutputType | null
    _max: SessionAudienceTypeOnSessionMaxAggregateOutputType | null
  }

  type GetSessionAudienceTypeOnSessionGroupByPayload<T extends SessionAudienceTypeOnSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionAudienceTypeOnSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionAudienceTypeOnSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionAudienceTypeOnSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionAudienceTypeOnSessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionAudienceTypeOnSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    audienceTypeId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    audienceType?: boolean | AudienceTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionAudienceTypeOnSession"]>

  export type SessionAudienceTypeOnSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    audienceTypeId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    audienceType?: boolean | AudienceTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionAudienceTypeOnSession"]>

  export type SessionAudienceTypeOnSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    audienceTypeId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    audienceType?: boolean | AudienceTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionAudienceTypeOnSession"]>

  export type SessionAudienceTypeOnSessionSelectScalar = {
    sessionId?: boolean
    audienceTypeId?: boolean
  }

  export type SessionAudienceTypeOnSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "audienceTypeId", ExtArgs["result"]["sessionAudienceTypeOnSession"]>
  export type SessionAudienceTypeOnSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    audienceType?: boolean | AudienceTypeDefaultArgs<ExtArgs>
  }
  export type SessionAudienceTypeOnSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    audienceType?: boolean | AudienceTypeDefaultArgs<ExtArgs>
  }
  export type SessionAudienceTypeOnSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    audienceType?: boolean | AudienceTypeDefaultArgs<ExtArgs>
  }

  export type $SessionAudienceTypeOnSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionAudienceTypeOnSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      audienceType: Prisma.$AudienceTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      audienceTypeId: number
    }, ExtArgs["result"]["sessionAudienceTypeOnSession"]>
    composites: {}
  }

  type SessionAudienceTypeOnSessionGetPayload<S extends boolean | null | undefined | SessionAudienceTypeOnSessionDefaultArgs> = $Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload, S>

  type SessionAudienceTypeOnSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionAudienceTypeOnSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionAudienceTypeOnSessionCountAggregateInputType | true
    }

  export interface SessionAudienceTypeOnSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionAudienceTypeOnSession'], meta: { name: 'SessionAudienceTypeOnSession' } }
    /**
     * Find zero or one SessionAudienceTypeOnSession that matches the filter.
     * @param {SessionAudienceTypeOnSessionFindUniqueArgs} args - Arguments to find a SessionAudienceTypeOnSession
     * @example
     * // Get one SessionAudienceTypeOnSession
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionAudienceTypeOnSessionFindUniqueArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionFindUniqueArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionAudienceTypeOnSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionAudienceTypeOnSessionFindUniqueOrThrowArgs} args - Arguments to find a SessionAudienceTypeOnSession
     * @example
     * // Get one SessionAudienceTypeOnSession
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionAudienceTypeOnSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionAudienceTypeOnSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionFindFirstArgs} args - Arguments to find a SessionAudienceTypeOnSession
     * @example
     * // Get one SessionAudienceTypeOnSession
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionAudienceTypeOnSessionFindFirstArgs>(args?: SelectSubset<T, SessionAudienceTypeOnSessionFindFirstArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionAudienceTypeOnSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionFindFirstOrThrowArgs} args - Arguments to find a SessionAudienceTypeOnSession
     * @example
     * // Get one SessionAudienceTypeOnSession
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionAudienceTypeOnSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionAudienceTypeOnSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionAudienceTypeOnSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionAudienceTypeOnSessions
     * const sessionAudienceTypeOnSessions = await prisma.sessionAudienceTypeOnSession.findMany()
     * 
     * // Get first 10 SessionAudienceTypeOnSessions
     * const sessionAudienceTypeOnSessions = await prisma.sessionAudienceTypeOnSession.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionAudienceTypeOnSessionWithSessionIdOnly = await prisma.sessionAudienceTypeOnSession.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionAudienceTypeOnSessionFindManyArgs>(args?: SelectSubset<T, SessionAudienceTypeOnSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionAudienceTypeOnSession.
     * @param {SessionAudienceTypeOnSessionCreateArgs} args - Arguments to create a SessionAudienceTypeOnSession.
     * @example
     * // Create one SessionAudienceTypeOnSession
     * const SessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.create({
     *   data: {
     *     // ... data to create a SessionAudienceTypeOnSession
     *   }
     * })
     * 
     */
    create<T extends SessionAudienceTypeOnSessionCreateArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionCreateArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionAudienceTypeOnSessions.
     * @param {SessionAudienceTypeOnSessionCreateManyArgs} args - Arguments to create many SessionAudienceTypeOnSessions.
     * @example
     * // Create many SessionAudienceTypeOnSessions
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionAudienceTypeOnSessionCreateManyArgs>(args?: SelectSubset<T, SessionAudienceTypeOnSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionAudienceTypeOnSessions and returns the data saved in the database.
     * @param {SessionAudienceTypeOnSessionCreateManyAndReturnArgs} args - Arguments to create many SessionAudienceTypeOnSessions.
     * @example
     * // Create many SessionAudienceTypeOnSessions
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionAudienceTypeOnSessions and only return the `sessionId`
     * const sessionAudienceTypeOnSessionWithSessionIdOnly = await prisma.sessionAudienceTypeOnSession.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionAudienceTypeOnSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionAudienceTypeOnSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionAudienceTypeOnSession.
     * @param {SessionAudienceTypeOnSessionDeleteArgs} args - Arguments to delete one SessionAudienceTypeOnSession.
     * @example
     * // Delete one SessionAudienceTypeOnSession
     * const SessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.delete({
     *   where: {
     *     // ... filter to delete one SessionAudienceTypeOnSession
     *   }
     * })
     * 
     */
    delete<T extends SessionAudienceTypeOnSessionDeleteArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionDeleteArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionAudienceTypeOnSession.
     * @param {SessionAudienceTypeOnSessionUpdateArgs} args - Arguments to update one SessionAudienceTypeOnSession.
     * @example
     * // Update one SessionAudienceTypeOnSession
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionAudienceTypeOnSessionUpdateArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionUpdateArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionAudienceTypeOnSessions.
     * @param {SessionAudienceTypeOnSessionDeleteManyArgs} args - Arguments to filter SessionAudienceTypeOnSessions to delete.
     * @example
     * // Delete a few SessionAudienceTypeOnSessions
     * const { count } = await prisma.sessionAudienceTypeOnSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionAudienceTypeOnSessionDeleteManyArgs>(args?: SelectSubset<T, SessionAudienceTypeOnSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionAudienceTypeOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionAudienceTypeOnSessions
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionAudienceTypeOnSessionUpdateManyArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionAudienceTypeOnSessions and returns the data updated in the database.
     * @param {SessionAudienceTypeOnSessionUpdateManyAndReturnArgs} args - Arguments to update many SessionAudienceTypeOnSessions.
     * @example
     * // Update many SessionAudienceTypeOnSessions
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionAudienceTypeOnSessions and only return the `sessionId`
     * const sessionAudienceTypeOnSessionWithSessionIdOnly = await prisma.sessionAudienceTypeOnSession.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionAudienceTypeOnSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionAudienceTypeOnSession.
     * @param {SessionAudienceTypeOnSessionUpsertArgs} args - Arguments to update or create a SessionAudienceTypeOnSession.
     * @example
     * // Update or create a SessionAudienceTypeOnSession
     * const sessionAudienceTypeOnSession = await prisma.sessionAudienceTypeOnSession.upsert({
     *   create: {
     *     // ... data to create a SessionAudienceTypeOnSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionAudienceTypeOnSession we want to update
     *   }
     * })
     */
    upsert<T extends SessionAudienceTypeOnSessionUpsertArgs>(args: SelectSubset<T, SessionAudienceTypeOnSessionUpsertArgs<ExtArgs>>): Prisma__SessionAudienceTypeOnSessionClient<$Result.GetResult<Prisma.$SessionAudienceTypeOnSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionAudienceTypeOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionCountArgs} args - Arguments to filter SessionAudienceTypeOnSessions to count.
     * @example
     * // Count the number of SessionAudienceTypeOnSessions
     * const count = await prisma.sessionAudienceTypeOnSession.count({
     *   where: {
     *     // ... the filter for the SessionAudienceTypeOnSessions we want to count
     *   }
     * })
    **/
    count<T extends SessionAudienceTypeOnSessionCountArgs>(
      args?: Subset<T, SessionAudienceTypeOnSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionAudienceTypeOnSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionAudienceTypeOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAudienceTypeOnSessionAggregateArgs>(args: Subset<T, SessionAudienceTypeOnSessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAudienceTypeOnSessionAggregateType<T>>

    /**
     * Group by SessionAudienceTypeOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAudienceTypeOnSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionAudienceTypeOnSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionAudienceTypeOnSessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionAudienceTypeOnSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionAudienceTypeOnSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionAudienceTypeOnSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionAudienceTypeOnSession model
   */
  readonly fields: SessionAudienceTypeOnSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionAudienceTypeOnSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionAudienceTypeOnSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    audienceType<T extends AudienceTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AudienceTypeDefaultArgs<ExtArgs>>): Prisma__AudienceTypeClient<$Result.GetResult<Prisma.$AudienceTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionAudienceTypeOnSession model
   */
  interface SessionAudienceTypeOnSessionFieldRefs {
    readonly sessionId: FieldRef<"SessionAudienceTypeOnSession", 'Int'>
    readonly audienceTypeId: FieldRef<"SessionAudienceTypeOnSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionAudienceTypeOnSession findUnique
   */
  export type SessionAudienceTypeOnSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionAudienceTypeOnSession to fetch.
     */
    where: SessionAudienceTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionAudienceTypeOnSession findUniqueOrThrow
   */
  export type SessionAudienceTypeOnSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionAudienceTypeOnSession to fetch.
     */
    where: SessionAudienceTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionAudienceTypeOnSession findFirst
   */
  export type SessionAudienceTypeOnSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionAudienceTypeOnSession to fetch.
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAudienceTypeOnSessions to fetch.
     */
    orderBy?: SessionAudienceTypeOnSessionOrderByWithRelationInput | SessionAudienceTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionAudienceTypeOnSessions.
     */
    cursor?: SessionAudienceTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAudienceTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAudienceTypeOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionAudienceTypeOnSessions.
     */
    distinct?: SessionAudienceTypeOnSessionScalarFieldEnum | SessionAudienceTypeOnSessionScalarFieldEnum[]
  }

  /**
   * SessionAudienceTypeOnSession findFirstOrThrow
   */
  export type SessionAudienceTypeOnSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionAudienceTypeOnSession to fetch.
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAudienceTypeOnSessions to fetch.
     */
    orderBy?: SessionAudienceTypeOnSessionOrderByWithRelationInput | SessionAudienceTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionAudienceTypeOnSessions.
     */
    cursor?: SessionAudienceTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAudienceTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAudienceTypeOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionAudienceTypeOnSessions.
     */
    distinct?: SessionAudienceTypeOnSessionScalarFieldEnum | SessionAudienceTypeOnSessionScalarFieldEnum[]
  }

  /**
   * SessionAudienceTypeOnSession findMany
   */
  export type SessionAudienceTypeOnSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionAudienceTypeOnSessions to fetch.
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionAudienceTypeOnSessions to fetch.
     */
    orderBy?: SessionAudienceTypeOnSessionOrderByWithRelationInput | SessionAudienceTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionAudienceTypeOnSessions.
     */
    cursor?: SessionAudienceTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionAudienceTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionAudienceTypeOnSessions.
     */
    skip?: number
    distinct?: SessionAudienceTypeOnSessionScalarFieldEnum | SessionAudienceTypeOnSessionScalarFieldEnum[]
  }

  /**
   * SessionAudienceTypeOnSession create
   */
  export type SessionAudienceTypeOnSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionAudienceTypeOnSession.
     */
    data: XOR<SessionAudienceTypeOnSessionCreateInput, SessionAudienceTypeOnSessionUncheckedCreateInput>
  }

  /**
   * SessionAudienceTypeOnSession createMany
   */
  export type SessionAudienceTypeOnSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionAudienceTypeOnSessions.
     */
    data: SessionAudienceTypeOnSessionCreateManyInput | SessionAudienceTypeOnSessionCreateManyInput[]
  }

  /**
   * SessionAudienceTypeOnSession createManyAndReturn
   */
  export type SessionAudienceTypeOnSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SessionAudienceTypeOnSessions.
     */
    data: SessionAudienceTypeOnSessionCreateManyInput | SessionAudienceTypeOnSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionAudienceTypeOnSession update
   */
  export type SessionAudienceTypeOnSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionAudienceTypeOnSession.
     */
    data: XOR<SessionAudienceTypeOnSessionUpdateInput, SessionAudienceTypeOnSessionUncheckedUpdateInput>
    /**
     * Choose, which SessionAudienceTypeOnSession to update.
     */
    where: SessionAudienceTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionAudienceTypeOnSession updateMany
   */
  export type SessionAudienceTypeOnSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionAudienceTypeOnSessions.
     */
    data: XOR<SessionAudienceTypeOnSessionUpdateManyMutationInput, SessionAudienceTypeOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionAudienceTypeOnSessions to update
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * Limit how many SessionAudienceTypeOnSessions to update.
     */
    limit?: number
  }

  /**
   * SessionAudienceTypeOnSession updateManyAndReturn
   */
  export type SessionAudienceTypeOnSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * The data used to update SessionAudienceTypeOnSessions.
     */
    data: XOR<SessionAudienceTypeOnSessionUpdateManyMutationInput, SessionAudienceTypeOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionAudienceTypeOnSessions to update
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * Limit how many SessionAudienceTypeOnSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionAudienceTypeOnSession upsert
   */
  export type SessionAudienceTypeOnSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionAudienceTypeOnSession to update in case it exists.
     */
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    /**
     * In case the SessionAudienceTypeOnSession found by the `where` argument doesn't exist, create a new SessionAudienceTypeOnSession with this data.
     */
    create: XOR<SessionAudienceTypeOnSessionCreateInput, SessionAudienceTypeOnSessionUncheckedCreateInput>
    /**
     * In case the SessionAudienceTypeOnSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionAudienceTypeOnSessionUpdateInput, SessionAudienceTypeOnSessionUncheckedUpdateInput>
  }

  /**
   * SessionAudienceTypeOnSession delete
   */
  export type SessionAudienceTypeOnSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter which SessionAudienceTypeOnSession to delete.
     */
    where: SessionAudienceTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionAudienceTypeOnSession deleteMany
   */
  export type SessionAudienceTypeOnSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionAudienceTypeOnSessions to delete
     */
    where?: SessionAudienceTypeOnSessionWhereInput
    /**
     * Limit how many SessionAudienceTypeOnSessions to delete.
     */
    limit?: number
  }

  /**
   * SessionAudienceTypeOnSession without action
   */
  export type SessionAudienceTypeOnSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionAudienceTypeOnSession
     */
    select?: SessionAudienceTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionAudienceTypeOnSession
     */
    omit?: SessionAudienceTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionAudienceTypeOnSessionInclude<ExtArgs> | null
  }


  /**
   * Model Industry
   */

  export type AggregateIndustry = {
    _count: IndustryCountAggregateOutputType | null
    _avg: IndustryAvgAggregateOutputType | null
    _sum: IndustrySumAggregateOutputType | null
    _min: IndustryMinAggregateOutputType | null
    _max: IndustryMaxAggregateOutputType | null
  }

  export type IndustryAvgAggregateOutputType = {
    id: number | null
  }

  export type IndustrySumAggregateOutputType = {
    id: number | null
  }

  export type IndustryMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type IndustryMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type IndustryCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type IndustryAvgAggregateInputType = {
    id?: true
  }

  export type IndustrySumAggregateInputType = {
    id?: true
  }

  export type IndustryMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type IndustryMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type IndustryCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type IndustryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Industry to aggregate.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Industries
    **/
    _count?: true | IndustryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IndustryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IndustrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IndustryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IndustryMaxAggregateInputType
  }

  export type GetIndustryAggregateType<T extends IndustryAggregateArgs> = {
        [P in keyof T & keyof AggregateIndustry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIndustry[P]>
      : GetScalarType<T[P], AggregateIndustry[P]>
  }




  export type IndustryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IndustryWhereInput
    orderBy?: IndustryOrderByWithAggregationInput | IndustryOrderByWithAggregationInput[]
    by: IndustryScalarFieldEnum[] | IndustryScalarFieldEnum
    having?: IndustryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IndustryCountAggregateInputType | true
    _avg?: IndustryAvgAggregateInputType
    _sum?: IndustrySumAggregateInputType
    _min?: IndustryMinAggregateInputType
    _max?: IndustryMaxAggregateInputType
  }

  export type IndustryGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: IndustryCountAggregateOutputType | null
    _avg: IndustryAvgAggregateOutputType | null
    _sum: IndustrySumAggregateOutputType | null
    _min: IndustryMinAggregateOutputType | null
    _max: IndustryMaxAggregateOutputType | null
  }

  type GetIndustryGroupByPayload<T extends IndustryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IndustryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IndustryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IndustryGroupByOutputType[P]>
            : GetScalarType<T[P], IndustryGroupByOutputType[P]>
        }
      >
    >


  export type IndustrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | Industry$sessionsArgs<ExtArgs>
    _count?: boolean | IndustryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["industry"]>

  export type IndustrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["industry"]>

  export type IndustrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["industry"]>

  export type IndustrySelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type IndustryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["industry"]>
  export type IndustryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | Industry$sessionsArgs<ExtArgs>
    _count?: boolean | IndustryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IndustryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IndustryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IndustryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Industry"
    objects: {
      sessions: Prisma.$SessionIndustryOnSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["industry"]>
    composites: {}
  }

  type IndustryGetPayload<S extends boolean | null | undefined | IndustryDefaultArgs> = $Result.GetResult<Prisma.$IndustryPayload, S>

  type IndustryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IndustryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IndustryCountAggregateInputType | true
    }

  export interface IndustryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Industry'], meta: { name: 'Industry' } }
    /**
     * Find zero or one Industry that matches the filter.
     * @param {IndustryFindUniqueArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IndustryFindUniqueArgs>(args: SelectSubset<T, IndustryFindUniqueArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Industry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IndustryFindUniqueOrThrowArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IndustryFindUniqueOrThrowArgs>(args: SelectSubset<T, IndustryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindFirstArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IndustryFindFirstArgs>(args?: SelectSubset<T, IndustryFindFirstArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Industry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindFirstOrThrowArgs} args - Arguments to find a Industry
     * @example
     * // Get one Industry
     * const industry = await prisma.industry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IndustryFindFirstOrThrowArgs>(args?: SelectSubset<T, IndustryFindFirstOrThrowArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Industries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Industries
     * const industries = await prisma.industry.findMany()
     * 
     * // Get first 10 Industries
     * const industries = await prisma.industry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const industryWithIdOnly = await prisma.industry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IndustryFindManyArgs>(args?: SelectSubset<T, IndustryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Industry.
     * @param {IndustryCreateArgs} args - Arguments to create a Industry.
     * @example
     * // Create one Industry
     * const Industry = await prisma.industry.create({
     *   data: {
     *     // ... data to create a Industry
     *   }
     * })
     * 
     */
    create<T extends IndustryCreateArgs>(args: SelectSubset<T, IndustryCreateArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Industries.
     * @param {IndustryCreateManyArgs} args - Arguments to create many Industries.
     * @example
     * // Create many Industries
     * const industry = await prisma.industry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IndustryCreateManyArgs>(args?: SelectSubset<T, IndustryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Industries and returns the data saved in the database.
     * @param {IndustryCreateManyAndReturnArgs} args - Arguments to create many Industries.
     * @example
     * // Create many Industries
     * const industry = await prisma.industry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Industries and only return the `id`
     * const industryWithIdOnly = await prisma.industry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IndustryCreateManyAndReturnArgs>(args?: SelectSubset<T, IndustryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Industry.
     * @param {IndustryDeleteArgs} args - Arguments to delete one Industry.
     * @example
     * // Delete one Industry
     * const Industry = await prisma.industry.delete({
     *   where: {
     *     // ... filter to delete one Industry
     *   }
     * })
     * 
     */
    delete<T extends IndustryDeleteArgs>(args: SelectSubset<T, IndustryDeleteArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Industry.
     * @param {IndustryUpdateArgs} args - Arguments to update one Industry.
     * @example
     * // Update one Industry
     * const industry = await prisma.industry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IndustryUpdateArgs>(args: SelectSubset<T, IndustryUpdateArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Industries.
     * @param {IndustryDeleteManyArgs} args - Arguments to filter Industries to delete.
     * @example
     * // Delete a few Industries
     * const { count } = await prisma.industry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IndustryDeleteManyArgs>(args?: SelectSubset<T, IndustryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Industries
     * const industry = await prisma.industry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IndustryUpdateManyArgs>(args: SelectSubset<T, IndustryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Industries and returns the data updated in the database.
     * @param {IndustryUpdateManyAndReturnArgs} args - Arguments to update many Industries.
     * @example
     * // Update many Industries
     * const industry = await prisma.industry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Industries and only return the `id`
     * const industryWithIdOnly = await prisma.industry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IndustryUpdateManyAndReturnArgs>(args: SelectSubset<T, IndustryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Industry.
     * @param {IndustryUpsertArgs} args - Arguments to update or create a Industry.
     * @example
     * // Update or create a Industry
     * const industry = await prisma.industry.upsert({
     *   create: {
     *     // ... data to create a Industry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Industry we want to update
     *   }
     * })
     */
    upsert<T extends IndustryUpsertArgs>(args: SelectSubset<T, IndustryUpsertArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Industries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryCountArgs} args - Arguments to filter Industries to count.
     * @example
     * // Count the number of Industries
     * const count = await prisma.industry.count({
     *   where: {
     *     // ... the filter for the Industries we want to count
     *   }
     * })
    **/
    count<T extends IndustryCountArgs>(
      args?: Subset<T, IndustryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IndustryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IndustryAggregateArgs>(args: Subset<T, IndustryAggregateArgs>): Prisma.PrismaPromise<GetIndustryAggregateType<T>>

    /**
     * Group by Industry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IndustryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IndustryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IndustryGroupByArgs['orderBy'] }
        : { orderBy?: IndustryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IndustryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIndustryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Industry model
   */
  readonly fields: IndustryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Industry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IndustryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends Industry$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, Industry$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Industry model
   */
  interface IndustryFieldRefs {
    readonly id: FieldRef<"Industry", 'Int'>
    readonly logicalValue: FieldRef<"Industry", 'String'>
    readonly displayValue: FieldRef<"Industry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Industry findUnique
   */
  export type IndustryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry findUniqueOrThrow
   */
  export type IndustryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry findFirst
   */
  export type IndustryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Industries.
     */
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry findFirstOrThrow
   */
  export type IndustryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industry to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Industries.
     */
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry findMany
   */
  export type IndustryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter, which Industries to fetch.
     */
    where?: IndustryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Industries to fetch.
     */
    orderBy?: IndustryOrderByWithRelationInput | IndustryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Industries.
     */
    cursor?: IndustryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Industries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Industries.
     */
    skip?: number
    distinct?: IndustryScalarFieldEnum | IndustryScalarFieldEnum[]
  }

  /**
   * Industry create
   */
  export type IndustryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * The data needed to create a Industry.
     */
    data: XOR<IndustryCreateInput, IndustryUncheckedCreateInput>
  }

  /**
   * Industry createMany
   */
  export type IndustryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Industries.
     */
    data: IndustryCreateManyInput | IndustryCreateManyInput[]
  }

  /**
   * Industry createManyAndReturn
   */
  export type IndustryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The data used to create many Industries.
     */
    data: IndustryCreateManyInput | IndustryCreateManyInput[]
  }

  /**
   * Industry update
   */
  export type IndustryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * The data needed to update a Industry.
     */
    data: XOR<IndustryUpdateInput, IndustryUncheckedUpdateInput>
    /**
     * Choose, which Industry to update.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry updateMany
   */
  export type IndustryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Industries.
     */
    data: XOR<IndustryUpdateManyMutationInput, IndustryUncheckedUpdateManyInput>
    /**
     * Filter which Industries to update
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to update.
     */
    limit?: number
  }

  /**
   * Industry updateManyAndReturn
   */
  export type IndustryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * The data used to update Industries.
     */
    data: XOR<IndustryUpdateManyMutationInput, IndustryUncheckedUpdateManyInput>
    /**
     * Filter which Industries to update
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to update.
     */
    limit?: number
  }

  /**
   * Industry upsert
   */
  export type IndustryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * The filter to search for the Industry to update in case it exists.
     */
    where: IndustryWhereUniqueInput
    /**
     * In case the Industry found by the `where` argument doesn't exist, create a new Industry with this data.
     */
    create: XOR<IndustryCreateInput, IndustryUncheckedCreateInput>
    /**
     * In case the Industry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IndustryUpdateInput, IndustryUncheckedUpdateInput>
  }

  /**
   * Industry delete
   */
  export type IndustryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
    /**
     * Filter which Industry to delete.
     */
    where: IndustryWhereUniqueInput
  }

  /**
   * Industry deleteMany
   */
  export type IndustryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Industries to delete
     */
    where?: IndustryWhereInput
    /**
     * Limit how many Industries to delete.
     */
    limit?: number
  }

  /**
   * Industry.sessions
   */
  export type Industry$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    where?: SessionIndustryOnSessionWhereInput
    orderBy?: SessionIndustryOnSessionOrderByWithRelationInput | SessionIndustryOnSessionOrderByWithRelationInput[]
    cursor?: SessionIndustryOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionIndustryOnSessionScalarFieldEnum | SessionIndustryOnSessionScalarFieldEnum[]
  }

  /**
   * Industry without action
   */
  export type IndustryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Industry
     */
    select?: IndustrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Industry
     */
    omit?: IndustryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IndustryInclude<ExtArgs> | null
  }


  /**
   * Model SessionIndustryOnSession
   */

  export type AggregateSessionIndustryOnSession = {
    _count: SessionIndustryOnSessionCountAggregateOutputType | null
    _avg: SessionIndustryOnSessionAvgAggregateOutputType | null
    _sum: SessionIndustryOnSessionSumAggregateOutputType | null
    _min: SessionIndustryOnSessionMinAggregateOutputType | null
    _max: SessionIndustryOnSessionMaxAggregateOutputType | null
  }

  export type SessionIndustryOnSessionAvgAggregateOutputType = {
    sessionId: number | null
    industryId: number | null
  }

  export type SessionIndustryOnSessionSumAggregateOutputType = {
    sessionId: number | null
    industryId: number | null
  }

  export type SessionIndustryOnSessionMinAggregateOutputType = {
    sessionId: number | null
    industryId: number | null
  }

  export type SessionIndustryOnSessionMaxAggregateOutputType = {
    sessionId: number | null
    industryId: number | null
  }

  export type SessionIndustryOnSessionCountAggregateOutputType = {
    sessionId: number
    industryId: number
    _all: number
  }


  export type SessionIndustryOnSessionAvgAggregateInputType = {
    sessionId?: true
    industryId?: true
  }

  export type SessionIndustryOnSessionSumAggregateInputType = {
    sessionId?: true
    industryId?: true
  }

  export type SessionIndustryOnSessionMinAggregateInputType = {
    sessionId?: true
    industryId?: true
  }

  export type SessionIndustryOnSessionMaxAggregateInputType = {
    sessionId?: true
    industryId?: true
  }

  export type SessionIndustryOnSessionCountAggregateInputType = {
    sessionId?: true
    industryId?: true
    _all?: true
  }

  export type SessionIndustryOnSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionIndustryOnSession to aggregate.
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionIndustryOnSessions to fetch.
     */
    orderBy?: SessionIndustryOnSessionOrderByWithRelationInput | SessionIndustryOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionIndustryOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionIndustryOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionIndustryOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionIndustryOnSessions
    **/
    _count?: true | SessionIndustryOnSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionIndustryOnSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionIndustryOnSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionIndustryOnSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionIndustryOnSessionMaxAggregateInputType
  }

  export type GetSessionIndustryOnSessionAggregateType<T extends SessionIndustryOnSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionIndustryOnSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionIndustryOnSession[P]>
      : GetScalarType<T[P], AggregateSessionIndustryOnSession[P]>
  }




  export type SessionIndustryOnSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionIndustryOnSessionWhereInput
    orderBy?: SessionIndustryOnSessionOrderByWithAggregationInput | SessionIndustryOnSessionOrderByWithAggregationInput[]
    by: SessionIndustryOnSessionScalarFieldEnum[] | SessionIndustryOnSessionScalarFieldEnum
    having?: SessionIndustryOnSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionIndustryOnSessionCountAggregateInputType | true
    _avg?: SessionIndustryOnSessionAvgAggregateInputType
    _sum?: SessionIndustryOnSessionSumAggregateInputType
    _min?: SessionIndustryOnSessionMinAggregateInputType
    _max?: SessionIndustryOnSessionMaxAggregateInputType
  }

  export type SessionIndustryOnSessionGroupByOutputType = {
    sessionId: number
    industryId: number
    _count: SessionIndustryOnSessionCountAggregateOutputType | null
    _avg: SessionIndustryOnSessionAvgAggregateOutputType | null
    _sum: SessionIndustryOnSessionSumAggregateOutputType | null
    _min: SessionIndustryOnSessionMinAggregateOutputType | null
    _max: SessionIndustryOnSessionMaxAggregateOutputType | null
  }

  type GetSessionIndustryOnSessionGroupByPayload<T extends SessionIndustryOnSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionIndustryOnSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionIndustryOnSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionIndustryOnSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionIndustryOnSessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionIndustryOnSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    industryId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionIndustryOnSession"]>

  export type SessionIndustryOnSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    industryId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionIndustryOnSession"]>

  export type SessionIndustryOnSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    industryId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionIndustryOnSession"]>

  export type SessionIndustryOnSessionSelectScalar = {
    sessionId?: boolean
    industryId?: boolean
  }

  export type SessionIndustryOnSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "industryId", ExtArgs["result"]["sessionIndustryOnSession"]>
  export type SessionIndustryOnSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type SessionIndustryOnSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }
  export type SessionIndustryOnSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    industry?: boolean | IndustryDefaultArgs<ExtArgs>
  }

  export type $SessionIndustryOnSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionIndustryOnSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      industry: Prisma.$IndustryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      industryId: number
    }, ExtArgs["result"]["sessionIndustryOnSession"]>
    composites: {}
  }

  type SessionIndustryOnSessionGetPayload<S extends boolean | null | undefined | SessionIndustryOnSessionDefaultArgs> = $Result.GetResult<Prisma.$SessionIndustryOnSessionPayload, S>

  type SessionIndustryOnSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionIndustryOnSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionIndustryOnSessionCountAggregateInputType | true
    }

  export interface SessionIndustryOnSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionIndustryOnSession'], meta: { name: 'SessionIndustryOnSession' } }
    /**
     * Find zero or one SessionIndustryOnSession that matches the filter.
     * @param {SessionIndustryOnSessionFindUniqueArgs} args - Arguments to find a SessionIndustryOnSession
     * @example
     * // Get one SessionIndustryOnSession
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionIndustryOnSessionFindUniqueArgs>(args: SelectSubset<T, SessionIndustryOnSessionFindUniqueArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionIndustryOnSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionIndustryOnSessionFindUniqueOrThrowArgs} args - Arguments to find a SessionIndustryOnSession
     * @example
     * // Get one SessionIndustryOnSession
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionIndustryOnSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionIndustryOnSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionIndustryOnSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionFindFirstArgs} args - Arguments to find a SessionIndustryOnSession
     * @example
     * // Get one SessionIndustryOnSession
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionIndustryOnSessionFindFirstArgs>(args?: SelectSubset<T, SessionIndustryOnSessionFindFirstArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionIndustryOnSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionFindFirstOrThrowArgs} args - Arguments to find a SessionIndustryOnSession
     * @example
     * // Get one SessionIndustryOnSession
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionIndustryOnSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionIndustryOnSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionIndustryOnSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionIndustryOnSessions
     * const sessionIndustryOnSessions = await prisma.sessionIndustryOnSession.findMany()
     * 
     * // Get first 10 SessionIndustryOnSessions
     * const sessionIndustryOnSessions = await prisma.sessionIndustryOnSession.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionIndustryOnSessionWithSessionIdOnly = await prisma.sessionIndustryOnSession.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionIndustryOnSessionFindManyArgs>(args?: SelectSubset<T, SessionIndustryOnSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionIndustryOnSession.
     * @param {SessionIndustryOnSessionCreateArgs} args - Arguments to create a SessionIndustryOnSession.
     * @example
     * // Create one SessionIndustryOnSession
     * const SessionIndustryOnSession = await prisma.sessionIndustryOnSession.create({
     *   data: {
     *     // ... data to create a SessionIndustryOnSession
     *   }
     * })
     * 
     */
    create<T extends SessionIndustryOnSessionCreateArgs>(args: SelectSubset<T, SessionIndustryOnSessionCreateArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionIndustryOnSessions.
     * @param {SessionIndustryOnSessionCreateManyArgs} args - Arguments to create many SessionIndustryOnSessions.
     * @example
     * // Create many SessionIndustryOnSessions
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionIndustryOnSessionCreateManyArgs>(args?: SelectSubset<T, SessionIndustryOnSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionIndustryOnSessions and returns the data saved in the database.
     * @param {SessionIndustryOnSessionCreateManyAndReturnArgs} args - Arguments to create many SessionIndustryOnSessions.
     * @example
     * // Create many SessionIndustryOnSessions
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionIndustryOnSessions and only return the `sessionId`
     * const sessionIndustryOnSessionWithSessionIdOnly = await prisma.sessionIndustryOnSession.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionIndustryOnSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionIndustryOnSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionIndustryOnSession.
     * @param {SessionIndustryOnSessionDeleteArgs} args - Arguments to delete one SessionIndustryOnSession.
     * @example
     * // Delete one SessionIndustryOnSession
     * const SessionIndustryOnSession = await prisma.sessionIndustryOnSession.delete({
     *   where: {
     *     // ... filter to delete one SessionIndustryOnSession
     *   }
     * })
     * 
     */
    delete<T extends SessionIndustryOnSessionDeleteArgs>(args: SelectSubset<T, SessionIndustryOnSessionDeleteArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionIndustryOnSession.
     * @param {SessionIndustryOnSessionUpdateArgs} args - Arguments to update one SessionIndustryOnSession.
     * @example
     * // Update one SessionIndustryOnSession
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionIndustryOnSessionUpdateArgs>(args: SelectSubset<T, SessionIndustryOnSessionUpdateArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionIndustryOnSessions.
     * @param {SessionIndustryOnSessionDeleteManyArgs} args - Arguments to filter SessionIndustryOnSessions to delete.
     * @example
     * // Delete a few SessionIndustryOnSessions
     * const { count } = await prisma.sessionIndustryOnSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionIndustryOnSessionDeleteManyArgs>(args?: SelectSubset<T, SessionIndustryOnSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionIndustryOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionIndustryOnSessions
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionIndustryOnSessionUpdateManyArgs>(args: SelectSubset<T, SessionIndustryOnSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionIndustryOnSessions and returns the data updated in the database.
     * @param {SessionIndustryOnSessionUpdateManyAndReturnArgs} args - Arguments to update many SessionIndustryOnSessions.
     * @example
     * // Update many SessionIndustryOnSessions
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionIndustryOnSessions and only return the `sessionId`
     * const sessionIndustryOnSessionWithSessionIdOnly = await prisma.sessionIndustryOnSession.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionIndustryOnSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionIndustryOnSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionIndustryOnSession.
     * @param {SessionIndustryOnSessionUpsertArgs} args - Arguments to update or create a SessionIndustryOnSession.
     * @example
     * // Update or create a SessionIndustryOnSession
     * const sessionIndustryOnSession = await prisma.sessionIndustryOnSession.upsert({
     *   create: {
     *     // ... data to create a SessionIndustryOnSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionIndustryOnSession we want to update
     *   }
     * })
     */
    upsert<T extends SessionIndustryOnSessionUpsertArgs>(args: SelectSubset<T, SessionIndustryOnSessionUpsertArgs<ExtArgs>>): Prisma__SessionIndustryOnSessionClient<$Result.GetResult<Prisma.$SessionIndustryOnSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionIndustryOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionCountArgs} args - Arguments to filter SessionIndustryOnSessions to count.
     * @example
     * // Count the number of SessionIndustryOnSessions
     * const count = await prisma.sessionIndustryOnSession.count({
     *   where: {
     *     // ... the filter for the SessionIndustryOnSessions we want to count
     *   }
     * })
    **/
    count<T extends SessionIndustryOnSessionCountArgs>(
      args?: Subset<T, SessionIndustryOnSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionIndustryOnSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionIndustryOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionIndustryOnSessionAggregateArgs>(args: Subset<T, SessionIndustryOnSessionAggregateArgs>): Prisma.PrismaPromise<GetSessionIndustryOnSessionAggregateType<T>>

    /**
     * Group by SessionIndustryOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionIndustryOnSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionIndustryOnSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionIndustryOnSessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionIndustryOnSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionIndustryOnSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionIndustryOnSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionIndustryOnSession model
   */
  readonly fields: SessionIndustryOnSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionIndustryOnSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionIndustryOnSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    industry<T extends IndustryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IndustryDefaultArgs<ExtArgs>>): Prisma__IndustryClient<$Result.GetResult<Prisma.$IndustryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionIndustryOnSession model
   */
  interface SessionIndustryOnSessionFieldRefs {
    readonly sessionId: FieldRef<"SessionIndustryOnSession", 'Int'>
    readonly industryId: FieldRef<"SessionIndustryOnSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionIndustryOnSession findUnique
   */
  export type SessionIndustryOnSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionIndustryOnSession to fetch.
     */
    where: SessionIndustryOnSessionWhereUniqueInput
  }

  /**
   * SessionIndustryOnSession findUniqueOrThrow
   */
  export type SessionIndustryOnSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionIndustryOnSession to fetch.
     */
    where: SessionIndustryOnSessionWhereUniqueInput
  }

  /**
   * SessionIndustryOnSession findFirst
   */
  export type SessionIndustryOnSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionIndustryOnSession to fetch.
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionIndustryOnSessions to fetch.
     */
    orderBy?: SessionIndustryOnSessionOrderByWithRelationInput | SessionIndustryOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionIndustryOnSessions.
     */
    cursor?: SessionIndustryOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionIndustryOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionIndustryOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionIndustryOnSessions.
     */
    distinct?: SessionIndustryOnSessionScalarFieldEnum | SessionIndustryOnSessionScalarFieldEnum[]
  }

  /**
   * SessionIndustryOnSession findFirstOrThrow
   */
  export type SessionIndustryOnSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionIndustryOnSession to fetch.
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionIndustryOnSessions to fetch.
     */
    orderBy?: SessionIndustryOnSessionOrderByWithRelationInput | SessionIndustryOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionIndustryOnSessions.
     */
    cursor?: SessionIndustryOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionIndustryOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionIndustryOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionIndustryOnSessions.
     */
    distinct?: SessionIndustryOnSessionScalarFieldEnum | SessionIndustryOnSessionScalarFieldEnum[]
  }

  /**
   * SessionIndustryOnSession findMany
   */
  export type SessionIndustryOnSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionIndustryOnSessions to fetch.
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionIndustryOnSessions to fetch.
     */
    orderBy?: SessionIndustryOnSessionOrderByWithRelationInput | SessionIndustryOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionIndustryOnSessions.
     */
    cursor?: SessionIndustryOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionIndustryOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionIndustryOnSessions.
     */
    skip?: number
    distinct?: SessionIndustryOnSessionScalarFieldEnum | SessionIndustryOnSessionScalarFieldEnum[]
  }

  /**
   * SessionIndustryOnSession create
   */
  export type SessionIndustryOnSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionIndustryOnSession.
     */
    data: XOR<SessionIndustryOnSessionCreateInput, SessionIndustryOnSessionUncheckedCreateInput>
  }

  /**
   * SessionIndustryOnSession createMany
   */
  export type SessionIndustryOnSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionIndustryOnSessions.
     */
    data: SessionIndustryOnSessionCreateManyInput | SessionIndustryOnSessionCreateManyInput[]
  }

  /**
   * SessionIndustryOnSession createManyAndReturn
   */
  export type SessionIndustryOnSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SessionIndustryOnSessions.
     */
    data: SessionIndustryOnSessionCreateManyInput | SessionIndustryOnSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionIndustryOnSession update
   */
  export type SessionIndustryOnSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionIndustryOnSession.
     */
    data: XOR<SessionIndustryOnSessionUpdateInput, SessionIndustryOnSessionUncheckedUpdateInput>
    /**
     * Choose, which SessionIndustryOnSession to update.
     */
    where: SessionIndustryOnSessionWhereUniqueInput
  }

  /**
   * SessionIndustryOnSession updateMany
   */
  export type SessionIndustryOnSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionIndustryOnSessions.
     */
    data: XOR<SessionIndustryOnSessionUpdateManyMutationInput, SessionIndustryOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionIndustryOnSessions to update
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * Limit how many SessionIndustryOnSessions to update.
     */
    limit?: number
  }

  /**
   * SessionIndustryOnSession updateManyAndReturn
   */
  export type SessionIndustryOnSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * The data used to update SessionIndustryOnSessions.
     */
    data: XOR<SessionIndustryOnSessionUpdateManyMutationInput, SessionIndustryOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionIndustryOnSessions to update
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * Limit how many SessionIndustryOnSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionIndustryOnSession upsert
   */
  export type SessionIndustryOnSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionIndustryOnSession to update in case it exists.
     */
    where: SessionIndustryOnSessionWhereUniqueInput
    /**
     * In case the SessionIndustryOnSession found by the `where` argument doesn't exist, create a new SessionIndustryOnSession with this data.
     */
    create: XOR<SessionIndustryOnSessionCreateInput, SessionIndustryOnSessionUncheckedCreateInput>
    /**
     * In case the SessionIndustryOnSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionIndustryOnSessionUpdateInput, SessionIndustryOnSessionUncheckedUpdateInput>
  }

  /**
   * SessionIndustryOnSession delete
   */
  export type SessionIndustryOnSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
    /**
     * Filter which SessionIndustryOnSession to delete.
     */
    where: SessionIndustryOnSessionWhereUniqueInput
  }

  /**
   * SessionIndustryOnSession deleteMany
   */
  export type SessionIndustryOnSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionIndustryOnSessions to delete
     */
    where?: SessionIndustryOnSessionWhereInput
    /**
     * Limit how many SessionIndustryOnSessions to delete.
     */
    limit?: number
  }

  /**
   * SessionIndustryOnSession without action
   */
  export type SessionIndustryOnSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionIndustryOnSession
     */
    select?: SessionIndustryOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionIndustryOnSession
     */
    omit?: SessionIndustryOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIndustryOnSessionInclude<ExtArgs> | null
  }


  /**
   * Model DeliveryType
   */

  export type AggregateDeliveryType = {
    _count: DeliveryTypeCountAggregateOutputType | null
    _avg: DeliveryTypeAvgAggregateOutputType | null
    _sum: DeliveryTypeSumAggregateOutputType | null
    _min: DeliveryTypeMinAggregateOutputType | null
    _max: DeliveryTypeMaxAggregateOutputType | null
  }

  export type DeliveryTypeAvgAggregateOutputType = {
    id: number | null
  }

  export type DeliveryTypeSumAggregateOutputType = {
    id: number | null
  }

  export type DeliveryTypeMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type DeliveryTypeMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type DeliveryTypeCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type DeliveryTypeAvgAggregateInputType = {
    id?: true
  }

  export type DeliveryTypeSumAggregateInputType = {
    id?: true
  }

  export type DeliveryTypeMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type DeliveryTypeMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type DeliveryTypeCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type DeliveryTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryType to aggregate.
     */
    where?: DeliveryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTypes to fetch.
     */
    orderBy?: DeliveryTypeOrderByWithRelationInput | DeliveryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeliveryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeliveryTypes
    **/
    _count?: true | DeliveryTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DeliveryTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DeliveryTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeliveryTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeliveryTypeMaxAggregateInputType
  }

  export type GetDeliveryTypeAggregateType<T extends DeliveryTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateDeliveryType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeliveryType[P]>
      : GetScalarType<T[P], AggregateDeliveryType[P]>
  }




  export type DeliveryTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeliveryTypeWhereInput
    orderBy?: DeliveryTypeOrderByWithAggregationInput | DeliveryTypeOrderByWithAggregationInput[]
    by: DeliveryTypeScalarFieldEnum[] | DeliveryTypeScalarFieldEnum
    having?: DeliveryTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeliveryTypeCountAggregateInputType | true
    _avg?: DeliveryTypeAvgAggregateInputType
    _sum?: DeliveryTypeSumAggregateInputType
    _min?: DeliveryTypeMinAggregateInputType
    _max?: DeliveryTypeMaxAggregateInputType
  }

  export type DeliveryTypeGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: DeliveryTypeCountAggregateOutputType | null
    _avg: DeliveryTypeAvgAggregateOutputType | null
    _sum: DeliveryTypeSumAggregateOutputType | null
    _min: DeliveryTypeMinAggregateOutputType | null
    _max: DeliveryTypeMaxAggregateOutputType | null
  }

  type GetDeliveryTypeGroupByPayload<T extends DeliveryTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeliveryTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeliveryTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeliveryTypeGroupByOutputType[P]>
            : GetScalarType<T[P], DeliveryTypeGroupByOutputType[P]>
        }
      >
    >


  export type DeliveryTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | DeliveryType$sessionsArgs<ExtArgs>
    _count?: boolean | DeliveryTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deliveryType"]>

  export type DeliveryTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["deliveryType"]>

  export type DeliveryTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["deliveryType"]>

  export type DeliveryTypeSelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type DeliveryTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["deliveryType"]>
  export type DeliveryTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | DeliveryType$sessionsArgs<ExtArgs>
    _count?: boolean | DeliveryTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DeliveryTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type DeliveryTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $DeliveryTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeliveryType"
    objects: {
      sessions: Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["deliveryType"]>
    composites: {}
  }

  type DeliveryTypeGetPayload<S extends boolean | null | undefined | DeliveryTypeDefaultArgs> = $Result.GetResult<Prisma.$DeliveryTypePayload, S>

  type DeliveryTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeliveryTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeliveryTypeCountAggregateInputType | true
    }

  export interface DeliveryTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeliveryType'], meta: { name: 'DeliveryType' } }
    /**
     * Find zero or one DeliveryType that matches the filter.
     * @param {DeliveryTypeFindUniqueArgs} args - Arguments to find a DeliveryType
     * @example
     * // Get one DeliveryType
     * const deliveryType = await prisma.deliveryType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeliveryTypeFindUniqueArgs>(args: SelectSubset<T, DeliveryTypeFindUniqueArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeliveryType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeliveryTypeFindUniqueOrThrowArgs} args - Arguments to find a DeliveryType
     * @example
     * // Get one DeliveryType
     * const deliveryType = await prisma.deliveryType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeliveryTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, DeliveryTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeFindFirstArgs} args - Arguments to find a DeliveryType
     * @example
     * // Get one DeliveryType
     * const deliveryType = await prisma.deliveryType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeliveryTypeFindFirstArgs>(args?: SelectSubset<T, DeliveryTypeFindFirstArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeliveryType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeFindFirstOrThrowArgs} args - Arguments to find a DeliveryType
     * @example
     * // Get one DeliveryType
     * const deliveryType = await prisma.deliveryType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeliveryTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, DeliveryTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeliveryTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeliveryTypes
     * const deliveryTypes = await prisma.deliveryType.findMany()
     * 
     * // Get first 10 DeliveryTypes
     * const deliveryTypes = await prisma.deliveryType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deliveryTypeWithIdOnly = await prisma.deliveryType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeliveryTypeFindManyArgs>(args?: SelectSubset<T, DeliveryTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeliveryType.
     * @param {DeliveryTypeCreateArgs} args - Arguments to create a DeliveryType.
     * @example
     * // Create one DeliveryType
     * const DeliveryType = await prisma.deliveryType.create({
     *   data: {
     *     // ... data to create a DeliveryType
     *   }
     * })
     * 
     */
    create<T extends DeliveryTypeCreateArgs>(args: SelectSubset<T, DeliveryTypeCreateArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeliveryTypes.
     * @param {DeliveryTypeCreateManyArgs} args - Arguments to create many DeliveryTypes.
     * @example
     * // Create many DeliveryTypes
     * const deliveryType = await prisma.deliveryType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeliveryTypeCreateManyArgs>(args?: SelectSubset<T, DeliveryTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeliveryTypes and returns the data saved in the database.
     * @param {DeliveryTypeCreateManyAndReturnArgs} args - Arguments to create many DeliveryTypes.
     * @example
     * // Create many DeliveryTypes
     * const deliveryType = await prisma.deliveryType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeliveryTypes and only return the `id`
     * const deliveryTypeWithIdOnly = await prisma.deliveryType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeliveryTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, DeliveryTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeliveryType.
     * @param {DeliveryTypeDeleteArgs} args - Arguments to delete one DeliveryType.
     * @example
     * // Delete one DeliveryType
     * const DeliveryType = await prisma.deliveryType.delete({
     *   where: {
     *     // ... filter to delete one DeliveryType
     *   }
     * })
     * 
     */
    delete<T extends DeliveryTypeDeleteArgs>(args: SelectSubset<T, DeliveryTypeDeleteArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeliveryType.
     * @param {DeliveryTypeUpdateArgs} args - Arguments to update one DeliveryType.
     * @example
     * // Update one DeliveryType
     * const deliveryType = await prisma.deliveryType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeliveryTypeUpdateArgs>(args: SelectSubset<T, DeliveryTypeUpdateArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeliveryTypes.
     * @param {DeliveryTypeDeleteManyArgs} args - Arguments to filter DeliveryTypes to delete.
     * @example
     * // Delete a few DeliveryTypes
     * const { count } = await prisma.deliveryType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeliveryTypeDeleteManyArgs>(args?: SelectSubset<T, DeliveryTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeliveryTypes
     * const deliveryType = await prisma.deliveryType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeliveryTypeUpdateManyArgs>(args: SelectSubset<T, DeliveryTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeliveryTypes and returns the data updated in the database.
     * @param {DeliveryTypeUpdateManyAndReturnArgs} args - Arguments to update many DeliveryTypes.
     * @example
     * // Update many DeliveryTypes
     * const deliveryType = await prisma.deliveryType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeliveryTypes and only return the `id`
     * const deliveryTypeWithIdOnly = await prisma.deliveryType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeliveryTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, DeliveryTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeliveryType.
     * @param {DeliveryTypeUpsertArgs} args - Arguments to update or create a DeliveryType.
     * @example
     * // Update or create a DeliveryType
     * const deliveryType = await prisma.deliveryType.upsert({
     *   create: {
     *     // ... data to create a DeliveryType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeliveryType we want to update
     *   }
     * })
     */
    upsert<T extends DeliveryTypeUpsertArgs>(args: SelectSubset<T, DeliveryTypeUpsertArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeliveryTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeCountArgs} args - Arguments to filter DeliveryTypes to count.
     * @example
     * // Count the number of DeliveryTypes
     * const count = await prisma.deliveryType.count({
     *   where: {
     *     // ... the filter for the DeliveryTypes we want to count
     *   }
     * })
    **/
    count<T extends DeliveryTypeCountArgs>(
      args?: Subset<T, DeliveryTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeliveryTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeliveryType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeliveryTypeAggregateArgs>(args: Subset<T, DeliveryTypeAggregateArgs>): Prisma.PrismaPromise<GetDeliveryTypeAggregateType<T>>

    /**
     * Group by DeliveryType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeliveryTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeliveryTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeliveryTypeGroupByArgs['orderBy'] }
        : { orderBy?: DeliveryTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeliveryTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeliveryTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeliveryType model
   */
  readonly fields: DeliveryTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeliveryType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeliveryTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends DeliveryType$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryType$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeliveryType model
   */
  interface DeliveryTypeFieldRefs {
    readonly id: FieldRef<"DeliveryType", 'Int'>
    readonly logicalValue: FieldRef<"DeliveryType", 'String'>
    readonly displayValue: FieldRef<"DeliveryType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DeliveryType findUnique
   */
  export type DeliveryTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryType to fetch.
     */
    where: DeliveryTypeWhereUniqueInput
  }

  /**
   * DeliveryType findUniqueOrThrow
   */
  export type DeliveryTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryType to fetch.
     */
    where: DeliveryTypeWhereUniqueInput
  }

  /**
   * DeliveryType findFirst
   */
  export type DeliveryTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryType to fetch.
     */
    where?: DeliveryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTypes to fetch.
     */
    orderBy?: DeliveryTypeOrderByWithRelationInput | DeliveryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTypes.
     */
    cursor?: DeliveryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTypes.
     */
    distinct?: DeliveryTypeScalarFieldEnum | DeliveryTypeScalarFieldEnum[]
  }

  /**
   * DeliveryType findFirstOrThrow
   */
  export type DeliveryTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryType to fetch.
     */
    where?: DeliveryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTypes to fetch.
     */
    orderBy?: DeliveryTypeOrderByWithRelationInput | DeliveryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeliveryTypes.
     */
    cursor?: DeliveryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeliveryTypes.
     */
    distinct?: DeliveryTypeScalarFieldEnum | DeliveryTypeScalarFieldEnum[]
  }

  /**
   * DeliveryType findMany
   */
  export type DeliveryTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * Filter, which DeliveryTypes to fetch.
     */
    where?: DeliveryTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeliveryTypes to fetch.
     */
    orderBy?: DeliveryTypeOrderByWithRelationInput | DeliveryTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeliveryTypes.
     */
    cursor?: DeliveryTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeliveryTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeliveryTypes.
     */
    skip?: number
    distinct?: DeliveryTypeScalarFieldEnum | DeliveryTypeScalarFieldEnum[]
  }

  /**
   * DeliveryType create
   */
  export type DeliveryTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a DeliveryType.
     */
    data: XOR<DeliveryTypeCreateInput, DeliveryTypeUncheckedCreateInput>
  }

  /**
   * DeliveryType createMany
   */
  export type DeliveryTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeliveryTypes.
     */
    data: DeliveryTypeCreateManyInput | DeliveryTypeCreateManyInput[]
  }

  /**
   * DeliveryType createManyAndReturn
   */
  export type DeliveryTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * The data used to create many DeliveryTypes.
     */
    data: DeliveryTypeCreateManyInput | DeliveryTypeCreateManyInput[]
  }

  /**
   * DeliveryType update
   */
  export type DeliveryTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a DeliveryType.
     */
    data: XOR<DeliveryTypeUpdateInput, DeliveryTypeUncheckedUpdateInput>
    /**
     * Choose, which DeliveryType to update.
     */
    where: DeliveryTypeWhereUniqueInput
  }

  /**
   * DeliveryType updateMany
   */
  export type DeliveryTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeliveryTypes.
     */
    data: XOR<DeliveryTypeUpdateManyMutationInput, DeliveryTypeUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTypes to update
     */
    where?: DeliveryTypeWhereInput
    /**
     * Limit how many DeliveryTypes to update.
     */
    limit?: number
  }

  /**
   * DeliveryType updateManyAndReturn
   */
  export type DeliveryTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * The data used to update DeliveryTypes.
     */
    data: XOR<DeliveryTypeUpdateManyMutationInput, DeliveryTypeUncheckedUpdateManyInput>
    /**
     * Filter which DeliveryTypes to update
     */
    where?: DeliveryTypeWhereInput
    /**
     * Limit how many DeliveryTypes to update.
     */
    limit?: number
  }

  /**
   * DeliveryType upsert
   */
  export type DeliveryTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the DeliveryType to update in case it exists.
     */
    where: DeliveryTypeWhereUniqueInput
    /**
     * In case the DeliveryType found by the `where` argument doesn't exist, create a new DeliveryType with this data.
     */
    create: XOR<DeliveryTypeCreateInput, DeliveryTypeUncheckedCreateInput>
    /**
     * In case the DeliveryType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeliveryTypeUpdateInput, DeliveryTypeUncheckedUpdateInput>
  }

  /**
   * DeliveryType delete
   */
  export type DeliveryTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
    /**
     * Filter which DeliveryType to delete.
     */
    where: DeliveryTypeWhereUniqueInput
  }

  /**
   * DeliveryType deleteMany
   */
  export type DeliveryTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeliveryTypes to delete
     */
    where?: DeliveryTypeWhereInput
    /**
     * Limit how many DeliveryTypes to delete.
     */
    limit?: number
  }

  /**
   * DeliveryType.sessions
   */
  export type DeliveryType$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    where?: SessionDeliveryTypeOnSessionWhereInput
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithRelationInput | SessionDeliveryTypeOnSessionOrderByWithRelationInput[]
    cursor?: SessionDeliveryTypeOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionDeliveryTypeOnSessionScalarFieldEnum | SessionDeliveryTypeOnSessionScalarFieldEnum[]
  }

  /**
   * DeliveryType without action
   */
  export type DeliveryTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeliveryType
     */
    select?: DeliveryTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeliveryType
     */
    omit?: DeliveryTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeliveryTypeInclude<ExtArgs> | null
  }


  /**
   * Model SessionDeliveryTypeOnSession
   */

  export type AggregateSessionDeliveryTypeOnSession = {
    _count: SessionDeliveryTypeOnSessionCountAggregateOutputType | null
    _avg: SessionDeliveryTypeOnSessionAvgAggregateOutputType | null
    _sum: SessionDeliveryTypeOnSessionSumAggregateOutputType | null
    _min: SessionDeliveryTypeOnSessionMinAggregateOutputType | null
    _max: SessionDeliveryTypeOnSessionMaxAggregateOutputType | null
  }

  export type SessionDeliveryTypeOnSessionAvgAggregateOutputType = {
    sessionId: number | null
    deliveryTypeId: number | null
  }

  export type SessionDeliveryTypeOnSessionSumAggregateOutputType = {
    sessionId: number | null
    deliveryTypeId: number | null
  }

  export type SessionDeliveryTypeOnSessionMinAggregateOutputType = {
    sessionId: number | null
    deliveryTypeId: number | null
  }

  export type SessionDeliveryTypeOnSessionMaxAggregateOutputType = {
    sessionId: number | null
    deliveryTypeId: number | null
  }

  export type SessionDeliveryTypeOnSessionCountAggregateOutputType = {
    sessionId: number
    deliveryTypeId: number
    _all: number
  }


  export type SessionDeliveryTypeOnSessionAvgAggregateInputType = {
    sessionId?: true
    deliveryTypeId?: true
  }

  export type SessionDeliveryTypeOnSessionSumAggregateInputType = {
    sessionId?: true
    deliveryTypeId?: true
  }

  export type SessionDeliveryTypeOnSessionMinAggregateInputType = {
    sessionId?: true
    deliveryTypeId?: true
  }

  export type SessionDeliveryTypeOnSessionMaxAggregateInputType = {
    sessionId?: true
    deliveryTypeId?: true
  }

  export type SessionDeliveryTypeOnSessionCountAggregateInputType = {
    sessionId?: true
    deliveryTypeId?: true
    _all?: true
  }

  export type SessionDeliveryTypeOnSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionDeliveryTypeOnSession to aggregate.
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDeliveryTypeOnSessions to fetch.
     */
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithRelationInput | SessionDeliveryTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionDeliveryTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDeliveryTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDeliveryTypeOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionDeliveryTypeOnSessions
    **/
    _count?: true | SessionDeliveryTypeOnSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionDeliveryTypeOnSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionDeliveryTypeOnSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionDeliveryTypeOnSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionDeliveryTypeOnSessionMaxAggregateInputType
  }

  export type GetSessionDeliveryTypeOnSessionAggregateType<T extends SessionDeliveryTypeOnSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionDeliveryTypeOnSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionDeliveryTypeOnSession[P]>
      : GetScalarType<T[P], AggregateSessionDeliveryTypeOnSession[P]>
  }




  export type SessionDeliveryTypeOnSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionDeliveryTypeOnSessionWhereInput
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithAggregationInput | SessionDeliveryTypeOnSessionOrderByWithAggregationInput[]
    by: SessionDeliveryTypeOnSessionScalarFieldEnum[] | SessionDeliveryTypeOnSessionScalarFieldEnum
    having?: SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionDeliveryTypeOnSessionCountAggregateInputType | true
    _avg?: SessionDeliveryTypeOnSessionAvgAggregateInputType
    _sum?: SessionDeliveryTypeOnSessionSumAggregateInputType
    _min?: SessionDeliveryTypeOnSessionMinAggregateInputType
    _max?: SessionDeliveryTypeOnSessionMaxAggregateInputType
  }

  export type SessionDeliveryTypeOnSessionGroupByOutputType = {
    sessionId: number
    deliveryTypeId: number
    _count: SessionDeliveryTypeOnSessionCountAggregateOutputType | null
    _avg: SessionDeliveryTypeOnSessionAvgAggregateOutputType | null
    _sum: SessionDeliveryTypeOnSessionSumAggregateOutputType | null
    _min: SessionDeliveryTypeOnSessionMinAggregateOutputType | null
    _max: SessionDeliveryTypeOnSessionMaxAggregateOutputType | null
  }

  type GetSessionDeliveryTypeOnSessionGroupByPayload<T extends SessionDeliveryTypeOnSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionDeliveryTypeOnSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionDeliveryTypeOnSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionDeliveryTypeOnSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionDeliveryTypeOnSessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionDeliveryTypeOnSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    deliveryTypeId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    deliveryType?: boolean | DeliveryTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionDeliveryTypeOnSession"]>

  export type SessionDeliveryTypeOnSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    deliveryTypeId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    deliveryType?: boolean | DeliveryTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionDeliveryTypeOnSession"]>

  export type SessionDeliveryTypeOnSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    deliveryTypeId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    deliveryType?: boolean | DeliveryTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionDeliveryTypeOnSession"]>

  export type SessionDeliveryTypeOnSessionSelectScalar = {
    sessionId?: boolean
    deliveryTypeId?: boolean
  }

  export type SessionDeliveryTypeOnSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "deliveryTypeId", ExtArgs["result"]["sessionDeliveryTypeOnSession"]>
  export type SessionDeliveryTypeOnSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    deliveryType?: boolean | DeliveryTypeDefaultArgs<ExtArgs>
  }
  export type SessionDeliveryTypeOnSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    deliveryType?: boolean | DeliveryTypeDefaultArgs<ExtArgs>
  }
  export type SessionDeliveryTypeOnSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    deliveryType?: boolean | DeliveryTypeDefaultArgs<ExtArgs>
  }

  export type $SessionDeliveryTypeOnSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionDeliveryTypeOnSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      deliveryType: Prisma.$DeliveryTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      deliveryTypeId: number
    }, ExtArgs["result"]["sessionDeliveryTypeOnSession"]>
    composites: {}
  }

  type SessionDeliveryTypeOnSessionGetPayload<S extends boolean | null | undefined | SessionDeliveryTypeOnSessionDefaultArgs> = $Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload, S>

  type SessionDeliveryTypeOnSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionDeliveryTypeOnSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionDeliveryTypeOnSessionCountAggregateInputType | true
    }

  export interface SessionDeliveryTypeOnSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionDeliveryTypeOnSession'], meta: { name: 'SessionDeliveryTypeOnSession' } }
    /**
     * Find zero or one SessionDeliveryTypeOnSession that matches the filter.
     * @param {SessionDeliveryTypeOnSessionFindUniqueArgs} args - Arguments to find a SessionDeliveryTypeOnSession
     * @example
     * // Get one SessionDeliveryTypeOnSession
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionDeliveryTypeOnSessionFindUniqueArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionFindUniqueArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionDeliveryTypeOnSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionDeliveryTypeOnSessionFindUniqueOrThrowArgs} args - Arguments to find a SessionDeliveryTypeOnSession
     * @example
     * // Get one SessionDeliveryTypeOnSession
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionDeliveryTypeOnSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionDeliveryTypeOnSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionFindFirstArgs} args - Arguments to find a SessionDeliveryTypeOnSession
     * @example
     * // Get one SessionDeliveryTypeOnSession
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionDeliveryTypeOnSessionFindFirstArgs>(args?: SelectSubset<T, SessionDeliveryTypeOnSessionFindFirstArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionDeliveryTypeOnSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionFindFirstOrThrowArgs} args - Arguments to find a SessionDeliveryTypeOnSession
     * @example
     * // Get one SessionDeliveryTypeOnSession
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionDeliveryTypeOnSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionDeliveryTypeOnSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionDeliveryTypeOnSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionDeliveryTypeOnSessions
     * const sessionDeliveryTypeOnSessions = await prisma.sessionDeliveryTypeOnSession.findMany()
     * 
     * // Get first 10 SessionDeliveryTypeOnSessions
     * const sessionDeliveryTypeOnSessions = await prisma.sessionDeliveryTypeOnSession.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionDeliveryTypeOnSessionWithSessionIdOnly = await prisma.sessionDeliveryTypeOnSession.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionDeliveryTypeOnSessionFindManyArgs>(args?: SelectSubset<T, SessionDeliveryTypeOnSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionDeliveryTypeOnSession.
     * @param {SessionDeliveryTypeOnSessionCreateArgs} args - Arguments to create a SessionDeliveryTypeOnSession.
     * @example
     * // Create one SessionDeliveryTypeOnSession
     * const SessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.create({
     *   data: {
     *     // ... data to create a SessionDeliveryTypeOnSession
     *   }
     * })
     * 
     */
    create<T extends SessionDeliveryTypeOnSessionCreateArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionCreateArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionDeliveryTypeOnSessions.
     * @param {SessionDeliveryTypeOnSessionCreateManyArgs} args - Arguments to create many SessionDeliveryTypeOnSessions.
     * @example
     * // Create many SessionDeliveryTypeOnSessions
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionDeliveryTypeOnSessionCreateManyArgs>(args?: SelectSubset<T, SessionDeliveryTypeOnSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionDeliveryTypeOnSessions and returns the data saved in the database.
     * @param {SessionDeliveryTypeOnSessionCreateManyAndReturnArgs} args - Arguments to create many SessionDeliveryTypeOnSessions.
     * @example
     * // Create many SessionDeliveryTypeOnSessions
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionDeliveryTypeOnSessions and only return the `sessionId`
     * const sessionDeliveryTypeOnSessionWithSessionIdOnly = await prisma.sessionDeliveryTypeOnSession.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionDeliveryTypeOnSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionDeliveryTypeOnSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionDeliveryTypeOnSession.
     * @param {SessionDeliveryTypeOnSessionDeleteArgs} args - Arguments to delete one SessionDeliveryTypeOnSession.
     * @example
     * // Delete one SessionDeliveryTypeOnSession
     * const SessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.delete({
     *   where: {
     *     // ... filter to delete one SessionDeliveryTypeOnSession
     *   }
     * })
     * 
     */
    delete<T extends SessionDeliveryTypeOnSessionDeleteArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionDeleteArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionDeliveryTypeOnSession.
     * @param {SessionDeliveryTypeOnSessionUpdateArgs} args - Arguments to update one SessionDeliveryTypeOnSession.
     * @example
     * // Update one SessionDeliveryTypeOnSession
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionDeliveryTypeOnSessionUpdateArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionUpdateArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionDeliveryTypeOnSessions.
     * @param {SessionDeliveryTypeOnSessionDeleteManyArgs} args - Arguments to filter SessionDeliveryTypeOnSessions to delete.
     * @example
     * // Delete a few SessionDeliveryTypeOnSessions
     * const { count } = await prisma.sessionDeliveryTypeOnSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeliveryTypeOnSessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeliveryTypeOnSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionDeliveryTypeOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionDeliveryTypeOnSessions
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionDeliveryTypeOnSessionUpdateManyArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionDeliveryTypeOnSessions and returns the data updated in the database.
     * @param {SessionDeliveryTypeOnSessionUpdateManyAndReturnArgs} args - Arguments to update many SessionDeliveryTypeOnSessions.
     * @example
     * // Update many SessionDeliveryTypeOnSessions
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionDeliveryTypeOnSessions and only return the `sessionId`
     * const sessionDeliveryTypeOnSessionWithSessionIdOnly = await prisma.sessionDeliveryTypeOnSession.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionDeliveryTypeOnSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionDeliveryTypeOnSession.
     * @param {SessionDeliveryTypeOnSessionUpsertArgs} args - Arguments to update or create a SessionDeliveryTypeOnSession.
     * @example
     * // Update or create a SessionDeliveryTypeOnSession
     * const sessionDeliveryTypeOnSession = await prisma.sessionDeliveryTypeOnSession.upsert({
     *   create: {
     *     // ... data to create a SessionDeliveryTypeOnSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionDeliveryTypeOnSession we want to update
     *   }
     * })
     */
    upsert<T extends SessionDeliveryTypeOnSessionUpsertArgs>(args: SelectSubset<T, SessionDeliveryTypeOnSessionUpsertArgs<ExtArgs>>): Prisma__SessionDeliveryTypeOnSessionClient<$Result.GetResult<Prisma.$SessionDeliveryTypeOnSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionDeliveryTypeOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionCountArgs} args - Arguments to filter SessionDeliveryTypeOnSessions to count.
     * @example
     * // Count the number of SessionDeliveryTypeOnSessions
     * const count = await prisma.sessionDeliveryTypeOnSession.count({
     *   where: {
     *     // ... the filter for the SessionDeliveryTypeOnSessions we want to count
     *   }
     * })
    **/
    count<T extends SessionDeliveryTypeOnSessionCountArgs>(
      args?: Subset<T, SessionDeliveryTypeOnSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionDeliveryTypeOnSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionDeliveryTypeOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionDeliveryTypeOnSessionAggregateArgs>(args: Subset<T, SessionDeliveryTypeOnSessionAggregateArgs>): Prisma.PrismaPromise<GetSessionDeliveryTypeOnSessionAggregateType<T>>

    /**
     * Group by SessionDeliveryTypeOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionDeliveryTypeOnSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionDeliveryTypeOnSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionDeliveryTypeOnSessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionDeliveryTypeOnSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionDeliveryTypeOnSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionDeliveryTypeOnSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionDeliveryTypeOnSession model
   */
  readonly fields: SessionDeliveryTypeOnSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionDeliveryTypeOnSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionDeliveryTypeOnSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deliveryType<T extends DeliveryTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DeliveryTypeDefaultArgs<ExtArgs>>): Prisma__DeliveryTypeClient<$Result.GetResult<Prisma.$DeliveryTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionDeliveryTypeOnSession model
   */
  interface SessionDeliveryTypeOnSessionFieldRefs {
    readonly sessionId: FieldRef<"SessionDeliveryTypeOnSession", 'Int'>
    readonly deliveryTypeId: FieldRef<"SessionDeliveryTypeOnSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionDeliveryTypeOnSession findUnique
   */
  export type SessionDeliveryTypeOnSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDeliveryTypeOnSession to fetch.
     */
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionDeliveryTypeOnSession findUniqueOrThrow
   */
  export type SessionDeliveryTypeOnSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDeliveryTypeOnSession to fetch.
     */
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionDeliveryTypeOnSession findFirst
   */
  export type SessionDeliveryTypeOnSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDeliveryTypeOnSession to fetch.
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDeliveryTypeOnSessions to fetch.
     */
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithRelationInput | SessionDeliveryTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionDeliveryTypeOnSessions.
     */
    cursor?: SessionDeliveryTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDeliveryTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDeliveryTypeOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionDeliveryTypeOnSessions.
     */
    distinct?: SessionDeliveryTypeOnSessionScalarFieldEnum | SessionDeliveryTypeOnSessionScalarFieldEnum[]
  }

  /**
   * SessionDeliveryTypeOnSession findFirstOrThrow
   */
  export type SessionDeliveryTypeOnSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDeliveryTypeOnSession to fetch.
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDeliveryTypeOnSessions to fetch.
     */
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithRelationInput | SessionDeliveryTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionDeliveryTypeOnSessions.
     */
    cursor?: SessionDeliveryTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDeliveryTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDeliveryTypeOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionDeliveryTypeOnSessions.
     */
    distinct?: SessionDeliveryTypeOnSessionScalarFieldEnum | SessionDeliveryTypeOnSessionScalarFieldEnum[]
  }

  /**
   * SessionDeliveryTypeOnSession findMany
   */
  export type SessionDeliveryTypeOnSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionDeliveryTypeOnSessions to fetch.
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionDeliveryTypeOnSessions to fetch.
     */
    orderBy?: SessionDeliveryTypeOnSessionOrderByWithRelationInput | SessionDeliveryTypeOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionDeliveryTypeOnSessions.
     */
    cursor?: SessionDeliveryTypeOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionDeliveryTypeOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionDeliveryTypeOnSessions.
     */
    skip?: number
    distinct?: SessionDeliveryTypeOnSessionScalarFieldEnum | SessionDeliveryTypeOnSessionScalarFieldEnum[]
  }

  /**
   * SessionDeliveryTypeOnSession create
   */
  export type SessionDeliveryTypeOnSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionDeliveryTypeOnSession.
     */
    data: XOR<SessionDeliveryTypeOnSessionCreateInput, SessionDeliveryTypeOnSessionUncheckedCreateInput>
  }

  /**
   * SessionDeliveryTypeOnSession createMany
   */
  export type SessionDeliveryTypeOnSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionDeliveryTypeOnSessions.
     */
    data: SessionDeliveryTypeOnSessionCreateManyInput | SessionDeliveryTypeOnSessionCreateManyInput[]
  }

  /**
   * SessionDeliveryTypeOnSession createManyAndReturn
   */
  export type SessionDeliveryTypeOnSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SessionDeliveryTypeOnSessions.
     */
    data: SessionDeliveryTypeOnSessionCreateManyInput | SessionDeliveryTypeOnSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionDeliveryTypeOnSession update
   */
  export type SessionDeliveryTypeOnSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionDeliveryTypeOnSession.
     */
    data: XOR<SessionDeliveryTypeOnSessionUpdateInput, SessionDeliveryTypeOnSessionUncheckedUpdateInput>
    /**
     * Choose, which SessionDeliveryTypeOnSession to update.
     */
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionDeliveryTypeOnSession updateMany
   */
  export type SessionDeliveryTypeOnSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionDeliveryTypeOnSessions.
     */
    data: XOR<SessionDeliveryTypeOnSessionUpdateManyMutationInput, SessionDeliveryTypeOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionDeliveryTypeOnSessions to update
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * Limit how many SessionDeliveryTypeOnSessions to update.
     */
    limit?: number
  }

  /**
   * SessionDeliveryTypeOnSession updateManyAndReturn
   */
  export type SessionDeliveryTypeOnSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * The data used to update SessionDeliveryTypeOnSessions.
     */
    data: XOR<SessionDeliveryTypeOnSessionUpdateManyMutationInput, SessionDeliveryTypeOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionDeliveryTypeOnSessions to update
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * Limit how many SessionDeliveryTypeOnSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionDeliveryTypeOnSession upsert
   */
  export type SessionDeliveryTypeOnSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionDeliveryTypeOnSession to update in case it exists.
     */
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    /**
     * In case the SessionDeliveryTypeOnSession found by the `where` argument doesn't exist, create a new SessionDeliveryTypeOnSession with this data.
     */
    create: XOR<SessionDeliveryTypeOnSessionCreateInput, SessionDeliveryTypeOnSessionUncheckedCreateInput>
    /**
     * In case the SessionDeliveryTypeOnSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionDeliveryTypeOnSessionUpdateInput, SessionDeliveryTypeOnSessionUncheckedUpdateInput>
  }

  /**
   * SessionDeliveryTypeOnSession delete
   */
  export type SessionDeliveryTypeOnSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
    /**
     * Filter which SessionDeliveryTypeOnSession to delete.
     */
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
  }

  /**
   * SessionDeliveryTypeOnSession deleteMany
   */
  export type SessionDeliveryTypeOnSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionDeliveryTypeOnSessions to delete
     */
    where?: SessionDeliveryTypeOnSessionWhereInput
    /**
     * Limit how many SessionDeliveryTypeOnSessions to delete.
     */
    limit?: number
  }

  /**
   * SessionDeliveryTypeOnSession without action
   */
  export type SessionDeliveryTypeOnSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionDeliveryTypeOnSession
     */
    select?: SessionDeliveryTypeOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionDeliveryTypeOnSession
     */
    omit?: SessionDeliveryTypeOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionDeliveryTypeOnSessionInclude<ExtArgs> | null
  }


  /**
   * Model ViewingOption
   */

  export type AggregateViewingOption = {
    _count: ViewingOptionCountAggregateOutputType | null
    _avg: ViewingOptionAvgAggregateOutputType | null
    _sum: ViewingOptionSumAggregateOutputType | null
    _min: ViewingOptionMinAggregateOutputType | null
    _max: ViewingOptionMaxAggregateOutputType | null
  }

  export type ViewingOptionAvgAggregateOutputType = {
    id: number | null
  }

  export type ViewingOptionSumAggregateOutputType = {
    id: number | null
  }

  export type ViewingOptionMinAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type ViewingOptionMaxAggregateOutputType = {
    id: number | null
    logicalValue: string | null
    displayValue: string | null
  }

  export type ViewingOptionCountAggregateOutputType = {
    id: number
    logicalValue: number
    displayValue: number
    _all: number
  }


  export type ViewingOptionAvgAggregateInputType = {
    id?: true
  }

  export type ViewingOptionSumAggregateInputType = {
    id?: true
  }

  export type ViewingOptionMinAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type ViewingOptionMaxAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
  }

  export type ViewingOptionCountAggregateInputType = {
    id?: true
    logicalValue?: true
    displayValue?: true
    _all?: true
  }

  export type ViewingOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewingOption to aggregate.
     */
    where?: ViewingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingOptions to fetch.
     */
    orderBy?: ViewingOptionOrderByWithRelationInput | ViewingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViewingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViewingOptions
    **/
    _count?: true | ViewingOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ViewingOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ViewingOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViewingOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViewingOptionMaxAggregateInputType
  }

  export type GetViewingOptionAggregateType<T extends ViewingOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateViewingOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViewingOption[P]>
      : GetScalarType<T[P], AggregateViewingOption[P]>
  }




  export type ViewingOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViewingOptionWhereInput
    orderBy?: ViewingOptionOrderByWithAggregationInput | ViewingOptionOrderByWithAggregationInput[]
    by: ViewingOptionScalarFieldEnum[] | ViewingOptionScalarFieldEnum
    having?: ViewingOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViewingOptionCountAggregateInputType | true
    _avg?: ViewingOptionAvgAggregateInputType
    _sum?: ViewingOptionSumAggregateInputType
    _min?: ViewingOptionMinAggregateInputType
    _max?: ViewingOptionMaxAggregateInputType
  }

  export type ViewingOptionGroupByOutputType = {
    id: number
    logicalValue: string
    displayValue: string
    _count: ViewingOptionCountAggregateOutputType | null
    _avg: ViewingOptionAvgAggregateOutputType | null
    _sum: ViewingOptionSumAggregateOutputType | null
    _min: ViewingOptionMinAggregateOutputType | null
    _max: ViewingOptionMaxAggregateOutputType | null
  }

  type GetViewingOptionGroupByPayload<T extends ViewingOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViewingOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViewingOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViewingOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ViewingOptionGroupByOutputType[P]>
        }
      >
    >


  export type ViewingOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
    sessions?: boolean | ViewingOption$sessionsArgs<ExtArgs>
    _count?: boolean | ViewingOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["viewingOption"]>

  export type ViewingOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["viewingOption"]>

  export type ViewingOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }, ExtArgs["result"]["viewingOption"]>

  export type ViewingOptionSelectScalar = {
    id?: boolean
    logicalValue?: boolean
    displayValue?: boolean
  }

  export type ViewingOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "logicalValue" | "displayValue", ExtArgs["result"]["viewingOption"]>
  export type ViewingOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | ViewingOption$sessionsArgs<ExtArgs>
    _count?: boolean | ViewingOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ViewingOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ViewingOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ViewingOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViewingOption"
    objects: {
      sessions: Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      logicalValue: string
      displayValue: string
    }, ExtArgs["result"]["viewingOption"]>
    composites: {}
  }

  type ViewingOptionGetPayload<S extends boolean | null | undefined | ViewingOptionDefaultArgs> = $Result.GetResult<Prisma.$ViewingOptionPayload, S>

  type ViewingOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ViewingOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ViewingOptionCountAggregateInputType | true
    }

  export interface ViewingOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViewingOption'], meta: { name: 'ViewingOption' } }
    /**
     * Find zero or one ViewingOption that matches the filter.
     * @param {ViewingOptionFindUniqueArgs} args - Arguments to find a ViewingOption
     * @example
     * // Get one ViewingOption
     * const viewingOption = await prisma.viewingOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ViewingOptionFindUniqueArgs>(args: SelectSubset<T, ViewingOptionFindUniqueArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ViewingOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ViewingOptionFindUniqueOrThrowArgs} args - Arguments to find a ViewingOption
     * @example
     * // Get one ViewingOption
     * const viewingOption = await prisma.viewingOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ViewingOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ViewingOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewingOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionFindFirstArgs} args - Arguments to find a ViewingOption
     * @example
     * // Get one ViewingOption
     * const viewingOption = await prisma.viewingOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ViewingOptionFindFirstArgs>(args?: SelectSubset<T, ViewingOptionFindFirstArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ViewingOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionFindFirstOrThrowArgs} args - Arguments to find a ViewingOption
     * @example
     * // Get one ViewingOption
     * const viewingOption = await prisma.viewingOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ViewingOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ViewingOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ViewingOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViewingOptions
     * const viewingOptions = await prisma.viewingOption.findMany()
     * 
     * // Get first 10 ViewingOptions
     * const viewingOptions = await prisma.viewingOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const viewingOptionWithIdOnly = await prisma.viewingOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ViewingOptionFindManyArgs>(args?: SelectSubset<T, ViewingOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ViewingOption.
     * @param {ViewingOptionCreateArgs} args - Arguments to create a ViewingOption.
     * @example
     * // Create one ViewingOption
     * const ViewingOption = await prisma.viewingOption.create({
     *   data: {
     *     // ... data to create a ViewingOption
     *   }
     * })
     * 
     */
    create<T extends ViewingOptionCreateArgs>(args: SelectSubset<T, ViewingOptionCreateArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ViewingOptions.
     * @param {ViewingOptionCreateManyArgs} args - Arguments to create many ViewingOptions.
     * @example
     * // Create many ViewingOptions
     * const viewingOption = await prisma.viewingOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ViewingOptionCreateManyArgs>(args?: SelectSubset<T, ViewingOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ViewingOptions and returns the data saved in the database.
     * @param {ViewingOptionCreateManyAndReturnArgs} args - Arguments to create many ViewingOptions.
     * @example
     * // Create many ViewingOptions
     * const viewingOption = await prisma.viewingOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ViewingOptions and only return the `id`
     * const viewingOptionWithIdOnly = await prisma.viewingOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ViewingOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ViewingOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ViewingOption.
     * @param {ViewingOptionDeleteArgs} args - Arguments to delete one ViewingOption.
     * @example
     * // Delete one ViewingOption
     * const ViewingOption = await prisma.viewingOption.delete({
     *   where: {
     *     // ... filter to delete one ViewingOption
     *   }
     * })
     * 
     */
    delete<T extends ViewingOptionDeleteArgs>(args: SelectSubset<T, ViewingOptionDeleteArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ViewingOption.
     * @param {ViewingOptionUpdateArgs} args - Arguments to update one ViewingOption.
     * @example
     * // Update one ViewingOption
     * const viewingOption = await prisma.viewingOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ViewingOptionUpdateArgs>(args: SelectSubset<T, ViewingOptionUpdateArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ViewingOptions.
     * @param {ViewingOptionDeleteManyArgs} args - Arguments to filter ViewingOptions to delete.
     * @example
     * // Delete a few ViewingOptions
     * const { count } = await prisma.viewingOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ViewingOptionDeleteManyArgs>(args?: SelectSubset<T, ViewingOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewingOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViewingOptions
     * const viewingOption = await prisma.viewingOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ViewingOptionUpdateManyArgs>(args: SelectSubset<T, ViewingOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViewingOptions and returns the data updated in the database.
     * @param {ViewingOptionUpdateManyAndReturnArgs} args - Arguments to update many ViewingOptions.
     * @example
     * // Update many ViewingOptions
     * const viewingOption = await prisma.viewingOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ViewingOptions and only return the `id`
     * const viewingOptionWithIdOnly = await prisma.viewingOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ViewingOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ViewingOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ViewingOption.
     * @param {ViewingOptionUpsertArgs} args - Arguments to update or create a ViewingOption.
     * @example
     * // Update or create a ViewingOption
     * const viewingOption = await prisma.viewingOption.upsert({
     *   create: {
     *     // ... data to create a ViewingOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViewingOption we want to update
     *   }
     * })
     */
    upsert<T extends ViewingOptionUpsertArgs>(args: SelectSubset<T, ViewingOptionUpsertArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ViewingOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionCountArgs} args - Arguments to filter ViewingOptions to count.
     * @example
     * // Count the number of ViewingOptions
     * const count = await prisma.viewingOption.count({
     *   where: {
     *     // ... the filter for the ViewingOptions we want to count
     *   }
     * })
    **/
    count<T extends ViewingOptionCountArgs>(
      args?: Subset<T, ViewingOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViewingOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViewingOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViewingOptionAggregateArgs>(args: Subset<T, ViewingOptionAggregateArgs>): Prisma.PrismaPromise<GetViewingOptionAggregateType<T>>

    /**
     * Group by ViewingOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViewingOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViewingOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViewingOptionGroupByArgs['orderBy'] }
        : { orderBy?: ViewingOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViewingOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViewingOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViewingOption model
   */
  readonly fields: ViewingOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViewingOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViewingOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends ViewingOption$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, ViewingOption$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ViewingOption model
   */
  interface ViewingOptionFieldRefs {
    readonly id: FieldRef<"ViewingOption", 'Int'>
    readonly logicalValue: FieldRef<"ViewingOption", 'String'>
    readonly displayValue: FieldRef<"ViewingOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViewingOption findUnique
   */
  export type ViewingOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * Filter, which ViewingOption to fetch.
     */
    where: ViewingOptionWhereUniqueInput
  }

  /**
   * ViewingOption findUniqueOrThrow
   */
  export type ViewingOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * Filter, which ViewingOption to fetch.
     */
    where: ViewingOptionWhereUniqueInput
  }

  /**
   * ViewingOption findFirst
   */
  export type ViewingOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * Filter, which ViewingOption to fetch.
     */
    where?: ViewingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingOptions to fetch.
     */
    orderBy?: ViewingOptionOrderByWithRelationInput | ViewingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewingOptions.
     */
    cursor?: ViewingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewingOptions.
     */
    distinct?: ViewingOptionScalarFieldEnum | ViewingOptionScalarFieldEnum[]
  }

  /**
   * ViewingOption findFirstOrThrow
   */
  export type ViewingOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * Filter, which ViewingOption to fetch.
     */
    where?: ViewingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingOptions to fetch.
     */
    orderBy?: ViewingOptionOrderByWithRelationInput | ViewingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViewingOptions.
     */
    cursor?: ViewingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViewingOptions.
     */
    distinct?: ViewingOptionScalarFieldEnum | ViewingOptionScalarFieldEnum[]
  }

  /**
   * ViewingOption findMany
   */
  export type ViewingOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * Filter, which ViewingOptions to fetch.
     */
    where?: ViewingOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViewingOptions to fetch.
     */
    orderBy?: ViewingOptionOrderByWithRelationInput | ViewingOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViewingOptions.
     */
    cursor?: ViewingOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViewingOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViewingOptions.
     */
    skip?: number
    distinct?: ViewingOptionScalarFieldEnum | ViewingOptionScalarFieldEnum[]
  }

  /**
   * ViewingOption create
   */
  export type ViewingOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ViewingOption.
     */
    data: XOR<ViewingOptionCreateInput, ViewingOptionUncheckedCreateInput>
  }

  /**
   * ViewingOption createMany
   */
  export type ViewingOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViewingOptions.
     */
    data: ViewingOptionCreateManyInput | ViewingOptionCreateManyInput[]
  }

  /**
   * ViewingOption createManyAndReturn
   */
  export type ViewingOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ViewingOptions.
     */
    data: ViewingOptionCreateManyInput | ViewingOptionCreateManyInput[]
  }

  /**
   * ViewingOption update
   */
  export type ViewingOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ViewingOption.
     */
    data: XOR<ViewingOptionUpdateInput, ViewingOptionUncheckedUpdateInput>
    /**
     * Choose, which ViewingOption to update.
     */
    where: ViewingOptionWhereUniqueInput
  }

  /**
   * ViewingOption updateMany
   */
  export type ViewingOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViewingOptions.
     */
    data: XOR<ViewingOptionUpdateManyMutationInput, ViewingOptionUncheckedUpdateManyInput>
    /**
     * Filter which ViewingOptions to update
     */
    where?: ViewingOptionWhereInput
    /**
     * Limit how many ViewingOptions to update.
     */
    limit?: number
  }

  /**
   * ViewingOption updateManyAndReturn
   */
  export type ViewingOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * The data used to update ViewingOptions.
     */
    data: XOR<ViewingOptionUpdateManyMutationInput, ViewingOptionUncheckedUpdateManyInput>
    /**
     * Filter which ViewingOptions to update
     */
    where?: ViewingOptionWhereInput
    /**
     * Limit how many ViewingOptions to update.
     */
    limit?: number
  }

  /**
   * ViewingOption upsert
   */
  export type ViewingOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ViewingOption to update in case it exists.
     */
    where: ViewingOptionWhereUniqueInput
    /**
     * In case the ViewingOption found by the `where` argument doesn't exist, create a new ViewingOption with this data.
     */
    create: XOR<ViewingOptionCreateInput, ViewingOptionUncheckedCreateInput>
    /**
     * In case the ViewingOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViewingOptionUpdateInput, ViewingOptionUncheckedUpdateInput>
  }

  /**
   * ViewingOption delete
   */
  export type ViewingOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
    /**
     * Filter which ViewingOption to delete.
     */
    where: ViewingOptionWhereUniqueInput
  }

  /**
   * ViewingOption deleteMany
   */
  export type ViewingOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViewingOptions to delete
     */
    where?: ViewingOptionWhereInput
    /**
     * Limit how many ViewingOptions to delete.
     */
    limit?: number
  }

  /**
   * ViewingOption.sessions
   */
  export type ViewingOption$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    where?: SessionViewingOptionOnSessionWhereInput
    orderBy?: SessionViewingOptionOnSessionOrderByWithRelationInput | SessionViewingOptionOnSessionOrderByWithRelationInput[]
    cursor?: SessionViewingOptionOnSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionViewingOptionOnSessionScalarFieldEnum | SessionViewingOptionOnSessionScalarFieldEnum[]
  }

  /**
   * ViewingOption without action
   */
  export type ViewingOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViewingOption
     */
    select?: ViewingOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ViewingOption
     */
    omit?: ViewingOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ViewingOptionInclude<ExtArgs> | null
  }


  /**
   * Model SessionViewingOptionOnSession
   */

  export type AggregateSessionViewingOptionOnSession = {
    _count: SessionViewingOptionOnSessionCountAggregateOutputType | null
    _avg: SessionViewingOptionOnSessionAvgAggregateOutputType | null
    _sum: SessionViewingOptionOnSessionSumAggregateOutputType | null
    _min: SessionViewingOptionOnSessionMinAggregateOutputType | null
    _max: SessionViewingOptionOnSessionMaxAggregateOutputType | null
  }

  export type SessionViewingOptionOnSessionAvgAggregateOutputType = {
    sessionId: number | null
    viewingOptionId: number | null
  }

  export type SessionViewingOptionOnSessionSumAggregateOutputType = {
    sessionId: number | null
    viewingOptionId: number | null
  }

  export type SessionViewingOptionOnSessionMinAggregateOutputType = {
    sessionId: number | null
    viewingOptionId: number | null
  }

  export type SessionViewingOptionOnSessionMaxAggregateOutputType = {
    sessionId: number | null
    viewingOptionId: number | null
  }

  export type SessionViewingOptionOnSessionCountAggregateOutputType = {
    sessionId: number
    viewingOptionId: number
    _all: number
  }


  export type SessionViewingOptionOnSessionAvgAggregateInputType = {
    sessionId?: true
    viewingOptionId?: true
  }

  export type SessionViewingOptionOnSessionSumAggregateInputType = {
    sessionId?: true
    viewingOptionId?: true
  }

  export type SessionViewingOptionOnSessionMinAggregateInputType = {
    sessionId?: true
    viewingOptionId?: true
  }

  export type SessionViewingOptionOnSessionMaxAggregateInputType = {
    sessionId?: true
    viewingOptionId?: true
  }

  export type SessionViewingOptionOnSessionCountAggregateInputType = {
    sessionId?: true
    viewingOptionId?: true
    _all?: true
  }

  export type SessionViewingOptionOnSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionViewingOptionOnSession to aggregate.
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionViewingOptionOnSessions to fetch.
     */
    orderBy?: SessionViewingOptionOnSessionOrderByWithRelationInput | SessionViewingOptionOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionViewingOptionOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionViewingOptionOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionViewingOptionOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionViewingOptionOnSessions
    **/
    _count?: true | SessionViewingOptionOnSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionViewingOptionOnSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionViewingOptionOnSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionViewingOptionOnSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionViewingOptionOnSessionMaxAggregateInputType
  }

  export type GetSessionViewingOptionOnSessionAggregateType<T extends SessionViewingOptionOnSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionViewingOptionOnSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionViewingOptionOnSession[P]>
      : GetScalarType<T[P], AggregateSessionViewingOptionOnSession[P]>
  }




  export type SessionViewingOptionOnSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionViewingOptionOnSessionWhereInput
    orderBy?: SessionViewingOptionOnSessionOrderByWithAggregationInput | SessionViewingOptionOnSessionOrderByWithAggregationInput[]
    by: SessionViewingOptionOnSessionScalarFieldEnum[] | SessionViewingOptionOnSessionScalarFieldEnum
    having?: SessionViewingOptionOnSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionViewingOptionOnSessionCountAggregateInputType | true
    _avg?: SessionViewingOptionOnSessionAvgAggregateInputType
    _sum?: SessionViewingOptionOnSessionSumAggregateInputType
    _min?: SessionViewingOptionOnSessionMinAggregateInputType
    _max?: SessionViewingOptionOnSessionMaxAggregateInputType
  }

  export type SessionViewingOptionOnSessionGroupByOutputType = {
    sessionId: number
    viewingOptionId: number
    _count: SessionViewingOptionOnSessionCountAggregateOutputType | null
    _avg: SessionViewingOptionOnSessionAvgAggregateOutputType | null
    _sum: SessionViewingOptionOnSessionSumAggregateOutputType | null
    _min: SessionViewingOptionOnSessionMinAggregateOutputType | null
    _max: SessionViewingOptionOnSessionMaxAggregateOutputType | null
  }

  type GetSessionViewingOptionOnSessionGroupByPayload<T extends SessionViewingOptionOnSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionViewingOptionOnSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionViewingOptionOnSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionViewingOptionOnSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionViewingOptionOnSessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionViewingOptionOnSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    viewingOptionId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    viewingOption?: boolean | ViewingOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionViewingOptionOnSession"]>

  export type SessionViewingOptionOnSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    viewingOptionId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    viewingOption?: boolean | ViewingOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionViewingOptionOnSession"]>

  export type SessionViewingOptionOnSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    viewingOptionId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    viewingOption?: boolean | ViewingOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionViewingOptionOnSession"]>

  export type SessionViewingOptionOnSessionSelectScalar = {
    sessionId?: boolean
    viewingOptionId?: boolean
  }

  export type SessionViewingOptionOnSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "viewingOptionId", ExtArgs["result"]["sessionViewingOptionOnSession"]>
  export type SessionViewingOptionOnSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    viewingOption?: boolean | ViewingOptionDefaultArgs<ExtArgs>
  }
  export type SessionViewingOptionOnSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    viewingOption?: boolean | ViewingOptionDefaultArgs<ExtArgs>
  }
  export type SessionViewingOptionOnSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    viewingOption?: boolean | ViewingOptionDefaultArgs<ExtArgs>
  }

  export type $SessionViewingOptionOnSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionViewingOptionOnSession"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      viewingOption: Prisma.$ViewingOptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      viewingOptionId: number
    }, ExtArgs["result"]["sessionViewingOptionOnSession"]>
    composites: {}
  }

  type SessionViewingOptionOnSessionGetPayload<S extends boolean | null | undefined | SessionViewingOptionOnSessionDefaultArgs> = $Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload, S>

  type SessionViewingOptionOnSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionViewingOptionOnSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionViewingOptionOnSessionCountAggregateInputType | true
    }

  export interface SessionViewingOptionOnSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionViewingOptionOnSession'], meta: { name: 'SessionViewingOptionOnSession' } }
    /**
     * Find zero or one SessionViewingOptionOnSession that matches the filter.
     * @param {SessionViewingOptionOnSessionFindUniqueArgs} args - Arguments to find a SessionViewingOptionOnSession
     * @example
     * // Get one SessionViewingOptionOnSession
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionViewingOptionOnSessionFindUniqueArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionFindUniqueArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionViewingOptionOnSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionViewingOptionOnSessionFindUniqueOrThrowArgs} args - Arguments to find a SessionViewingOptionOnSession
     * @example
     * // Get one SessionViewingOptionOnSession
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionViewingOptionOnSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionViewingOptionOnSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionFindFirstArgs} args - Arguments to find a SessionViewingOptionOnSession
     * @example
     * // Get one SessionViewingOptionOnSession
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionViewingOptionOnSessionFindFirstArgs>(args?: SelectSubset<T, SessionViewingOptionOnSessionFindFirstArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionViewingOptionOnSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionFindFirstOrThrowArgs} args - Arguments to find a SessionViewingOptionOnSession
     * @example
     * // Get one SessionViewingOptionOnSession
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionViewingOptionOnSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionViewingOptionOnSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionViewingOptionOnSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionViewingOptionOnSessions
     * const sessionViewingOptionOnSessions = await prisma.sessionViewingOptionOnSession.findMany()
     * 
     * // Get first 10 SessionViewingOptionOnSessions
     * const sessionViewingOptionOnSessions = await prisma.sessionViewingOptionOnSession.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionViewingOptionOnSessionWithSessionIdOnly = await prisma.sessionViewingOptionOnSession.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionViewingOptionOnSessionFindManyArgs>(args?: SelectSubset<T, SessionViewingOptionOnSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionViewingOptionOnSession.
     * @param {SessionViewingOptionOnSessionCreateArgs} args - Arguments to create a SessionViewingOptionOnSession.
     * @example
     * // Create one SessionViewingOptionOnSession
     * const SessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.create({
     *   data: {
     *     // ... data to create a SessionViewingOptionOnSession
     *   }
     * })
     * 
     */
    create<T extends SessionViewingOptionOnSessionCreateArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionCreateArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionViewingOptionOnSessions.
     * @param {SessionViewingOptionOnSessionCreateManyArgs} args - Arguments to create many SessionViewingOptionOnSessions.
     * @example
     * // Create many SessionViewingOptionOnSessions
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionViewingOptionOnSessionCreateManyArgs>(args?: SelectSubset<T, SessionViewingOptionOnSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionViewingOptionOnSessions and returns the data saved in the database.
     * @param {SessionViewingOptionOnSessionCreateManyAndReturnArgs} args - Arguments to create many SessionViewingOptionOnSessions.
     * @example
     * // Create many SessionViewingOptionOnSessions
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionViewingOptionOnSessions and only return the `sessionId`
     * const sessionViewingOptionOnSessionWithSessionIdOnly = await prisma.sessionViewingOptionOnSession.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionViewingOptionOnSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionViewingOptionOnSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionViewingOptionOnSession.
     * @param {SessionViewingOptionOnSessionDeleteArgs} args - Arguments to delete one SessionViewingOptionOnSession.
     * @example
     * // Delete one SessionViewingOptionOnSession
     * const SessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.delete({
     *   where: {
     *     // ... filter to delete one SessionViewingOptionOnSession
     *   }
     * })
     * 
     */
    delete<T extends SessionViewingOptionOnSessionDeleteArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionDeleteArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionViewingOptionOnSession.
     * @param {SessionViewingOptionOnSessionUpdateArgs} args - Arguments to update one SessionViewingOptionOnSession.
     * @example
     * // Update one SessionViewingOptionOnSession
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionViewingOptionOnSessionUpdateArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionUpdateArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionViewingOptionOnSessions.
     * @param {SessionViewingOptionOnSessionDeleteManyArgs} args - Arguments to filter SessionViewingOptionOnSessions to delete.
     * @example
     * // Delete a few SessionViewingOptionOnSessions
     * const { count } = await prisma.sessionViewingOptionOnSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionViewingOptionOnSessionDeleteManyArgs>(args?: SelectSubset<T, SessionViewingOptionOnSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionViewingOptionOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionViewingOptionOnSessions
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionViewingOptionOnSessionUpdateManyArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionViewingOptionOnSessions and returns the data updated in the database.
     * @param {SessionViewingOptionOnSessionUpdateManyAndReturnArgs} args - Arguments to update many SessionViewingOptionOnSessions.
     * @example
     * // Update many SessionViewingOptionOnSessions
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionViewingOptionOnSessions and only return the `sessionId`
     * const sessionViewingOptionOnSessionWithSessionIdOnly = await prisma.sessionViewingOptionOnSession.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionViewingOptionOnSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionViewingOptionOnSession.
     * @param {SessionViewingOptionOnSessionUpsertArgs} args - Arguments to update or create a SessionViewingOptionOnSession.
     * @example
     * // Update or create a SessionViewingOptionOnSession
     * const sessionViewingOptionOnSession = await prisma.sessionViewingOptionOnSession.upsert({
     *   create: {
     *     // ... data to create a SessionViewingOptionOnSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionViewingOptionOnSession we want to update
     *   }
     * })
     */
    upsert<T extends SessionViewingOptionOnSessionUpsertArgs>(args: SelectSubset<T, SessionViewingOptionOnSessionUpsertArgs<ExtArgs>>): Prisma__SessionViewingOptionOnSessionClient<$Result.GetResult<Prisma.$SessionViewingOptionOnSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionViewingOptionOnSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionCountArgs} args - Arguments to filter SessionViewingOptionOnSessions to count.
     * @example
     * // Count the number of SessionViewingOptionOnSessions
     * const count = await prisma.sessionViewingOptionOnSession.count({
     *   where: {
     *     // ... the filter for the SessionViewingOptionOnSessions we want to count
     *   }
     * })
    **/
    count<T extends SessionViewingOptionOnSessionCountArgs>(
      args?: Subset<T, SessionViewingOptionOnSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionViewingOptionOnSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionViewingOptionOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionViewingOptionOnSessionAggregateArgs>(args: Subset<T, SessionViewingOptionOnSessionAggregateArgs>): Prisma.PrismaPromise<GetSessionViewingOptionOnSessionAggregateType<T>>

    /**
     * Group by SessionViewingOptionOnSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionViewingOptionOnSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionViewingOptionOnSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionViewingOptionOnSessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionViewingOptionOnSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionViewingOptionOnSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionViewingOptionOnSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionViewingOptionOnSession model
   */
  readonly fields: SessionViewingOptionOnSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionViewingOptionOnSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionViewingOptionOnSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    viewingOption<T extends ViewingOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ViewingOptionDefaultArgs<ExtArgs>>): Prisma__ViewingOptionClient<$Result.GetResult<Prisma.$ViewingOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionViewingOptionOnSession model
   */
  interface SessionViewingOptionOnSessionFieldRefs {
    readonly sessionId: FieldRef<"SessionViewingOptionOnSession", 'Int'>
    readonly viewingOptionId: FieldRef<"SessionViewingOptionOnSession", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionViewingOptionOnSession findUnique
   */
  export type SessionViewingOptionOnSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionViewingOptionOnSession to fetch.
     */
    where: SessionViewingOptionOnSessionWhereUniqueInput
  }

  /**
   * SessionViewingOptionOnSession findUniqueOrThrow
   */
  export type SessionViewingOptionOnSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionViewingOptionOnSession to fetch.
     */
    where: SessionViewingOptionOnSessionWhereUniqueInput
  }

  /**
   * SessionViewingOptionOnSession findFirst
   */
  export type SessionViewingOptionOnSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionViewingOptionOnSession to fetch.
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionViewingOptionOnSessions to fetch.
     */
    orderBy?: SessionViewingOptionOnSessionOrderByWithRelationInput | SessionViewingOptionOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionViewingOptionOnSessions.
     */
    cursor?: SessionViewingOptionOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionViewingOptionOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionViewingOptionOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionViewingOptionOnSessions.
     */
    distinct?: SessionViewingOptionOnSessionScalarFieldEnum | SessionViewingOptionOnSessionScalarFieldEnum[]
  }

  /**
   * SessionViewingOptionOnSession findFirstOrThrow
   */
  export type SessionViewingOptionOnSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionViewingOptionOnSession to fetch.
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionViewingOptionOnSessions to fetch.
     */
    orderBy?: SessionViewingOptionOnSessionOrderByWithRelationInput | SessionViewingOptionOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionViewingOptionOnSessions.
     */
    cursor?: SessionViewingOptionOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionViewingOptionOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionViewingOptionOnSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionViewingOptionOnSessions.
     */
    distinct?: SessionViewingOptionOnSessionScalarFieldEnum | SessionViewingOptionOnSessionScalarFieldEnum[]
  }

  /**
   * SessionViewingOptionOnSession findMany
   */
  export type SessionViewingOptionOnSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * Filter, which SessionViewingOptionOnSessions to fetch.
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionViewingOptionOnSessions to fetch.
     */
    orderBy?: SessionViewingOptionOnSessionOrderByWithRelationInput | SessionViewingOptionOnSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionViewingOptionOnSessions.
     */
    cursor?: SessionViewingOptionOnSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionViewingOptionOnSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionViewingOptionOnSessions.
     */
    skip?: number
    distinct?: SessionViewingOptionOnSessionScalarFieldEnum | SessionViewingOptionOnSessionScalarFieldEnum[]
  }

  /**
   * SessionViewingOptionOnSession create
   */
  export type SessionViewingOptionOnSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionViewingOptionOnSession.
     */
    data: XOR<SessionViewingOptionOnSessionCreateInput, SessionViewingOptionOnSessionUncheckedCreateInput>
  }

  /**
   * SessionViewingOptionOnSession createMany
   */
  export type SessionViewingOptionOnSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionViewingOptionOnSessions.
     */
    data: SessionViewingOptionOnSessionCreateManyInput | SessionViewingOptionOnSessionCreateManyInput[]
  }

  /**
   * SessionViewingOptionOnSession createManyAndReturn
   */
  export type SessionViewingOptionOnSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * The data used to create many SessionViewingOptionOnSessions.
     */
    data: SessionViewingOptionOnSessionCreateManyInput | SessionViewingOptionOnSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionViewingOptionOnSession update
   */
  export type SessionViewingOptionOnSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionViewingOptionOnSession.
     */
    data: XOR<SessionViewingOptionOnSessionUpdateInput, SessionViewingOptionOnSessionUncheckedUpdateInput>
    /**
     * Choose, which SessionViewingOptionOnSession to update.
     */
    where: SessionViewingOptionOnSessionWhereUniqueInput
  }

  /**
   * SessionViewingOptionOnSession updateMany
   */
  export type SessionViewingOptionOnSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionViewingOptionOnSessions.
     */
    data: XOR<SessionViewingOptionOnSessionUpdateManyMutationInput, SessionViewingOptionOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionViewingOptionOnSessions to update
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * Limit how many SessionViewingOptionOnSessions to update.
     */
    limit?: number
  }

  /**
   * SessionViewingOptionOnSession updateManyAndReturn
   */
  export type SessionViewingOptionOnSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * The data used to update SessionViewingOptionOnSessions.
     */
    data: XOR<SessionViewingOptionOnSessionUpdateManyMutationInput, SessionViewingOptionOnSessionUncheckedUpdateManyInput>
    /**
     * Filter which SessionViewingOptionOnSessions to update
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * Limit how many SessionViewingOptionOnSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionViewingOptionOnSession upsert
   */
  export type SessionViewingOptionOnSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionViewingOptionOnSession to update in case it exists.
     */
    where: SessionViewingOptionOnSessionWhereUniqueInput
    /**
     * In case the SessionViewingOptionOnSession found by the `where` argument doesn't exist, create a new SessionViewingOptionOnSession with this data.
     */
    create: XOR<SessionViewingOptionOnSessionCreateInput, SessionViewingOptionOnSessionUncheckedCreateInput>
    /**
     * In case the SessionViewingOptionOnSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionViewingOptionOnSessionUpdateInput, SessionViewingOptionOnSessionUncheckedUpdateInput>
  }

  /**
   * SessionViewingOptionOnSession delete
   */
  export type SessionViewingOptionOnSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
    /**
     * Filter which SessionViewingOptionOnSession to delete.
     */
    where: SessionViewingOptionOnSessionWhereUniqueInput
  }

  /**
   * SessionViewingOptionOnSession deleteMany
   */
  export type SessionViewingOptionOnSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionViewingOptionOnSessions to delete
     */
    where?: SessionViewingOptionOnSessionWhereInput
    /**
     * Limit how many SessionViewingOptionOnSessions to delete.
     */
    limit?: number
  }

  /**
   * SessionViewingOptionOnSession without action
   */
  export type SessionViewingOptionOnSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionViewingOptionOnSession
     */
    select?: SessionViewingOptionOnSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionViewingOptionOnSession
     */
    omit?: SessionViewingOptionOnSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionViewingOptionOnSessionInclude<ExtArgs> | null
  }


  /**
   * Model Speaker
   */

  export type AggregateSpeaker = {
    _count: SpeakerCountAggregateOutputType | null
    _avg: SpeakerAvgAggregateOutputType | null
    _sum: SpeakerSumAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  export type SpeakerAvgAggregateOutputType = {
    id: number | null
  }

  export type SpeakerSumAggregateOutputType = {
    id: number | null
  }

  export type SpeakerMinAggregateOutputType = {
    id: number | null
    speakerId: string | null
    name: string | null
    company: string | null
  }

  export type SpeakerMaxAggregateOutputType = {
    id: number | null
    speakerId: string | null
    name: string | null
    company: string | null
  }

  export type SpeakerCountAggregateOutputType = {
    id: number
    speakerId: number
    name: number
    company: number
    _all: number
  }


  export type SpeakerAvgAggregateInputType = {
    id?: true
  }

  export type SpeakerSumAggregateInputType = {
    id?: true
  }

  export type SpeakerMinAggregateInputType = {
    id?: true
    speakerId?: true
    name?: true
    company?: true
  }

  export type SpeakerMaxAggregateInputType = {
    id?: true
    speakerId?: true
    name?: true
    company?: true
  }

  export type SpeakerCountAggregateInputType = {
    id?: true
    speakerId?: true
    name?: true
    company?: true
    _all?: true
  }

  export type SpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speaker to aggregate.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Speakers
    **/
    _count?: true | SpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeakerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeakerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakerMaxAggregateInputType
  }

  export type GetSpeakerAggregateType<T extends SpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeaker[P]>
      : GetScalarType<T[P], AggregateSpeaker[P]>
  }




  export type SpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerWhereInput
    orderBy?: SpeakerOrderByWithAggregationInput | SpeakerOrderByWithAggregationInput[]
    by: SpeakerScalarFieldEnum[] | SpeakerScalarFieldEnum
    having?: SpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakerCountAggregateInputType | true
    _avg?: SpeakerAvgAggregateInputType
    _sum?: SpeakerSumAggregateInputType
    _min?: SpeakerMinAggregateInputType
    _max?: SpeakerMaxAggregateInputType
  }

  export type SpeakerGroupByOutputType = {
    id: number
    speakerId: string
    name: string
    company: string | null
    _count: SpeakerCountAggregateOutputType | null
    _avg: SpeakerAvgAggregateOutputType | null
    _sum: SpeakerSumAggregateOutputType | null
    _min: SpeakerMinAggregateOutputType | null
    _max: SpeakerMaxAggregateOutputType | null
  }

  type GetSpeakerGroupByPayload<T extends SpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerGroupByOutputType[P]>
        }
      >
    >


  export type SpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speakerId?: boolean
    name?: boolean
    company?: boolean
    sessionSpeakers?: boolean | Speaker$sessionSpeakersArgs<ExtArgs>
    speakerCompanies?: boolean | Speaker$speakerCompaniesArgs<ExtArgs>
    _count?: boolean | SpeakerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speaker"]>

  export type SpeakerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speakerId?: boolean
    name?: boolean
    company?: boolean
  }, ExtArgs["result"]["speaker"]>

  export type SpeakerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    speakerId?: boolean
    name?: boolean
    company?: boolean
  }, ExtArgs["result"]["speaker"]>

  export type SpeakerSelectScalar = {
    id?: boolean
    speakerId?: boolean
    name?: boolean
    company?: boolean
  }

  export type SpeakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "speakerId" | "name" | "company", ExtArgs["result"]["speaker"]>
  export type SpeakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessionSpeakers?: boolean | Speaker$sessionSpeakersArgs<ExtArgs>
    speakerCompanies?: boolean | Speaker$speakerCompaniesArgs<ExtArgs>
    _count?: boolean | SpeakerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SpeakerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SpeakerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Speaker"
    objects: {
      sessionSpeakers: Prisma.$SessionSpeakerPayload<ExtArgs>[]
      speakerCompanies: Prisma.$SpeakerCompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      speakerId: string
      name: string
      company: string | null
    }, ExtArgs["result"]["speaker"]>
    composites: {}
  }

  type SpeakerGetPayload<S extends boolean | null | undefined | SpeakerDefaultArgs> = $Result.GetResult<Prisma.$SpeakerPayload, S>

  type SpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakerCountAggregateInputType | true
    }

  export interface SpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Speaker'], meta: { name: 'Speaker' } }
    /**
     * Find zero or one Speaker that matches the filter.
     * @param {SpeakerFindUniqueArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakerFindUniqueArgs>(args: SelectSubset<T, SpeakerFindUniqueArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Speaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakerFindUniqueOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakerFindFirstArgs>(args?: SelectSubset<T, SpeakerFindFirstArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Speaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindFirstOrThrowArgs} args - Arguments to find a Speaker
     * @example
     * // Get one Speaker
     * const speaker = await prisma.speaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Speakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Speakers
     * const speakers = await prisma.speaker.findMany()
     * 
     * // Get first 10 Speakers
     * const speakers = await prisma.speaker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const speakerWithIdOnly = await prisma.speaker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpeakerFindManyArgs>(args?: SelectSubset<T, SpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Speaker.
     * @param {SpeakerCreateArgs} args - Arguments to create a Speaker.
     * @example
     * // Create one Speaker
     * const Speaker = await prisma.speaker.create({
     *   data: {
     *     // ... data to create a Speaker
     *   }
     * })
     * 
     */
    create<T extends SpeakerCreateArgs>(args: SelectSubset<T, SpeakerCreateArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Speakers.
     * @param {SpeakerCreateManyArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speaker = await prisma.speaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakerCreateManyArgs>(args?: SelectSubset<T, SpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Speakers and returns the data saved in the database.
     * @param {SpeakerCreateManyAndReturnArgs} args - Arguments to create many Speakers.
     * @example
     * // Create many Speakers
     * const speaker = await prisma.speaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Speakers and only return the `id`
     * const speakerWithIdOnly = await prisma.speaker.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeakerCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeakerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Speaker.
     * @param {SpeakerDeleteArgs} args - Arguments to delete one Speaker.
     * @example
     * // Delete one Speaker
     * const Speaker = await prisma.speaker.delete({
     *   where: {
     *     // ... filter to delete one Speaker
     *   }
     * })
     * 
     */
    delete<T extends SpeakerDeleteArgs>(args: SelectSubset<T, SpeakerDeleteArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Speaker.
     * @param {SpeakerUpdateArgs} args - Arguments to update one Speaker.
     * @example
     * // Update one Speaker
     * const speaker = await prisma.speaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakerUpdateArgs>(args: SelectSubset<T, SpeakerUpdateArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Speakers.
     * @param {SpeakerDeleteManyArgs} args - Arguments to filter Speakers to delete.
     * @example
     * // Delete a few Speakers
     * const { count } = await prisma.speaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakerDeleteManyArgs>(args?: SelectSubset<T, SpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakerUpdateManyArgs>(args: SelectSubset<T, SpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Speakers and returns the data updated in the database.
     * @param {SpeakerUpdateManyAndReturnArgs} args - Arguments to update many Speakers.
     * @example
     * // Update many Speakers
     * const speaker = await prisma.speaker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Speakers and only return the `id`
     * const speakerWithIdOnly = await prisma.speaker.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpeakerUpdateManyAndReturnArgs>(args: SelectSubset<T, SpeakerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Speaker.
     * @param {SpeakerUpsertArgs} args - Arguments to update or create a Speaker.
     * @example
     * // Update or create a Speaker
     * const speaker = await prisma.speaker.upsert({
     *   create: {
     *     // ... data to create a Speaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Speaker we want to update
     *   }
     * })
     */
    upsert<T extends SpeakerUpsertArgs>(args: SelectSubset<T, SpeakerUpsertArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Speakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCountArgs} args - Arguments to filter Speakers to count.
     * @example
     * // Count the number of Speakers
     * const count = await prisma.speaker.count({
     *   where: {
     *     // ... the filter for the Speakers we want to count
     *   }
     * })
    **/
    count<T extends SpeakerCountArgs>(
      args?: Subset<T, SpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakerAggregateArgs>(args: Subset<T, SpeakerAggregateArgs>): Prisma.PrismaPromise<GetSpeakerAggregateType<T>>

    /**
     * Group by Speaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Speaker model
   */
  readonly fields: SpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Speaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessionSpeakers<T extends Speaker$sessionSpeakersArgs<ExtArgs> = {}>(args?: Subset<T, Speaker$sessionSpeakersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    speakerCompanies<T extends Speaker$speakerCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, Speaker$speakerCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Speaker model
   */
  interface SpeakerFieldRefs {
    readonly id: FieldRef<"Speaker", 'Int'>
    readonly speakerId: FieldRef<"Speaker", 'String'>
    readonly name: FieldRef<"Speaker", 'String'>
    readonly company: FieldRef<"Speaker", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Speaker findUnique
   */
  export type SpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker findUniqueOrThrow
   */
  export type SpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker findFirst
   */
  export type SpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker findFirstOrThrow
   */
  export type SpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speaker to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Speakers.
     */
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker findMany
   */
  export type SpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter, which Speakers to fetch.
     */
    where?: SpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Speakers to fetch.
     */
    orderBy?: SpeakerOrderByWithRelationInput | SpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Speakers.
     */
    cursor?: SpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Speakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Speakers.
     */
    skip?: number
    distinct?: SpeakerScalarFieldEnum | SpeakerScalarFieldEnum[]
  }

  /**
   * Speaker create
   */
  export type SpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * The data needed to create a Speaker.
     */
    data: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
  }

  /**
   * Speaker createMany
   */
  export type SpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Speakers.
     */
    data: SpeakerCreateManyInput | SpeakerCreateManyInput[]
  }

  /**
   * Speaker createManyAndReturn
   */
  export type SpeakerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * The data used to create many Speakers.
     */
    data: SpeakerCreateManyInput | SpeakerCreateManyInput[]
  }

  /**
   * Speaker update
   */
  export type SpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * The data needed to update a Speaker.
     */
    data: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
    /**
     * Choose, which Speaker to update.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker updateMany
   */
  export type SpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>
    /**
     * Filter which Speakers to update
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to update.
     */
    limit?: number
  }

  /**
   * Speaker updateManyAndReturn
   */
  export type SpeakerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * The data used to update Speakers.
     */
    data: XOR<SpeakerUpdateManyMutationInput, SpeakerUncheckedUpdateManyInput>
    /**
     * Filter which Speakers to update
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to update.
     */
    limit?: number
  }

  /**
   * Speaker upsert
   */
  export type SpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * The filter to search for the Speaker to update in case it exists.
     */
    where: SpeakerWhereUniqueInput
    /**
     * In case the Speaker found by the `where` argument doesn't exist, create a new Speaker with this data.
     */
    create: XOR<SpeakerCreateInput, SpeakerUncheckedCreateInput>
    /**
     * In case the Speaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakerUpdateInput, SpeakerUncheckedUpdateInput>
  }

  /**
   * Speaker delete
   */
  export type SpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
    /**
     * Filter which Speaker to delete.
     */
    where: SpeakerWhereUniqueInput
  }

  /**
   * Speaker deleteMany
   */
  export type SpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Speakers to delete
     */
    where?: SpeakerWhereInput
    /**
     * Limit how many Speakers to delete.
     */
    limit?: number
  }

  /**
   * Speaker.sessionSpeakers
   */
  export type Speaker$sessionSpeakersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    where?: SessionSpeakerWhereInput
    orderBy?: SessionSpeakerOrderByWithRelationInput | SessionSpeakerOrderByWithRelationInput[]
    cursor?: SessionSpeakerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionSpeakerScalarFieldEnum | SessionSpeakerScalarFieldEnum[]
  }

  /**
   * Speaker.speakerCompanies
   */
  export type Speaker$speakerCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    where?: SpeakerCompanyWhereInput
    orderBy?: SpeakerCompanyOrderByWithRelationInput | SpeakerCompanyOrderByWithRelationInput[]
    cursor?: SpeakerCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakerCompanyScalarFieldEnum | SpeakerCompanyScalarFieldEnum[]
  }

  /**
   * Speaker without action
   */
  export type SpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Speaker
     */
    select?: SpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Speaker
     */
    omit?: SpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CompanyAvgAggregateInputType = {
    id?: true
  }

  export type CompanySumAggregateInputType = {
    id?: true
  }

  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _avg?: CompanyAvgAggregateInputType
    _sum?: CompanySumAggregateInputType
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: number
    name: string
    _count: CompanyCountAggregateOutputType | null
    _avg: CompanyAvgAggregateOutputType | null
    _sum: CompanySumAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    speakerCompanies?: boolean | Company$speakerCompaniesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speakerCompanies?: boolean | Company$speakerCompaniesArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      speakerCompanies: Prisma.$SpeakerCompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    speakerCompanies<T extends Company$speakerCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, Company$speakerCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'Int'>
    readonly name: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.speakerCompanies
   */
  export type Company$speakerCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    where?: SpeakerCompanyWhereInput
    orderBy?: SpeakerCompanyOrderByWithRelationInput | SpeakerCompanyOrderByWithRelationInput[]
    cursor?: SpeakerCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpeakerCompanyScalarFieldEnum | SpeakerCompanyScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model SpeakerCompany
   */

  export type AggregateSpeakerCompany = {
    _count: SpeakerCompanyCountAggregateOutputType | null
    _avg: SpeakerCompanyAvgAggregateOutputType | null
    _sum: SpeakerCompanySumAggregateOutputType | null
    _min: SpeakerCompanyMinAggregateOutputType | null
    _max: SpeakerCompanyMaxAggregateOutputType | null
  }

  export type SpeakerCompanyAvgAggregateOutputType = {
    speakerId: number | null
    companyId: number | null
  }

  export type SpeakerCompanySumAggregateOutputType = {
    speakerId: number | null
    companyId: number | null
  }

  export type SpeakerCompanyMinAggregateOutputType = {
    speakerId: number | null
    companyId: number | null
  }

  export type SpeakerCompanyMaxAggregateOutputType = {
    speakerId: number | null
    companyId: number | null
  }

  export type SpeakerCompanyCountAggregateOutputType = {
    speakerId: number
    companyId: number
    _all: number
  }


  export type SpeakerCompanyAvgAggregateInputType = {
    speakerId?: true
    companyId?: true
  }

  export type SpeakerCompanySumAggregateInputType = {
    speakerId?: true
    companyId?: true
  }

  export type SpeakerCompanyMinAggregateInputType = {
    speakerId?: true
    companyId?: true
  }

  export type SpeakerCompanyMaxAggregateInputType = {
    speakerId?: true
    companyId?: true
  }

  export type SpeakerCompanyCountAggregateInputType = {
    speakerId?: true
    companyId?: true
    _all?: true
  }

  export type SpeakerCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakerCompany to aggregate.
     */
    where?: SpeakerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerCompanies to fetch.
     */
    orderBy?: SpeakerCompanyOrderByWithRelationInput | SpeakerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpeakerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpeakerCompanies
    **/
    _count?: true | SpeakerCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpeakerCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpeakerCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpeakerCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpeakerCompanyMaxAggregateInputType
  }

  export type GetSpeakerCompanyAggregateType<T extends SpeakerCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateSpeakerCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpeakerCompany[P]>
      : GetScalarType<T[P], AggregateSpeakerCompany[P]>
  }




  export type SpeakerCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpeakerCompanyWhereInput
    orderBy?: SpeakerCompanyOrderByWithAggregationInput | SpeakerCompanyOrderByWithAggregationInput[]
    by: SpeakerCompanyScalarFieldEnum[] | SpeakerCompanyScalarFieldEnum
    having?: SpeakerCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpeakerCompanyCountAggregateInputType | true
    _avg?: SpeakerCompanyAvgAggregateInputType
    _sum?: SpeakerCompanySumAggregateInputType
    _min?: SpeakerCompanyMinAggregateInputType
    _max?: SpeakerCompanyMaxAggregateInputType
  }

  export type SpeakerCompanyGroupByOutputType = {
    speakerId: number
    companyId: number
    _count: SpeakerCompanyCountAggregateOutputType | null
    _avg: SpeakerCompanyAvgAggregateOutputType | null
    _sum: SpeakerCompanySumAggregateOutputType | null
    _min: SpeakerCompanyMinAggregateOutputType | null
    _max: SpeakerCompanyMaxAggregateOutputType | null
  }

  type GetSpeakerCompanyGroupByPayload<T extends SpeakerCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpeakerCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpeakerCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpeakerCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], SpeakerCompanyGroupByOutputType[P]>
        }
      >
    >


  export type SpeakerCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speakerId?: boolean
    companyId?: boolean
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakerCompany"]>

  export type SpeakerCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speakerId?: boolean
    companyId?: boolean
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakerCompany"]>

  export type SpeakerCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    speakerId?: boolean
    companyId?: boolean
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["speakerCompany"]>

  export type SpeakerCompanySelectScalar = {
    speakerId?: boolean
    companyId?: boolean
  }

  export type SpeakerCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"speakerId" | "companyId", ExtArgs["result"]["speakerCompany"]>
  export type SpeakerCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SpeakerCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SpeakerCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SpeakerCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpeakerCompany"
    objects: {
      speaker: Prisma.$SpeakerPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      speakerId: number
      companyId: number
    }, ExtArgs["result"]["speakerCompany"]>
    composites: {}
  }

  type SpeakerCompanyGetPayload<S extends boolean | null | undefined | SpeakerCompanyDefaultArgs> = $Result.GetResult<Prisma.$SpeakerCompanyPayload, S>

  type SpeakerCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SpeakerCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SpeakerCompanyCountAggregateInputType | true
    }

  export interface SpeakerCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpeakerCompany'], meta: { name: 'SpeakerCompany' } }
    /**
     * Find zero or one SpeakerCompany that matches the filter.
     * @param {SpeakerCompanyFindUniqueArgs} args - Arguments to find a SpeakerCompany
     * @example
     * // Get one SpeakerCompany
     * const speakerCompany = await prisma.speakerCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpeakerCompanyFindUniqueArgs>(args: SelectSubset<T, SpeakerCompanyFindUniqueArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SpeakerCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SpeakerCompanyFindUniqueOrThrowArgs} args - Arguments to find a SpeakerCompany
     * @example
     * // Get one SpeakerCompany
     * const speakerCompany = await prisma.speakerCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpeakerCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, SpeakerCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeakerCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyFindFirstArgs} args - Arguments to find a SpeakerCompany
     * @example
     * // Get one SpeakerCompany
     * const speakerCompany = await prisma.speakerCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpeakerCompanyFindFirstArgs>(args?: SelectSubset<T, SpeakerCompanyFindFirstArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SpeakerCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyFindFirstOrThrowArgs} args - Arguments to find a SpeakerCompany
     * @example
     * // Get one SpeakerCompany
     * const speakerCompany = await prisma.speakerCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpeakerCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, SpeakerCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SpeakerCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpeakerCompanies
     * const speakerCompanies = await prisma.speakerCompany.findMany()
     * 
     * // Get first 10 SpeakerCompanies
     * const speakerCompanies = await prisma.speakerCompany.findMany({ take: 10 })
     * 
     * // Only select the `speakerId`
     * const speakerCompanyWithSpeakerIdOnly = await prisma.speakerCompany.findMany({ select: { speakerId: true } })
     * 
     */
    findMany<T extends SpeakerCompanyFindManyArgs>(args?: SelectSubset<T, SpeakerCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SpeakerCompany.
     * @param {SpeakerCompanyCreateArgs} args - Arguments to create a SpeakerCompany.
     * @example
     * // Create one SpeakerCompany
     * const SpeakerCompany = await prisma.speakerCompany.create({
     *   data: {
     *     // ... data to create a SpeakerCompany
     *   }
     * })
     * 
     */
    create<T extends SpeakerCompanyCreateArgs>(args: SelectSubset<T, SpeakerCompanyCreateArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SpeakerCompanies.
     * @param {SpeakerCompanyCreateManyArgs} args - Arguments to create many SpeakerCompanies.
     * @example
     * // Create many SpeakerCompanies
     * const speakerCompany = await prisma.speakerCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpeakerCompanyCreateManyArgs>(args?: SelectSubset<T, SpeakerCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpeakerCompanies and returns the data saved in the database.
     * @param {SpeakerCompanyCreateManyAndReturnArgs} args - Arguments to create many SpeakerCompanies.
     * @example
     * // Create many SpeakerCompanies
     * const speakerCompany = await prisma.speakerCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpeakerCompanies and only return the `speakerId`
     * const speakerCompanyWithSpeakerIdOnly = await prisma.speakerCompany.createManyAndReturn({
     *   select: { speakerId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpeakerCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, SpeakerCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SpeakerCompany.
     * @param {SpeakerCompanyDeleteArgs} args - Arguments to delete one SpeakerCompany.
     * @example
     * // Delete one SpeakerCompany
     * const SpeakerCompany = await prisma.speakerCompany.delete({
     *   where: {
     *     // ... filter to delete one SpeakerCompany
     *   }
     * })
     * 
     */
    delete<T extends SpeakerCompanyDeleteArgs>(args: SelectSubset<T, SpeakerCompanyDeleteArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SpeakerCompany.
     * @param {SpeakerCompanyUpdateArgs} args - Arguments to update one SpeakerCompany.
     * @example
     * // Update one SpeakerCompany
     * const speakerCompany = await prisma.speakerCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpeakerCompanyUpdateArgs>(args: SelectSubset<T, SpeakerCompanyUpdateArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SpeakerCompanies.
     * @param {SpeakerCompanyDeleteManyArgs} args - Arguments to filter SpeakerCompanies to delete.
     * @example
     * // Delete a few SpeakerCompanies
     * const { count } = await prisma.speakerCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpeakerCompanyDeleteManyArgs>(args?: SelectSubset<T, SpeakerCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakerCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpeakerCompanies
     * const speakerCompany = await prisma.speakerCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpeakerCompanyUpdateManyArgs>(args: SelectSubset<T, SpeakerCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpeakerCompanies and returns the data updated in the database.
     * @param {SpeakerCompanyUpdateManyAndReturnArgs} args - Arguments to update many SpeakerCompanies.
     * @example
     * // Update many SpeakerCompanies
     * const speakerCompany = await prisma.speakerCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SpeakerCompanies and only return the `speakerId`
     * const speakerCompanyWithSpeakerIdOnly = await prisma.speakerCompany.updateManyAndReturn({
     *   select: { speakerId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SpeakerCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, SpeakerCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SpeakerCompany.
     * @param {SpeakerCompanyUpsertArgs} args - Arguments to update or create a SpeakerCompany.
     * @example
     * // Update or create a SpeakerCompany
     * const speakerCompany = await prisma.speakerCompany.upsert({
     *   create: {
     *     // ... data to create a SpeakerCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpeakerCompany we want to update
     *   }
     * })
     */
    upsert<T extends SpeakerCompanyUpsertArgs>(args: SelectSubset<T, SpeakerCompanyUpsertArgs<ExtArgs>>): Prisma__SpeakerCompanyClient<$Result.GetResult<Prisma.$SpeakerCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SpeakerCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyCountArgs} args - Arguments to filter SpeakerCompanies to count.
     * @example
     * // Count the number of SpeakerCompanies
     * const count = await prisma.speakerCompany.count({
     *   where: {
     *     // ... the filter for the SpeakerCompanies we want to count
     *   }
     * })
    **/
    count<T extends SpeakerCompanyCountArgs>(
      args?: Subset<T, SpeakerCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpeakerCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpeakerCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpeakerCompanyAggregateArgs>(args: Subset<T, SpeakerCompanyAggregateArgs>): Prisma.PrismaPromise<GetSpeakerCompanyAggregateType<T>>

    /**
     * Group by SpeakerCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpeakerCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpeakerCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpeakerCompanyGroupByArgs['orderBy'] }
        : { orderBy?: SpeakerCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpeakerCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpeakerCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpeakerCompany model
   */
  readonly fields: SpeakerCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpeakerCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpeakerCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    speaker<T extends SpeakerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeakerDefaultArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpeakerCompany model
   */
  interface SpeakerCompanyFieldRefs {
    readonly speakerId: FieldRef<"SpeakerCompany", 'Int'>
    readonly companyId: FieldRef<"SpeakerCompany", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SpeakerCompany findUnique
   */
  export type SpeakerCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SpeakerCompany to fetch.
     */
    where: SpeakerCompanyWhereUniqueInput
  }

  /**
   * SpeakerCompany findUniqueOrThrow
   */
  export type SpeakerCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SpeakerCompany to fetch.
     */
    where: SpeakerCompanyWhereUniqueInput
  }

  /**
   * SpeakerCompany findFirst
   */
  export type SpeakerCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SpeakerCompany to fetch.
     */
    where?: SpeakerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerCompanies to fetch.
     */
    orderBy?: SpeakerCompanyOrderByWithRelationInput | SpeakerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakerCompanies.
     */
    cursor?: SpeakerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakerCompanies.
     */
    distinct?: SpeakerCompanyScalarFieldEnum | SpeakerCompanyScalarFieldEnum[]
  }

  /**
   * SpeakerCompany findFirstOrThrow
   */
  export type SpeakerCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SpeakerCompany to fetch.
     */
    where?: SpeakerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerCompanies to fetch.
     */
    orderBy?: SpeakerCompanyOrderByWithRelationInput | SpeakerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpeakerCompanies.
     */
    cursor?: SpeakerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpeakerCompanies.
     */
    distinct?: SpeakerCompanyScalarFieldEnum | SpeakerCompanyScalarFieldEnum[]
  }

  /**
   * SpeakerCompany findMany
   */
  export type SpeakerCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * Filter, which SpeakerCompanies to fetch.
     */
    where?: SpeakerCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpeakerCompanies to fetch.
     */
    orderBy?: SpeakerCompanyOrderByWithRelationInput | SpeakerCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpeakerCompanies.
     */
    cursor?: SpeakerCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpeakerCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpeakerCompanies.
     */
    skip?: number
    distinct?: SpeakerCompanyScalarFieldEnum | SpeakerCompanyScalarFieldEnum[]
  }

  /**
   * SpeakerCompany create
   */
  export type SpeakerCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a SpeakerCompany.
     */
    data: XOR<SpeakerCompanyCreateInput, SpeakerCompanyUncheckedCreateInput>
  }

  /**
   * SpeakerCompany createMany
   */
  export type SpeakerCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpeakerCompanies.
     */
    data: SpeakerCompanyCreateManyInput | SpeakerCompanyCreateManyInput[]
  }

  /**
   * SpeakerCompany createManyAndReturn
   */
  export type SpeakerCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many SpeakerCompanies.
     */
    data: SpeakerCompanyCreateManyInput | SpeakerCompanyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeakerCompany update
   */
  export type SpeakerCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a SpeakerCompany.
     */
    data: XOR<SpeakerCompanyUpdateInput, SpeakerCompanyUncheckedUpdateInput>
    /**
     * Choose, which SpeakerCompany to update.
     */
    where: SpeakerCompanyWhereUniqueInput
  }

  /**
   * SpeakerCompany updateMany
   */
  export type SpeakerCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpeakerCompanies.
     */
    data: XOR<SpeakerCompanyUpdateManyMutationInput, SpeakerCompanyUncheckedUpdateManyInput>
    /**
     * Filter which SpeakerCompanies to update
     */
    where?: SpeakerCompanyWhereInput
    /**
     * Limit how many SpeakerCompanies to update.
     */
    limit?: number
  }

  /**
   * SpeakerCompany updateManyAndReturn
   */
  export type SpeakerCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * The data used to update SpeakerCompanies.
     */
    data: XOR<SpeakerCompanyUpdateManyMutationInput, SpeakerCompanyUncheckedUpdateManyInput>
    /**
     * Filter which SpeakerCompanies to update
     */
    where?: SpeakerCompanyWhereInput
    /**
     * Limit how many SpeakerCompanies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpeakerCompany upsert
   */
  export type SpeakerCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the SpeakerCompany to update in case it exists.
     */
    where: SpeakerCompanyWhereUniqueInput
    /**
     * In case the SpeakerCompany found by the `where` argument doesn't exist, create a new SpeakerCompany with this data.
     */
    create: XOR<SpeakerCompanyCreateInput, SpeakerCompanyUncheckedCreateInput>
    /**
     * In case the SpeakerCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpeakerCompanyUpdateInput, SpeakerCompanyUncheckedUpdateInput>
  }

  /**
   * SpeakerCompany delete
   */
  export type SpeakerCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
    /**
     * Filter which SpeakerCompany to delete.
     */
    where: SpeakerCompanyWhereUniqueInput
  }

  /**
   * SpeakerCompany deleteMany
   */
  export type SpeakerCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpeakerCompanies to delete
     */
    where?: SpeakerCompanyWhereInput
    /**
     * Limit how many SpeakerCompanies to delete.
     */
    limit?: number
  }

  /**
   * SpeakerCompany without action
   */
  export type SpeakerCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpeakerCompany
     */
    select?: SpeakerCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SpeakerCompany
     */
    omit?: SpeakerCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpeakerCompanyInclude<ExtArgs> | null
  }


  /**
   * Model SessionSpeaker
   */

  export type AggregateSessionSpeaker = {
    _count: SessionSpeakerCountAggregateOutputType | null
    _avg: SessionSpeakerAvgAggregateOutputType | null
    _sum: SessionSpeakerSumAggregateOutputType | null
    _min: SessionSpeakerMinAggregateOutputType | null
    _max: SessionSpeakerMaxAggregateOutputType | null
  }

  export type SessionSpeakerAvgAggregateOutputType = {
    sessionId: number | null
    speakerId: number | null
  }

  export type SessionSpeakerSumAggregateOutputType = {
    sessionId: number | null
    speakerId: number | null
  }

  export type SessionSpeakerMinAggregateOutputType = {
    sessionId: number | null
    speakerId: number | null
  }

  export type SessionSpeakerMaxAggregateOutputType = {
    sessionId: number | null
    speakerId: number | null
  }

  export type SessionSpeakerCountAggregateOutputType = {
    sessionId: number
    speakerId: number
    _all: number
  }


  export type SessionSpeakerAvgAggregateInputType = {
    sessionId?: true
    speakerId?: true
  }

  export type SessionSpeakerSumAggregateInputType = {
    sessionId?: true
    speakerId?: true
  }

  export type SessionSpeakerMinAggregateInputType = {
    sessionId?: true
    speakerId?: true
  }

  export type SessionSpeakerMaxAggregateInputType = {
    sessionId?: true
    speakerId?: true
  }

  export type SessionSpeakerCountAggregateInputType = {
    sessionId?: true
    speakerId?: true
    _all?: true
  }

  export type SessionSpeakerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionSpeaker to aggregate.
     */
    where?: SessionSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSpeakers to fetch.
     */
    orderBy?: SessionSpeakerOrderByWithRelationInput | SessionSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessionSpeakers
    **/
    _count?: true | SessionSpeakerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionSpeakerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionSpeakerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionSpeakerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionSpeakerMaxAggregateInputType
  }

  export type GetSessionSpeakerAggregateType<T extends SessionSpeakerAggregateArgs> = {
        [P in keyof T & keyof AggregateSessionSpeaker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessionSpeaker[P]>
      : GetScalarType<T[P], AggregateSessionSpeaker[P]>
  }




  export type SessionSpeakerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionSpeakerWhereInput
    orderBy?: SessionSpeakerOrderByWithAggregationInput | SessionSpeakerOrderByWithAggregationInput[]
    by: SessionSpeakerScalarFieldEnum[] | SessionSpeakerScalarFieldEnum
    having?: SessionSpeakerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionSpeakerCountAggregateInputType | true
    _avg?: SessionSpeakerAvgAggregateInputType
    _sum?: SessionSpeakerSumAggregateInputType
    _min?: SessionSpeakerMinAggregateInputType
    _max?: SessionSpeakerMaxAggregateInputType
  }

  export type SessionSpeakerGroupByOutputType = {
    sessionId: number
    speakerId: number
    _count: SessionSpeakerCountAggregateOutputType | null
    _avg: SessionSpeakerAvgAggregateOutputType | null
    _sum: SessionSpeakerSumAggregateOutputType | null
    _min: SessionSpeakerMinAggregateOutputType | null
    _max: SessionSpeakerMaxAggregateOutputType | null
  }

  type GetSessionSpeakerGroupByPayload<T extends SessionSpeakerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionSpeakerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionSpeakerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionSpeakerGroupByOutputType[P]>
            : GetScalarType<T[P], SessionSpeakerGroupByOutputType[P]>
        }
      >
    >


  export type SessionSpeakerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    speakerId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionSpeaker"]>

  export type SessionSpeakerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    speakerId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionSpeaker"]>

  export type SessionSpeakerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sessionId?: boolean
    speakerId?: boolean
    session?: boolean | SessionDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessionSpeaker"]>

  export type SessionSpeakerSelectScalar = {
    sessionId?: boolean
    speakerId?: boolean
  }

  export type SessionSpeakerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sessionId" | "speakerId", ExtArgs["result"]["sessionSpeaker"]>
  export type SessionSpeakerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }
  export type SessionSpeakerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }
  export type SessionSpeakerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | SessionDefaultArgs<ExtArgs>
    speaker?: boolean | SpeakerDefaultArgs<ExtArgs>
  }

  export type $SessionSpeakerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessionSpeaker"
    objects: {
      session: Prisma.$SessionPayload<ExtArgs>
      speaker: Prisma.$SpeakerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sessionId: number
      speakerId: number
    }, ExtArgs["result"]["sessionSpeaker"]>
    composites: {}
  }

  type SessionSpeakerGetPayload<S extends boolean | null | undefined | SessionSpeakerDefaultArgs> = $Result.GetResult<Prisma.$SessionSpeakerPayload, S>

  type SessionSpeakerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionSpeakerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionSpeakerCountAggregateInputType | true
    }

  export interface SessionSpeakerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessionSpeaker'], meta: { name: 'SessionSpeaker' } }
    /**
     * Find zero or one SessionSpeaker that matches the filter.
     * @param {SessionSpeakerFindUniqueArgs} args - Arguments to find a SessionSpeaker
     * @example
     * // Get one SessionSpeaker
     * const sessionSpeaker = await prisma.sessionSpeaker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionSpeakerFindUniqueArgs>(args: SelectSubset<T, SessionSpeakerFindUniqueArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessionSpeaker that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionSpeakerFindUniqueOrThrowArgs} args - Arguments to find a SessionSpeaker
     * @example
     * // Get one SessionSpeaker
     * const sessionSpeaker = await prisma.sessionSpeaker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionSpeakerFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionSpeakerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionSpeaker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerFindFirstArgs} args - Arguments to find a SessionSpeaker
     * @example
     * // Get one SessionSpeaker
     * const sessionSpeaker = await prisma.sessionSpeaker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionSpeakerFindFirstArgs>(args?: SelectSubset<T, SessionSpeakerFindFirstArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessionSpeaker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerFindFirstOrThrowArgs} args - Arguments to find a SessionSpeaker
     * @example
     * // Get one SessionSpeaker
     * const sessionSpeaker = await prisma.sessionSpeaker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionSpeakerFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionSpeakerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessionSpeakers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessionSpeakers
     * const sessionSpeakers = await prisma.sessionSpeaker.findMany()
     * 
     * // Get first 10 SessionSpeakers
     * const sessionSpeakers = await prisma.sessionSpeaker.findMany({ take: 10 })
     * 
     * // Only select the `sessionId`
     * const sessionSpeakerWithSessionIdOnly = await prisma.sessionSpeaker.findMany({ select: { sessionId: true } })
     * 
     */
    findMany<T extends SessionSpeakerFindManyArgs>(args?: SelectSubset<T, SessionSpeakerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessionSpeaker.
     * @param {SessionSpeakerCreateArgs} args - Arguments to create a SessionSpeaker.
     * @example
     * // Create one SessionSpeaker
     * const SessionSpeaker = await prisma.sessionSpeaker.create({
     *   data: {
     *     // ... data to create a SessionSpeaker
     *   }
     * })
     * 
     */
    create<T extends SessionSpeakerCreateArgs>(args: SelectSubset<T, SessionSpeakerCreateArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessionSpeakers.
     * @param {SessionSpeakerCreateManyArgs} args - Arguments to create many SessionSpeakers.
     * @example
     * // Create many SessionSpeakers
     * const sessionSpeaker = await prisma.sessionSpeaker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionSpeakerCreateManyArgs>(args?: SelectSubset<T, SessionSpeakerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessionSpeakers and returns the data saved in the database.
     * @param {SessionSpeakerCreateManyAndReturnArgs} args - Arguments to create many SessionSpeakers.
     * @example
     * // Create many SessionSpeakers
     * const sessionSpeaker = await prisma.sessionSpeaker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessionSpeakers and only return the `sessionId`
     * const sessionSpeakerWithSessionIdOnly = await prisma.sessionSpeaker.createManyAndReturn({
     *   select: { sessionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionSpeakerCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionSpeakerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessionSpeaker.
     * @param {SessionSpeakerDeleteArgs} args - Arguments to delete one SessionSpeaker.
     * @example
     * // Delete one SessionSpeaker
     * const SessionSpeaker = await prisma.sessionSpeaker.delete({
     *   where: {
     *     // ... filter to delete one SessionSpeaker
     *   }
     * })
     * 
     */
    delete<T extends SessionSpeakerDeleteArgs>(args: SelectSubset<T, SessionSpeakerDeleteArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessionSpeaker.
     * @param {SessionSpeakerUpdateArgs} args - Arguments to update one SessionSpeaker.
     * @example
     * // Update one SessionSpeaker
     * const sessionSpeaker = await prisma.sessionSpeaker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionSpeakerUpdateArgs>(args: SelectSubset<T, SessionSpeakerUpdateArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessionSpeakers.
     * @param {SessionSpeakerDeleteManyArgs} args - Arguments to filter SessionSpeakers to delete.
     * @example
     * // Delete a few SessionSpeakers
     * const { count } = await prisma.sessionSpeaker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionSpeakerDeleteManyArgs>(args?: SelectSubset<T, SessionSpeakerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessionSpeakers
     * const sessionSpeaker = await prisma.sessionSpeaker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionSpeakerUpdateManyArgs>(args: SelectSubset<T, SessionSpeakerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessionSpeakers and returns the data updated in the database.
     * @param {SessionSpeakerUpdateManyAndReturnArgs} args - Arguments to update many SessionSpeakers.
     * @example
     * // Update many SessionSpeakers
     * const sessionSpeaker = await prisma.sessionSpeaker.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessionSpeakers and only return the `sessionId`
     * const sessionSpeakerWithSessionIdOnly = await prisma.sessionSpeaker.updateManyAndReturn({
     *   select: { sessionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionSpeakerUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionSpeakerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessionSpeaker.
     * @param {SessionSpeakerUpsertArgs} args - Arguments to update or create a SessionSpeaker.
     * @example
     * // Update or create a SessionSpeaker
     * const sessionSpeaker = await prisma.sessionSpeaker.upsert({
     *   create: {
     *     // ... data to create a SessionSpeaker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessionSpeaker we want to update
     *   }
     * })
     */
    upsert<T extends SessionSpeakerUpsertArgs>(args: SelectSubset<T, SessionSpeakerUpsertArgs<ExtArgs>>): Prisma__SessionSpeakerClient<$Result.GetResult<Prisma.$SessionSpeakerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessionSpeakers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerCountArgs} args - Arguments to filter SessionSpeakers to count.
     * @example
     * // Count the number of SessionSpeakers
     * const count = await prisma.sessionSpeaker.count({
     *   where: {
     *     // ... the filter for the SessionSpeakers we want to count
     *   }
     * })
    **/
    count<T extends SessionSpeakerCountArgs>(
      args?: Subset<T, SessionSpeakerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionSpeakerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessionSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionSpeakerAggregateArgs>(args: Subset<T, SessionSpeakerAggregateArgs>): Prisma.PrismaPromise<GetSessionSpeakerAggregateType<T>>

    /**
     * Group by SessionSpeaker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionSpeakerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionSpeakerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionSpeakerGroupByArgs['orderBy'] }
        : { orderBy?: SessionSpeakerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionSpeakerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionSpeakerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessionSpeaker model
   */
  readonly fields: SessionSpeakerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessionSpeaker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionSpeakerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends SessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessionDefaultArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    speaker<T extends SpeakerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SpeakerDefaultArgs<ExtArgs>>): Prisma__SpeakerClient<$Result.GetResult<Prisma.$SpeakerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessionSpeaker model
   */
  interface SessionSpeakerFieldRefs {
    readonly sessionId: FieldRef<"SessionSpeaker", 'Int'>
    readonly speakerId: FieldRef<"SessionSpeaker", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SessionSpeaker findUnique
   */
  export type SessionSpeakerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which SessionSpeaker to fetch.
     */
    where: SessionSpeakerWhereUniqueInput
  }

  /**
   * SessionSpeaker findUniqueOrThrow
   */
  export type SessionSpeakerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which SessionSpeaker to fetch.
     */
    where: SessionSpeakerWhereUniqueInput
  }

  /**
   * SessionSpeaker findFirst
   */
  export type SessionSpeakerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which SessionSpeaker to fetch.
     */
    where?: SessionSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSpeakers to fetch.
     */
    orderBy?: SessionSpeakerOrderByWithRelationInput | SessionSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionSpeakers.
     */
    cursor?: SessionSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionSpeakers.
     */
    distinct?: SessionSpeakerScalarFieldEnum | SessionSpeakerScalarFieldEnum[]
  }

  /**
   * SessionSpeaker findFirstOrThrow
   */
  export type SessionSpeakerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which SessionSpeaker to fetch.
     */
    where?: SessionSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSpeakers to fetch.
     */
    orderBy?: SessionSpeakerOrderByWithRelationInput | SessionSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessionSpeakers.
     */
    cursor?: SessionSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSpeakers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessionSpeakers.
     */
    distinct?: SessionSpeakerScalarFieldEnum | SessionSpeakerScalarFieldEnum[]
  }

  /**
   * SessionSpeaker findMany
   */
  export type SessionSpeakerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * Filter, which SessionSpeakers to fetch.
     */
    where?: SessionSpeakerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessionSpeakers to fetch.
     */
    orderBy?: SessionSpeakerOrderByWithRelationInput | SessionSpeakerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessionSpeakers.
     */
    cursor?: SessionSpeakerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessionSpeakers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessionSpeakers.
     */
    skip?: number
    distinct?: SessionSpeakerScalarFieldEnum | SessionSpeakerScalarFieldEnum[]
  }

  /**
   * SessionSpeaker create
   */
  export type SessionSpeakerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * The data needed to create a SessionSpeaker.
     */
    data: XOR<SessionSpeakerCreateInput, SessionSpeakerUncheckedCreateInput>
  }

  /**
   * SessionSpeaker createMany
   */
  export type SessionSpeakerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessionSpeakers.
     */
    data: SessionSpeakerCreateManyInput | SessionSpeakerCreateManyInput[]
  }

  /**
   * SessionSpeaker createManyAndReturn
   */
  export type SessionSpeakerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * The data used to create many SessionSpeakers.
     */
    data: SessionSpeakerCreateManyInput | SessionSpeakerCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionSpeaker update
   */
  export type SessionSpeakerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * The data needed to update a SessionSpeaker.
     */
    data: XOR<SessionSpeakerUpdateInput, SessionSpeakerUncheckedUpdateInput>
    /**
     * Choose, which SessionSpeaker to update.
     */
    where: SessionSpeakerWhereUniqueInput
  }

  /**
   * SessionSpeaker updateMany
   */
  export type SessionSpeakerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessionSpeakers.
     */
    data: XOR<SessionSpeakerUpdateManyMutationInput, SessionSpeakerUncheckedUpdateManyInput>
    /**
     * Filter which SessionSpeakers to update
     */
    where?: SessionSpeakerWhereInput
    /**
     * Limit how many SessionSpeakers to update.
     */
    limit?: number
  }

  /**
   * SessionSpeaker updateManyAndReturn
   */
  export type SessionSpeakerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * The data used to update SessionSpeakers.
     */
    data: XOR<SessionSpeakerUpdateManyMutationInput, SessionSpeakerUncheckedUpdateManyInput>
    /**
     * Filter which SessionSpeakers to update
     */
    where?: SessionSpeakerWhereInput
    /**
     * Limit how many SessionSpeakers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessionSpeaker upsert
   */
  export type SessionSpeakerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * The filter to search for the SessionSpeaker to update in case it exists.
     */
    where: SessionSpeakerWhereUniqueInput
    /**
     * In case the SessionSpeaker found by the `where` argument doesn't exist, create a new SessionSpeaker with this data.
     */
    create: XOR<SessionSpeakerCreateInput, SessionSpeakerUncheckedCreateInput>
    /**
     * In case the SessionSpeaker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionSpeakerUpdateInput, SessionSpeakerUncheckedUpdateInput>
  }

  /**
   * SessionSpeaker delete
   */
  export type SessionSpeakerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
    /**
     * Filter which SessionSpeaker to delete.
     */
    where: SessionSpeakerWhereUniqueInput
  }

  /**
   * SessionSpeaker deleteMany
   */
  export type SessionSpeakerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessionSpeakers to delete
     */
    where?: SessionSpeakerWhereInput
    /**
     * Limit how many SessionSpeakers to delete.
     */
    limit?: number
  }

  /**
   * SessionSpeaker without action
   */
  export type SessionSpeakerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessionSpeaker
     */
    select?: SessionSpeakerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessionSpeaker
     */
    omit?: SessionSpeakerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionSpeakerInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    sessionInstanceId: 'sessionInstanceId',
    localizedId: 'localizedId',
    sessionCode: 'sessionCode',
    langLocale: 'langLocale',
    title: 'title',
    sortTitle: 'sortTitle',
    description: 'description',
    aiDescription: 'aiDescription',
    location: 'location',
    timeSlot: 'timeSlot',
    startDateTime: 'startDateTime',
    endDateTime: 'endDateTime',
    durationInMinutes: 'durationInMinutes',
    sessionTypeDisplay: 'sessionTypeDisplay',
    sessionTypeLogical: 'sessionTypeLogical',
    reportingTopic: 'reportingTopic',
    onDemandUrl: 'onDemandUrl',
    downloadVideoUrl: 'downloadVideoUrl',
    captionFileUrl: 'captionFileUrl',
    thumbnailUrl: 'thumbnailUrl',
    registrationLink: 'registrationLink',
    hasOnDemand: 'hasOnDemand',
    isPopular: 'isPopular',
    heroSession: 'heroSession'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const TopicScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type TopicScalarFieldEnum = (typeof TopicScalarFieldEnum)[keyof typeof TopicScalarFieldEnum]


  export const SessionTopicScalarFieldEnum: {
    sessionId: 'sessionId',
    topicId: 'topicId'
  };

  export type SessionTopicScalarFieldEnum = (typeof SessionTopicScalarFieldEnum)[keyof typeof SessionTopicScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const SessionTagScalarFieldEnum: {
    sessionId: 'sessionId',
    tagId: 'tagId'
  };

  export type SessionTagScalarFieldEnum = (typeof SessionTagScalarFieldEnum)[keyof typeof SessionTagScalarFieldEnum]


  export const LevelScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type LevelScalarFieldEnum = (typeof LevelScalarFieldEnum)[keyof typeof LevelScalarFieldEnum]


  export const SessionLevelOnSessionScalarFieldEnum: {
    sessionId: 'sessionId',
    levelId: 'levelId'
  };

  export type SessionLevelOnSessionScalarFieldEnum = (typeof SessionLevelOnSessionScalarFieldEnum)[keyof typeof SessionLevelOnSessionScalarFieldEnum]


  export const AudienceTypeScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type AudienceTypeScalarFieldEnum = (typeof AudienceTypeScalarFieldEnum)[keyof typeof AudienceTypeScalarFieldEnum]


  export const SessionAudienceTypeOnSessionScalarFieldEnum: {
    sessionId: 'sessionId',
    audienceTypeId: 'audienceTypeId'
  };

  export type SessionAudienceTypeOnSessionScalarFieldEnum = (typeof SessionAudienceTypeOnSessionScalarFieldEnum)[keyof typeof SessionAudienceTypeOnSessionScalarFieldEnum]


  export const IndustryScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type IndustryScalarFieldEnum = (typeof IndustryScalarFieldEnum)[keyof typeof IndustryScalarFieldEnum]


  export const SessionIndustryOnSessionScalarFieldEnum: {
    sessionId: 'sessionId',
    industryId: 'industryId'
  };

  export type SessionIndustryOnSessionScalarFieldEnum = (typeof SessionIndustryOnSessionScalarFieldEnum)[keyof typeof SessionIndustryOnSessionScalarFieldEnum]


  export const DeliveryTypeScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type DeliveryTypeScalarFieldEnum = (typeof DeliveryTypeScalarFieldEnum)[keyof typeof DeliveryTypeScalarFieldEnum]


  export const SessionDeliveryTypeOnSessionScalarFieldEnum: {
    sessionId: 'sessionId',
    deliveryTypeId: 'deliveryTypeId'
  };

  export type SessionDeliveryTypeOnSessionScalarFieldEnum = (typeof SessionDeliveryTypeOnSessionScalarFieldEnum)[keyof typeof SessionDeliveryTypeOnSessionScalarFieldEnum]


  export const ViewingOptionScalarFieldEnum: {
    id: 'id',
    logicalValue: 'logicalValue',
    displayValue: 'displayValue'
  };

  export type ViewingOptionScalarFieldEnum = (typeof ViewingOptionScalarFieldEnum)[keyof typeof ViewingOptionScalarFieldEnum]


  export const SessionViewingOptionOnSessionScalarFieldEnum: {
    sessionId: 'sessionId',
    viewingOptionId: 'viewingOptionId'
  };

  export type SessionViewingOptionOnSessionScalarFieldEnum = (typeof SessionViewingOptionOnSessionScalarFieldEnum)[keyof typeof SessionViewingOptionOnSessionScalarFieldEnum]


  export const SpeakerScalarFieldEnum: {
    id: 'id',
    speakerId: 'speakerId',
    name: 'name',
    company: 'company'
  };

  export type SpeakerScalarFieldEnum = (typeof SpeakerScalarFieldEnum)[keyof typeof SpeakerScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const SpeakerCompanyScalarFieldEnum: {
    speakerId: 'speakerId',
    companyId: 'companyId'
  };

  export type SpeakerCompanyScalarFieldEnum = (typeof SpeakerCompanyScalarFieldEnum)[keyof typeof SpeakerCompanyScalarFieldEnum]


  export const SessionSpeakerScalarFieldEnum: {
    sessionId: 'sessionId',
    speakerId: 'speakerId'
  };

  export type SessionSpeakerScalarFieldEnum = (typeof SessionSpeakerScalarFieldEnum)[keyof typeof SessionSpeakerScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: IntFilter<"Session"> | number
    sessionId?: StringFilter<"Session"> | string
    sessionInstanceId?: StringNullableFilter<"Session"> | string | null
    localizedId?: StringNullableFilter<"Session"> | string | null
    sessionCode?: StringNullableFilter<"Session"> | string | null
    langLocale?: StringNullableFilter<"Session"> | string | null
    title?: StringFilter<"Session"> | string
    sortTitle?: StringNullableFilter<"Session"> | string | null
    description?: StringNullableFilter<"Session"> | string | null
    aiDescription?: StringNullableFilter<"Session"> | string | null
    location?: StringNullableFilter<"Session"> | string | null
    timeSlot?: StringNullableFilter<"Session"> | string | null
    startDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    durationInMinutes?: IntNullableFilter<"Session"> | number | null
    sessionTypeDisplay?: StringNullableFilter<"Session"> | string | null
    sessionTypeLogical?: StringNullableFilter<"Session"> | string | null
    reportingTopic?: StringNullableFilter<"Session"> | string | null
    onDemandUrl?: StringNullableFilter<"Session"> | string | null
    downloadVideoUrl?: StringNullableFilter<"Session"> | string | null
    captionFileUrl?: StringNullableFilter<"Session"> | string | null
    thumbnailUrl?: StringNullableFilter<"Session"> | string | null
    registrationLink?: StringNullableFilter<"Session"> | string | null
    hasOnDemand?: BoolFilter<"Session"> | boolean
    isPopular?: BoolFilter<"Session"> | boolean
    heroSession?: BoolFilter<"Session"> | boolean
    sessionTopics?: SessionTopicListRelationFilter
    sessionTags?: SessionTagListRelationFilter
    sessionLevels?: SessionLevelOnSessionListRelationFilter
    sessionAudienceTypes?: SessionAudienceTypeOnSessionListRelationFilter
    sessionIndustries?: SessionIndustryOnSessionListRelationFilter
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionListRelationFilter
    sessionViewingOpts?: SessionViewingOptionOnSessionListRelationFilter
    sessionSpeakers?: SessionSpeakerListRelationFilter
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionInstanceId?: SortOrderInput | SortOrder
    localizedId?: SortOrderInput | SortOrder
    sessionCode?: SortOrderInput | SortOrder
    langLocale?: SortOrderInput | SortOrder
    title?: SortOrder
    sortTitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    aiDescription?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    timeSlot?: SortOrderInput | SortOrder
    startDateTime?: SortOrderInput | SortOrder
    endDateTime?: SortOrderInput | SortOrder
    durationInMinutes?: SortOrderInput | SortOrder
    sessionTypeDisplay?: SortOrderInput | SortOrder
    sessionTypeLogical?: SortOrderInput | SortOrder
    reportingTopic?: SortOrderInput | SortOrder
    onDemandUrl?: SortOrderInput | SortOrder
    downloadVideoUrl?: SortOrderInput | SortOrder
    captionFileUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    registrationLink?: SortOrderInput | SortOrder
    hasOnDemand?: SortOrder
    isPopular?: SortOrder
    heroSession?: SortOrder
    sessionTopics?: SessionTopicOrderByRelationAggregateInput
    sessionTags?: SessionTagOrderByRelationAggregateInput
    sessionLevels?: SessionLevelOnSessionOrderByRelationAggregateInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionOrderByRelationAggregateInput
    sessionIndustries?: SessionIndustryOnSessionOrderByRelationAggregateInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionOrderByRelationAggregateInput
    sessionViewingOpts?: SessionViewingOptionOnSessionOrderByRelationAggregateInput
    sessionSpeakers?: SessionSpeakerOrderByRelationAggregateInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessionId?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    sessionInstanceId?: StringNullableFilter<"Session"> | string | null
    localizedId?: StringNullableFilter<"Session"> | string | null
    sessionCode?: StringNullableFilter<"Session"> | string | null
    langLocale?: StringNullableFilter<"Session"> | string | null
    title?: StringFilter<"Session"> | string
    sortTitle?: StringNullableFilter<"Session"> | string | null
    description?: StringNullableFilter<"Session"> | string | null
    aiDescription?: StringNullableFilter<"Session"> | string | null
    location?: StringNullableFilter<"Session"> | string | null
    timeSlot?: StringNullableFilter<"Session"> | string | null
    startDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableFilter<"Session"> | Date | string | null
    durationInMinutes?: IntNullableFilter<"Session"> | number | null
    sessionTypeDisplay?: StringNullableFilter<"Session"> | string | null
    sessionTypeLogical?: StringNullableFilter<"Session"> | string | null
    reportingTopic?: StringNullableFilter<"Session"> | string | null
    onDemandUrl?: StringNullableFilter<"Session"> | string | null
    downloadVideoUrl?: StringNullableFilter<"Session"> | string | null
    captionFileUrl?: StringNullableFilter<"Session"> | string | null
    thumbnailUrl?: StringNullableFilter<"Session"> | string | null
    registrationLink?: StringNullableFilter<"Session"> | string | null
    hasOnDemand?: BoolFilter<"Session"> | boolean
    isPopular?: BoolFilter<"Session"> | boolean
    heroSession?: BoolFilter<"Session"> | boolean
    sessionTopics?: SessionTopicListRelationFilter
    sessionTags?: SessionTagListRelationFilter
    sessionLevels?: SessionLevelOnSessionListRelationFilter
    sessionAudienceTypes?: SessionAudienceTypeOnSessionListRelationFilter
    sessionIndustries?: SessionIndustryOnSessionListRelationFilter
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionListRelationFilter
    sessionViewingOpts?: SessionViewingOptionOnSessionListRelationFilter
    sessionSpeakers?: SessionSpeakerListRelationFilter
  }, "id" | "sessionId">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionInstanceId?: SortOrderInput | SortOrder
    localizedId?: SortOrderInput | SortOrder
    sessionCode?: SortOrderInput | SortOrder
    langLocale?: SortOrderInput | SortOrder
    title?: SortOrder
    sortTitle?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    aiDescription?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    timeSlot?: SortOrderInput | SortOrder
    startDateTime?: SortOrderInput | SortOrder
    endDateTime?: SortOrderInput | SortOrder
    durationInMinutes?: SortOrderInput | SortOrder
    sessionTypeDisplay?: SortOrderInput | SortOrder
    sessionTypeLogical?: SortOrderInput | SortOrder
    reportingTopic?: SortOrderInput | SortOrder
    onDemandUrl?: SortOrderInput | SortOrder
    downloadVideoUrl?: SortOrderInput | SortOrder
    captionFileUrl?: SortOrderInput | SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    registrationLink?: SortOrderInput | SortOrder
    hasOnDemand?: SortOrder
    isPopular?: SortOrder
    heroSession?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _avg?: SessionAvgOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
    _sum?: SessionSumOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Session"> | number
    sessionId?: StringWithAggregatesFilter<"Session"> | string
    sessionInstanceId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    localizedId?: StringNullableWithAggregatesFilter<"Session"> | string | null
    sessionCode?: StringNullableWithAggregatesFilter<"Session"> | string | null
    langLocale?: StringNullableWithAggregatesFilter<"Session"> | string | null
    title?: StringWithAggregatesFilter<"Session"> | string
    sortTitle?: StringNullableWithAggregatesFilter<"Session"> | string | null
    description?: StringNullableWithAggregatesFilter<"Session"> | string | null
    aiDescription?: StringNullableWithAggregatesFilter<"Session"> | string | null
    location?: StringNullableWithAggregatesFilter<"Session"> | string | null
    timeSlot?: StringNullableWithAggregatesFilter<"Session"> | string | null
    startDateTime?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    endDateTime?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
    durationInMinutes?: IntNullableWithAggregatesFilter<"Session"> | number | null
    sessionTypeDisplay?: StringNullableWithAggregatesFilter<"Session"> | string | null
    sessionTypeLogical?: StringNullableWithAggregatesFilter<"Session"> | string | null
    reportingTopic?: StringNullableWithAggregatesFilter<"Session"> | string | null
    onDemandUrl?: StringNullableWithAggregatesFilter<"Session"> | string | null
    downloadVideoUrl?: StringNullableWithAggregatesFilter<"Session"> | string | null
    captionFileUrl?: StringNullableWithAggregatesFilter<"Session"> | string | null
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Session"> | string | null
    registrationLink?: StringNullableWithAggregatesFilter<"Session"> | string | null
    hasOnDemand?: BoolWithAggregatesFilter<"Session"> | boolean
    isPopular?: BoolWithAggregatesFilter<"Session"> | boolean
    heroSession?: BoolWithAggregatesFilter<"Session"> | boolean
  }

  export type TopicWhereInput = {
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    id?: IntFilter<"Topic"> | number
    logicalValue?: StringFilter<"Topic"> | string
    displayValue?: StringFilter<"Topic"> | string
    sessions?: SessionTopicListRelationFilter
  }

  export type TopicOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionTopicOrderByRelationAggregateInput
  }

  export type TopicWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: TopicWhereInput | TopicWhereInput[]
    OR?: TopicWhereInput[]
    NOT?: TopicWhereInput | TopicWhereInput[]
    displayValue?: StringFilter<"Topic"> | string
    sessions?: SessionTopicListRelationFilter
  }, "id" | "logicalValue">

  export type TopicOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: TopicCountOrderByAggregateInput
    _avg?: TopicAvgOrderByAggregateInput
    _max?: TopicMaxOrderByAggregateInput
    _min?: TopicMinOrderByAggregateInput
    _sum?: TopicSumOrderByAggregateInput
  }

  export type TopicScalarWhereWithAggregatesInput = {
    AND?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    OR?: TopicScalarWhereWithAggregatesInput[]
    NOT?: TopicScalarWhereWithAggregatesInput | TopicScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Topic"> | number
    logicalValue?: StringWithAggregatesFilter<"Topic"> | string
    displayValue?: StringWithAggregatesFilter<"Topic"> | string
  }

  export type SessionTopicWhereInput = {
    AND?: SessionTopicWhereInput | SessionTopicWhereInput[]
    OR?: SessionTopicWhereInput[]
    NOT?: SessionTopicWhereInput | SessionTopicWhereInput[]
    sessionId?: IntFilter<"SessionTopic"> | number
    topicId?: IntFilter<"SessionTopic"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }

  export type SessionTopicOrderByWithRelationInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
    session?: SessionOrderByWithRelationInput
    topic?: TopicOrderByWithRelationInput
  }

  export type SessionTopicWhereUniqueInput = Prisma.AtLeast<{
    sessionId_topicId?: SessionTopicSessionIdTopicIdCompoundUniqueInput
    AND?: SessionTopicWhereInput | SessionTopicWhereInput[]
    OR?: SessionTopicWhereInput[]
    NOT?: SessionTopicWhereInput | SessionTopicWhereInput[]
    sessionId?: IntFilter<"SessionTopic"> | number
    topicId?: IntFilter<"SessionTopic"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    topic?: XOR<TopicScalarRelationFilter, TopicWhereInput>
  }, "sessionId_topicId">

  export type SessionTopicOrderByWithAggregationInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
    _count?: SessionTopicCountOrderByAggregateInput
    _avg?: SessionTopicAvgOrderByAggregateInput
    _max?: SessionTopicMaxOrderByAggregateInput
    _min?: SessionTopicMinOrderByAggregateInput
    _sum?: SessionTopicSumOrderByAggregateInput
  }

  export type SessionTopicScalarWhereWithAggregatesInput = {
    AND?: SessionTopicScalarWhereWithAggregatesInput | SessionTopicScalarWhereWithAggregatesInput[]
    OR?: SessionTopicScalarWhereWithAggregatesInput[]
    NOT?: SessionTopicScalarWhereWithAggregatesInput | SessionTopicScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionTopic"> | number
    topicId?: IntWithAggregatesFilter<"SessionTopic"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    logicalValue?: StringFilter<"Tag"> | string
    displayValue?: StringFilter<"Tag"> | string
    sessions?: SessionTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    displayValue?: StringFilter<"Tag"> | string
    sessions?: SessionTagListRelationFilter
  }, "id" | "logicalValue">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    logicalValue?: StringWithAggregatesFilter<"Tag"> | string
    displayValue?: StringWithAggregatesFilter<"Tag"> | string
  }

  export type SessionTagWhereInput = {
    AND?: SessionTagWhereInput | SessionTagWhereInput[]
    OR?: SessionTagWhereInput[]
    NOT?: SessionTagWhereInput | SessionTagWhereInput[]
    sessionId?: IntFilter<"SessionTag"> | number
    tagId?: IntFilter<"SessionTag"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type SessionTagOrderByWithRelationInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
    session?: SessionOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type SessionTagWhereUniqueInput = Prisma.AtLeast<{
    sessionId_tagId?: SessionTagSessionIdTagIdCompoundUniqueInput
    AND?: SessionTagWhereInput | SessionTagWhereInput[]
    OR?: SessionTagWhereInput[]
    NOT?: SessionTagWhereInput | SessionTagWhereInput[]
    sessionId?: IntFilter<"SessionTag"> | number
    tagId?: IntFilter<"SessionTag"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "sessionId_tagId">

  export type SessionTagOrderByWithAggregationInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
    _count?: SessionTagCountOrderByAggregateInput
    _avg?: SessionTagAvgOrderByAggregateInput
    _max?: SessionTagMaxOrderByAggregateInput
    _min?: SessionTagMinOrderByAggregateInput
    _sum?: SessionTagSumOrderByAggregateInput
  }

  export type SessionTagScalarWhereWithAggregatesInput = {
    AND?: SessionTagScalarWhereWithAggregatesInput | SessionTagScalarWhereWithAggregatesInput[]
    OR?: SessionTagScalarWhereWithAggregatesInput[]
    NOT?: SessionTagScalarWhereWithAggregatesInput | SessionTagScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionTag"> | number
    tagId?: IntWithAggregatesFilter<"SessionTag"> | number
  }

  export type LevelWhereInput = {
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    id?: IntFilter<"Level"> | number
    logicalValue?: StringFilter<"Level"> | string
    displayValue?: StringFilter<"Level"> | string
    sessions?: SessionLevelOnSessionListRelationFilter
  }

  export type LevelOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionLevelOnSessionOrderByRelationAggregateInput
  }

  export type LevelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: LevelWhereInput | LevelWhereInput[]
    OR?: LevelWhereInput[]
    NOT?: LevelWhereInput | LevelWhereInput[]
    displayValue?: StringFilter<"Level"> | string
    sessions?: SessionLevelOnSessionListRelationFilter
  }, "id" | "logicalValue">

  export type LevelOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: LevelCountOrderByAggregateInput
    _avg?: LevelAvgOrderByAggregateInput
    _max?: LevelMaxOrderByAggregateInput
    _min?: LevelMinOrderByAggregateInput
    _sum?: LevelSumOrderByAggregateInput
  }

  export type LevelScalarWhereWithAggregatesInput = {
    AND?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    OR?: LevelScalarWhereWithAggregatesInput[]
    NOT?: LevelScalarWhereWithAggregatesInput | LevelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Level"> | number
    logicalValue?: StringWithAggregatesFilter<"Level"> | string
    displayValue?: StringWithAggregatesFilter<"Level"> | string
  }

  export type SessionLevelOnSessionWhereInput = {
    AND?: SessionLevelOnSessionWhereInput | SessionLevelOnSessionWhereInput[]
    OR?: SessionLevelOnSessionWhereInput[]
    NOT?: SessionLevelOnSessionWhereInput | SessionLevelOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionLevelOnSession"> | number
    levelId?: IntFilter<"SessionLevelOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
  }

  export type SessionLevelOnSessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
    session?: SessionOrderByWithRelationInput
    level?: LevelOrderByWithRelationInput
  }

  export type SessionLevelOnSessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId_levelId?: SessionLevelOnSessionSessionIdLevelIdCompoundUniqueInput
    AND?: SessionLevelOnSessionWhereInput | SessionLevelOnSessionWhereInput[]
    OR?: SessionLevelOnSessionWhereInput[]
    NOT?: SessionLevelOnSessionWhereInput | SessionLevelOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionLevelOnSession"> | number
    levelId?: IntFilter<"SessionLevelOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    level?: XOR<LevelScalarRelationFilter, LevelWhereInput>
  }, "sessionId_levelId">

  export type SessionLevelOnSessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
    _count?: SessionLevelOnSessionCountOrderByAggregateInput
    _avg?: SessionLevelOnSessionAvgOrderByAggregateInput
    _max?: SessionLevelOnSessionMaxOrderByAggregateInput
    _min?: SessionLevelOnSessionMinOrderByAggregateInput
    _sum?: SessionLevelOnSessionSumOrderByAggregateInput
  }

  export type SessionLevelOnSessionScalarWhereWithAggregatesInput = {
    AND?: SessionLevelOnSessionScalarWhereWithAggregatesInput | SessionLevelOnSessionScalarWhereWithAggregatesInput[]
    OR?: SessionLevelOnSessionScalarWhereWithAggregatesInput[]
    NOT?: SessionLevelOnSessionScalarWhereWithAggregatesInput | SessionLevelOnSessionScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionLevelOnSession"> | number
    levelId?: IntWithAggregatesFilter<"SessionLevelOnSession"> | number
  }

  export type AudienceTypeWhereInput = {
    AND?: AudienceTypeWhereInput | AudienceTypeWhereInput[]
    OR?: AudienceTypeWhereInput[]
    NOT?: AudienceTypeWhereInput | AudienceTypeWhereInput[]
    id?: IntFilter<"AudienceType"> | number
    logicalValue?: StringFilter<"AudienceType"> | string
    displayValue?: StringFilter<"AudienceType"> | string
    sessions?: SessionAudienceTypeOnSessionListRelationFilter
  }

  export type AudienceTypeOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionAudienceTypeOnSessionOrderByRelationAggregateInput
  }

  export type AudienceTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: AudienceTypeWhereInput | AudienceTypeWhereInput[]
    OR?: AudienceTypeWhereInput[]
    NOT?: AudienceTypeWhereInput | AudienceTypeWhereInput[]
    displayValue?: StringFilter<"AudienceType"> | string
    sessions?: SessionAudienceTypeOnSessionListRelationFilter
  }, "id" | "logicalValue">

  export type AudienceTypeOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: AudienceTypeCountOrderByAggregateInput
    _avg?: AudienceTypeAvgOrderByAggregateInput
    _max?: AudienceTypeMaxOrderByAggregateInput
    _min?: AudienceTypeMinOrderByAggregateInput
    _sum?: AudienceTypeSumOrderByAggregateInput
  }

  export type AudienceTypeScalarWhereWithAggregatesInput = {
    AND?: AudienceTypeScalarWhereWithAggregatesInput | AudienceTypeScalarWhereWithAggregatesInput[]
    OR?: AudienceTypeScalarWhereWithAggregatesInput[]
    NOT?: AudienceTypeScalarWhereWithAggregatesInput | AudienceTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AudienceType"> | number
    logicalValue?: StringWithAggregatesFilter<"AudienceType"> | string
    displayValue?: StringWithAggregatesFilter<"AudienceType"> | string
  }

  export type SessionAudienceTypeOnSessionWhereInput = {
    AND?: SessionAudienceTypeOnSessionWhereInput | SessionAudienceTypeOnSessionWhereInput[]
    OR?: SessionAudienceTypeOnSessionWhereInput[]
    NOT?: SessionAudienceTypeOnSessionWhereInput | SessionAudienceTypeOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionAudienceTypeOnSession"> | number
    audienceTypeId?: IntFilter<"SessionAudienceTypeOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    audienceType?: XOR<AudienceTypeScalarRelationFilter, AudienceTypeWhereInput>
  }

  export type SessionAudienceTypeOnSessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
    session?: SessionOrderByWithRelationInput
    audienceType?: AudienceTypeOrderByWithRelationInput
  }

  export type SessionAudienceTypeOnSessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId_audienceTypeId?: SessionAudienceTypeOnSessionSessionIdAudienceTypeIdCompoundUniqueInput
    AND?: SessionAudienceTypeOnSessionWhereInput | SessionAudienceTypeOnSessionWhereInput[]
    OR?: SessionAudienceTypeOnSessionWhereInput[]
    NOT?: SessionAudienceTypeOnSessionWhereInput | SessionAudienceTypeOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionAudienceTypeOnSession"> | number
    audienceTypeId?: IntFilter<"SessionAudienceTypeOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    audienceType?: XOR<AudienceTypeScalarRelationFilter, AudienceTypeWhereInput>
  }, "sessionId_audienceTypeId">

  export type SessionAudienceTypeOnSessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
    _count?: SessionAudienceTypeOnSessionCountOrderByAggregateInput
    _avg?: SessionAudienceTypeOnSessionAvgOrderByAggregateInput
    _max?: SessionAudienceTypeOnSessionMaxOrderByAggregateInput
    _min?: SessionAudienceTypeOnSessionMinOrderByAggregateInput
    _sum?: SessionAudienceTypeOnSessionSumOrderByAggregateInput
  }

  export type SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput = {
    AND?: SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput | SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput[]
    OR?: SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput[]
    NOT?: SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput | SessionAudienceTypeOnSessionScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionAudienceTypeOnSession"> | number
    audienceTypeId?: IntWithAggregatesFilter<"SessionAudienceTypeOnSession"> | number
  }

  export type IndustryWhereInput = {
    AND?: IndustryWhereInput | IndustryWhereInput[]
    OR?: IndustryWhereInput[]
    NOT?: IndustryWhereInput | IndustryWhereInput[]
    id?: IntFilter<"Industry"> | number
    logicalValue?: StringFilter<"Industry"> | string
    displayValue?: StringFilter<"Industry"> | string
    sessions?: SessionIndustryOnSessionListRelationFilter
  }

  export type IndustryOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionIndustryOnSessionOrderByRelationAggregateInput
  }

  export type IndustryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: IndustryWhereInput | IndustryWhereInput[]
    OR?: IndustryWhereInput[]
    NOT?: IndustryWhereInput | IndustryWhereInput[]
    displayValue?: StringFilter<"Industry"> | string
    sessions?: SessionIndustryOnSessionListRelationFilter
  }, "id" | "logicalValue">

  export type IndustryOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: IndustryCountOrderByAggregateInput
    _avg?: IndustryAvgOrderByAggregateInput
    _max?: IndustryMaxOrderByAggregateInput
    _min?: IndustryMinOrderByAggregateInput
    _sum?: IndustrySumOrderByAggregateInput
  }

  export type IndustryScalarWhereWithAggregatesInput = {
    AND?: IndustryScalarWhereWithAggregatesInput | IndustryScalarWhereWithAggregatesInput[]
    OR?: IndustryScalarWhereWithAggregatesInput[]
    NOT?: IndustryScalarWhereWithAggregatesInput | IndustryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Industry"> | number
    logicalValue?: StringWithAggregatesFilter<"Industry"> | string
    displayValue?: StringWithAggregatesFilter<"Industry"> | string
  }

  export type SessionIndustryOnSessionWhereInput = {
    AND?: SessionIndustryOnSessionWhereInput | SessionIndustryOnSessionWhereInput[]
    OR?: SessionIndustryOnSessionWhereInput[]
    NOT?: SessionIndustryOnSessionWhereInput | SessionIndustryOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionIndustryOnSession"> | number
    industryId?: IntFilter<"SessionIndustryOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }

  export type SessionIndustryOnSessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
    session?: SessionOrderByWithRelationInput
    industry?: IndustryOrderByWithRelationInput
  }

  export type SessionIndustryOnSessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId_industryId?: SessionIndustryOnSessionSessionIdIndustryIdCompoundUniqueInput
    AND?: SessionIndustryOnSessionWhereInput | SessionIndustryOnSessionWhereInput[]
    OR?: SessionIndustryOnSessionWhereInput[]
    NOT?: SessionIndustryOnSessionWhereInput | SessionIndustryOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionIndustryOnSession"> | number
    industryId?: IntFilter<"SessionIndustryOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    industry?: XOR<IndustryScalarRelationFilter, IndustryWhereInput>
  }, "sessionId_industryId">

  export type SessionIndustryOnSessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
    _count?: SessionIndustryOnSessionCountOrderByAggregateInput
    _avg?: SessionIndustryOnSessionAvgOrderByAggregateInput
    _max?: SessionIndustryOnSessionMaxOrderByAggregateInput
    _min?: SessionIndustryOnSessionMinOrderByAggregateInput
    _sum?: SessionIndustryOnSessionSumOrderByAggregateInput
  }

  export type SessionIndustryOnSessionScalarWhereWithAggregatesInput = {
    AND?: SessionIndustryOnSessionScalarWhereWithAggregatesInput | SessionIndustryOnSessionScalarWhereWithAggregatesInput[]
    OR?: SessionIndustryOnSessionScalarWhereWithAggregatesInput[]
    NOT?: SessionIndustryOnSessionScalarWhereWithAggregatesInput | SessionIndustryOnSessionScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionIndustryOnSession"> | number
    industryId?: IntWithAggregatesFilter<"SessionIndustryOnSession"> | number
  }

  export type DeliveryTypeWhereInput = {
    AND?: DeliveryTypeWhereInput | DeliveryTypeWhereInput[]
    OR?: DeliveryTypeWhereInput[]
    NOT?: DeliveryTypeWhereInput | DeliveryTypeWhereInput[]
    id?: IntFilter<"DeliveryType"> | number
    logicalValue?: StringFilter<"DeliveryType"> | string
    displayValue?: StringFilter<"DeliveryType"> | string
    sessions?: SessionDeliveryTypeOnSessionListRelationFilter
  }

  export type DeliveryTypeOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionDeliveryTypeOnSessionOrderByRelationAggregateInput
  }

  export type DeliveryTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: DeliveryTypeWhereInput | DeliveryTypeWhereInput[]
    OR?: DeliveryTypeWhereInput[]
    NOT?: DeliveryTypeWhereInput | DeliveryTypeWhereInput[]
    displayValue?: StringFilter<"DeliveryType"> | string
    sessions?: SessionDeliveryTypeOnSessionListRelationFilter
  }, "id" | "logicalValue">

  export type DeliveryTypeOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: DeliveryTypeCountOrderByAggregateInput
    _avg?: DeliveryTypeAvgOrderByAggregateInput
    _max?: DeliveryTypeMaxOrderByAggregateInput
    _min?: DeliveryTypeMinOrderByAggregateInput
    _sum?: DeliveryTypeSumOrderByAggregateInput
  }

  export type DeliveryTypeScalarWhereWithAggregatesInput = {
    AND?: DeliveryTypeScalarWhereWithAggregatesInput | DeliveryTypeScalarWhereWithAggregatesInput[]
    OR?: DeliveryTypeScalarWhereWithAggregatesInput[]
    NOT?: DeliveryTypeScalarWhereWithAggregatesInput | DeliveryTypeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DeliveryType"> | number
    logicalValue?: StringWithAggregatesFilter<"DeliveryType"> | string
    displayValue?: StringWithAggregatesFilter<"DeliveryType"> | string
  }

  export type SessionDeliveryTypeOnSessionWhereInput = {
    AND?: SessionDeliveryTypeOnSessionWhereInput | SessionDeliveryTypeOnSessionWhereInput[]
    OR?: SessionDeliveryTypeOnSessionWhereInput[]
    NOT?: SessionDeliveryTypeOnSessionWhereInput | SessionDeliveryTypeOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionDeliveryTypeOnSession"> | number
    deliveryTypeId?: IntFilter<"SessionDeliveryTypeOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    deliveryType?: XOR<DeliveryTypeScalarRelationFilter, DeliveryTypeWhereInput>
  }

  export type SessionDeliveryTypeOnSessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
    session?: SessionOrderByWithRelationInput
    deliveryType?: DeliveryTypeOrderByWithRelationInput
  }

  export type SessionDeliveryTypeOnSessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId_deliveryTypeId?: SessionDeliveryTypeOnSessionSessionIdDeliveryTypeIdCompoundUniqueInput
    AND?: SessionDeliveryTypeOnSessionWhereInput | SessionDeliveryTypeOnSessionWhereInput[]
    OR?: SessionDeliveryTypeOnSessionWhereInput[]
    NOT?: SessionDeliveryTypeOnSessionWhereInput | SessionDeliveryTypeOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionDeliveryTypeOnSession"> | number
    deliveryTypeId?: IntFilter<"SessionDeliveryTypeOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    deliveryType?: XOR<DeliveryTypeScalarRelationFilter, DeliveryTypeWhereInput>
  }, "sessionId_deliveryTypeId">

  export type SessionDeliveryTypeOnSessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
    _count?: SessionDeliveryTypeOnSessionCountOrderByAggregateInput
    _avg?: SessionDeliveryTypeOnSessionAvgOrderByAggregateInput
    _max?: SessionDeliveryTypeOnSessionMaxOrderByAggregateInput
    _min?: SessionDeliveryTypeOnSessionMinOrderByAggregateInput
    _sum?: SessionDeliveryTypeOnSessionSumOrderByAggregateInput
  }

  export type SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput = {
    AND?: SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput | SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput[]
    OR?: SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput[]
    NOT?: SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput | SessionDeliveryTypeOnSessionScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionDeliveryTypeOnSession"> | number
    deliveryTypeId?: IntWithAggregatesFilter<"SessionDeliveryTypeOnSession"> | number
  }

  export type ViewingOptionWhereInput = {
    AND?: ViewingOptionWhereInput | ViewingOptionWhereInput[]
    OR?: ViewingOptionWhereInput[]
    NOT?: ViewingOptionWhereInput | ViewingOptionWhereInput[]
    id?: IntFilter<"ViewingOption"> | number
    logicalValue?: StringFilter<"ViewingOption"> | string
    displayValue?: StringFilter<"ViewingOption"> | string
    sessions?: SessionViewingOptionOnSessionListRelationFilter
  }

  export type ViewingOptionOrderByWithRelationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    sessions?: SessionViewingOptionOnSessionOrderByRelationAggregateInput
  }

  export type ViewingOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    logicalValue?: string
    AND?: ViewingOptionWhereInput | ViewingOptionWhereInput[]
    OR?: ViewingOptionWhereInput[]
    NOT?: ViewingOptionWhereInput | ViewingOptionWhereInput[]
    displayValue?: StringFilter<"ViewingOption"> | string
    sessions?: SessionViewingOptionOnSessionListRelationFilter
  }, "id" | "logicalValue">

  export type ViewingOptionOrderByWithAggregationInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
    _count?: ViewingOptionCountOrderByAggregateInput
    _avg?: ViewingOptionAvgOrderByAggregateInput
    _max?: ViewingOptionMaxOrderByAggregateInput
    _min?: ViewingOptionMinOrderByAggregateInput
    _sum?: ViewingOptionSumOrderByAggregateInput
  }

  export type ViewingOptionScalarWhereWithAggregatesInput = {
    AND?: ViewingOptionScalarWhereWithAggregatesInput | ViewingOptionScalarWhereWithAggregatesInput[]
    OR?: ViewingOptionScalarWhereWithAggregatesInput[]
    NOT?: ViewingOptionScalarWhereWithAggregatesInput | ViewingOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ViewingOption"> | number
    logicalValue?: StringWithAggregatesFilter<"ViewingOption"> | string
    displayValue?: StringWithAggregatesFilter<"ViewingOption"> | string
  }

  export type SessionViewingOptionOnSessionWhereInput = {
    AND?: SessionViewingOptionOnSessionWhereInput | SessionViewingOptionOnSessionWhereInput[]
    OR?: SessionViewingOptionOnSessionWhereInput[]
    NOT?: SessionViewingOptionOnSessionWhereInput | SessionViewingOptionOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionViewingOptionOnSession"> | number
    viewingOptionId?: IntFilter<"SessionViewingOptionOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    viewingOption?: XOR<ViewingOptionScalarRelationFilter, ViewingOptionWhereInput>
  }

  export type SessionViewingOptionOnSessionOrderByWithRelationInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
    session?: SessionOrderByWithRelationInput
    viewingOption?: ViewingOptionOrderByWithRelationInput
  }

  export type SessionViewingOptionOnSessionWhereUniqueInput = Prisma.AtLeast<{
    sessionId_viewingOptionId?: SessionViewingOptionOnSessionSessionIdViewingOptionIdCompoundUniqueInput
    AND?: SessionViewingOptionOnSessionWhereInput | SessionViewingOptionOnSessionWhereInput[]
    OR?: SessionViewingOptionOnSessionWhereInput[]
    NOT?: SessionViewingOptionOnSessionWhereInput | SessionViewingOptionOnSessionWhereInput[]
    sessionId?: IntFilter<"SessionViewingOptionOnSession"> | number
    viewingOptionId?: IntFilter<"SessionViewingOptionOnSession"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    viewingOption?: XOR<ViewingOptionScalarRelationFilter, ViewingOptionWhereInput>
  }, "sessionId_viewingOptionId">

  export type SessionViewingOptionOnSessionOrderByWithAggregationInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
    _count?: SessionViewingOptionOnSessionCountOrderByAggregateInput
    _avg?: SessionViewingOptionOnSessionAvgOrderByAggregateInput
    _max?: SessionViewingOptionOnSessionMaxOrderByAggregateInput
    _min?: SessionViewingOptionOnSessionMinOrderByAggregateInput
    _sum?: SessionViewingOptionOnSessionSumOrderByAggregateInput
  }

  export type SessionViewingOptionOnSessionScalarWhereWithAggregatesInput = {
    AND?: SessionViewingOptionOnSessionScalarWhereWithAggregatesInput | SessionViewingOptionOnSessionScalarWhereWithAggregatesInput[]
    OR?: SessionViewingOptionOnSessionScalarWhereWithAggregatesInput[]
    NOT?: SessionViewingOptionOnSessionScalarWhereWithAggregatesInput | SessionViewingOptionOnSessionScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionViewingOptionOnSession"> | number
    viewingOptionId?: IntWithAggregatesFilter<"SessionViewingOptionOnSession"> | number
  }

  export type SpeakerWhereInput = {
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
    id?: IntFilter<"Speaker"> | number
    speakerId?: StringFilter<"Speaker"> | string
    name?: StringFilter<"Speaker"> | string
    company?: StringNullableFilter<"Speaker"> | string | null
    sessionSpeakers?: SessionSpeakerListRelationFilter
    speakerCompanies?: SpeakerCompanyListRelationFilter
  }

  export type SpeakerOrderByWithRelationInput = {
    id?: SortOrder
    speakerId?: SortOrder
    name?: SortOrder
    company?: SortOrderInput | SortOrder
    sessionSpeakers?: SessionSpeakerOrderByRelationAggregateInput
    speakerCompanies?: SpeakerCompanyOrderByRelationAggregateInput
  }

  export type SpeakerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    speakerId?: string
    AND?: SpeakerWhereInput | SpeakerWhereInput[]
    OR?: SpeakerWhereInput[]
    NOT?: SpeakerWhereInput | SpeakerWhereInput[]
    name?: StringFilter<"Speaker"> | string
    company?: StringNullableFilter<"Speaker"> | string | null
    sessionSpeakers?: SessionSpeakerListRelationFilter
    speakerCompanies?: SpeakerCompanyListRelationFilter
  }, "id" | "speakerId">

  export type SpeakerOrderByWithAggregationInput = {
    id?: SortOrder
    speakerId?: SortOrder
    name?: SortOrder
    company?: SortOrderInput | SortOrder
    _count?: SpeakerCountOrderByAggregateInput
    _avg?: SpeakerAvgOrderByAggregateInput
    _max?: SpeakerMaxOrderByAggregateInput
    _min?: SpeakerMinOrderByAggregateInput
    _sum?: SpeakerSumOrderByAggregateInput
  }

  export type SpeakerScalarWhereWithAggregatesInput = {
    AND?: SpeakerScalarWhereWithAggregatesInput | SpeakerScalarWhereWithAggregatesInput[]
    OR?: SpeakerScalarWhereWithAggregatesInput[]
    NOT?: SpeakerScalarWhereWithAggregatesInput | SpeakerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Speaker"> | number
    speakerId?: StringWithAggregatesFilter<"Speaker"> | string
    name?: StringWithAggregatesFilter<"Speaker"> | string
    company?: StringNullableWithAggregatesFilter<"Speaker"> | string | null
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: IntFilter<"Company"> | number
    name?: StringFilter<"Company"> | string
    speakerCompanies?: SpeakerCompanyListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    speakerCompanies?: SpeakerCompanyOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    speakerCompanies?: SpeakerCompanyListRelationFilter
  }, "id" | "name">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _avg?: CompanyAvgOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
    _sum?: CompanySumOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Company"> | number
    name?: StringWithAggregatesFilter<"Company"> | string
  }

  export type SpeakerCompanyWhereInput = {
    AND?: SpeakerCompanyWhereInput | SpeakerCompanyWhereInput[]
    OR?: SpeakerCompanyWhereInput[]
    NOT?: SpeakerCompanyWhereInput | SpeakerCompanyWhereInput[]
    speakerId?: IntFilter<"SpeakerCompany"> | number
    companyId?: IntFilter<"SpeakerCompany"> | number
    speaker?: XOR<SpeakerScalarRelationFilter, SpeakerWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type SpeakerCompanyOrderByWithRelationInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
    speaker?: SpeakerOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type SpeakerCompanyWhereUniqueInput = Prisma.AtLeast<{
    speakerId_companyId?: SpeakerCompanySpeakerIdCompanyIdCompoundUniqueInput
    AND?: SpeakerCompanyWhereInput | SpeakerCompanyWhereInput[]
    OR?: SpeakerCompanyWhereInput[]
    NOT?: SpeakerCompanyWhereInput | SpeakerCompanyWhereInput[]
    speakerId?: IntFilter<"SpeakerCompany"> | number
    companyId?: IntFilter<"SpeakerCompany"> | number
    speaker?: XOR<SpeakerScalarRelationFilter, SpeakerWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "speakerId_companyId">

  export type SpeakerCompanyOrderByWithAggregationInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
    _count?: SpeakerCompanyCountOrderByAggregateInput
    _avg?: SpeakerCompanyAvgOrderByAggregateInput
    _max?: SpeakerCompanyMaxOrderByAggregateInput
    _min?: SpeakerCompanyMinOrderByAggregateInput
    _sum?: SpeakerCompanySumOrderByAggregateInput
  }

  export type SpeakerCompanyScalarWhereWithAggregatesInput = {
    AND?: SpeakerCompanyScalarWhereWithAggregatesInput | SpeakerCompanyScalarWhereWithAggregatesInput[]
    OR?: SpeakerCompanyScalarWhereWithAggregatesInput[]
    NOT?: SpeakerCompanyScalarWhereWithAggregatesInput | SpeakerCompanyScalarWhereWithAggregatesInput[]
    speakerId?: IntWithAggregatesFilter<"SpeakerCompany"> | number
    companyId?: IntWithAggregatesFilter<"SpeakerCompany"> | number
  }

  export type SessionSpeakerWhereInput = {
    AND?: SessionSpeakerWhereInput | SessionSpeakerWhereInput[]
    OR?: SessionSpeakerWhereInput[]
    NOT?: SessionSpeakerWhereInput | SessionSpeakerWhereInput[]
    sessionId?: IntFilter<"SessionSpeaker"> | number
    speakerId?: IntFilter<"SessionSpeaker"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    speaker?: XOR<SpeakerScalarRelationFilter, SpeakerWhereInput>
  }

  export type SessionSpeakerOrderByWithRelationInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
    session?: SessionOrderByWithRelationInput
    speaker?: SpeakerOrderByWithRelationInput
  }

  export type SessionSpeakerWhereUniqueInput = Prisma.AtLeast<{
    sessionId_speakerId?: SessionSpeakerSessionIdSpeakerIdCompoundUniqueInput
    AND?: SessionSpeakerWhereInput | SessionSpeakerWhereInput[]
    OR?: SessionSpeakerWhereInput[]
    NOT?: SessionSpeakerWhereInput | SessionSpeakerWhereInput[]
    sessionId?: IntFilter<"SessionSpeaker"> | number
    speakerId?: IntFilter<"SessionSpeaker"> | number
    session?: XOR<SessionScalarRelationFilter, SessionWhereInput>
    speaker?: XOR<SpeakerScalarRelationFilter, SpeakerWhereInput>
  }, "sessionId_speakerId">

  export type SessionSpeakerOrderByWithAggregationInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
    _count?: SessionSpeakerCountOrderByAggregateInput
    _avg?: SessionSpeakerAvgOrderByAggregateInput
    _max?: SessionSpeakerMaxOrderByAggregateInput
    _min?: SessionSpeakerMinOrderByAggregateInput
    _sum?: SessionSpeakerSumOrderByAggregateInput
  }

  export type SessionSpeakerScalarWhereWithAggregatesInput = {
    AND?: SessionSpeakerScalarWhereWithAggregatesInput | SessionSpeakerScalarWhereWithAggregatesInput[]
    OR?: SessionSpeakerScalarWhereWithAggregatesInput[]
    NOT?: SessionSpeakerScalarWhereWithAggregatesInput | SessionSpeakerScalarWhereWithAggregatesInput[]
    sessionId?: IntWithAggregatesFilter<"SessionSpeaker"> | number
    speakerId?: IntWithAggregatesFilter<"SessionSpeaker"> | number
  }

  export type SessionCreateInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionUpdateInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SessionCreateManyInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
  }

  export type SessionUpdateManyMutationInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TopicCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionTopicCreateNestedManyWithoutTopicInput
  }

  export type TopicUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionTopicUncheckedCreateNestedManyWithoutTopicInput
  }

  export type TopicUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionTopicUpdateManyWithoutTopicNestedInput
  }

  export type TopicUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionTopicUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type TopicCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type TopicUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTopicCreateInput = {
    session: SessionCreateNestedOneWithoutSessionTopicsInput
    topic: TopicCreateNestedOneWithoutSessionsInput
  }

  export type SessionTopicUncheckedCreateInput = {
    sessionId: number
    topicId: number
  }

  export type SessionTopicUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionTopicsNestedInput
    topic?: TopicUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionTopicUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTopicCreateManyInput = {
    sessionId: number
    topicId: number
  }

  export type SessionTopicUpdateManyMutationInput = {

  }

  export type SessionTopicUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type TagUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTagCreateInput = {
    session: SessionCreateNestedOneWithoutSessionTagsInput
    tag: TagCreateNestedOneWithoutSessionsInput
  }

  export type SessionTagUncheckedCreateInput = {
    sessionId: number
    tagId: number
  }

  export type SessionTagUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionTagUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTagCreateManyInput = {
    sessionId: number
    tagId: number
  }

  export type SessionTagUpdateManyMutationInput = {

  }

  export type SessionTagUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type LevelCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionLevelOnSessionCreateNestedManyWithoutLevelInput
  }

  export type LevelUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutLevelInput
  }

  export type LevelUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionLevelOnSessionUpdateManyWithoutLevelNestedInput
  }

  export type LevelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionLevelOnSessionUncheckedUpdateManyWithoutLevelNestedInput
  }

  export type LevelCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type LevelUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type LevelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionLevelOnSessionCreateInput = {
    session: SessionCreateNestedOneWithoutSessionLevelsInput
    level: LevelCreateNestedOneWithoutSessionsInput
  }

  export type SessionLevelOnSessionUncheckedCreateInput = {
    sessionId: number
    levelId: number
  }

  export type SessionLevelOnSessionUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionLevelsNestedInput
    level?: LevelUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionLevelOnSessionUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    levelId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionLevelOnSessionCreateManyInput = {
    sessionId: number
    levelId: number
  }

  export type SessionLevelOnSessionUpdateManyMutationInput = {

  }

  export type SessionLevelOnSessionUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    levelId?: IntFieldUpdateOperationsInput | number
  }

  export type AudienceTypeCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionAudienceTypeOnSessionCreateNestedManyWithoutAudienceTypeInput
  }

  export type AudienceTypeUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutAudienceTypeInput
  }

  export type AudienceTypeUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionAudienceTypeOnSessionUpdateManyWithoutAudienceTypeNestedInput
  }

  export type AudienceTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutAudienceTypeNestedInput
  }

  export type AudienceTypeCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type AudienceTypeUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type AudienceTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionAudienceTypeOnSessionCreateInput = {
    session: SessionCreateNestedOneWithoutSessionAudienceTypesInput
    audienceType: AudienceTypeCreateNestedOneWithoutSessionsInput
  }

  export type SessionAudienceTypeOnSessionUncheckedCreateInput = {
    sessionId: number
    audienceTypeId: number
  }

  export type SessionAudienceTypeOnSessionUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionAudienceTypesNestedInput
    audienceType?: AudienceTypeUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    audienceTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionAudienceTypeOnSessionCreateManyInput = {
    sessionId: number
    audienceTypeId: number
  }

  export type SessionAudienceTypeOnSessionUpdateManyMutationInput = {

  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    audienceTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type IndustryCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionIndustryOnSessionCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutIndustryInput
  }

  export type IndustryUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionIndustryOnSessionUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionIndustryOnSessionUncheckedUpdateManyWithoutIndustryNestedInput
  }

  export type IndustryCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type IndustryUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type IndustryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionIndustryOnSessionCreateInput = {
    session: SessionCreateNestedOneWithoutSessionIndustriesInput
    industry: IndustryCreateNestedOneWithoutSessionsInput
  }

  export type SessionIndustryOnSessionUncheckedCreateInput = {
    sessionId: number
    industryId: number
  }

  export type SessionIndustryOnSessionUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionIndustriesNestedInput
    industry?: IndustryUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionIndustryOnSessionUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    industryId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionIndustryOnSessionCreateManyInput = {
    sessionId: number
    industryId: number
  }

  export type SessionIndustryOnSessionUpdateManyMutationInput = {

  }

  export type SessionIndustryOnSessionUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    industryId?: IntFieldUpdateOperationsInput | number
  }

  export type DeliveryTypeCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutDeliveryTypeInput
  }

  export type DeliveryTypeUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutDeliveryTypeInput
  }

  export type DeliveryTypeUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionDeliveryTypeOnSessionUpdateManyWithoutDeliveryTypeNestedInput
  }

  export type DeliveryTypeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutDeliveryTypeNestedInput
  }

  export type DeliveryTypeCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type DeliveryTypeUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryTypeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionDeliveryTypeOnSessionCreateInput = {
    session: SessionCreateNestedOneWithoutSessionDeliveryTypesInput
    deliveryType: DeliveryTypeCreateNestedOneWithoutSessionsInput
  }

  export type SessionDeliveryTypeOnSessionUncheckedCreateInput = {
    sessionId: number
    deliveryTypeId: number
  }

  export type SessionDeliveryTypeOnSessionUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionDeliveryTypesNestedInput
    deliveryType?: DeliveryTypeUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    deliveryTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionDeliveryTypeOnSessionCreateManyInput = {
    sessionId: number
    deliveryTypeId: number
  }

  export type SessionDeliveryTypeOnSessionUpdateManyMutationInput = {

  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    deliveryTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type ViewingOptionCreateInput = {
    logicalValue: string
    displayValue: string
    sessions?: SessionViewingOptionOnSessionCreateNestedManyWithoutViewingOptionInput
  }

  export type ViewingOptionUncheckedCreateInput = {
    id?: number
    logicalValue: string
    displayValue: string
    sessions?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutViewingOptionInput
  }

  export type ViewingOptionUpdateInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionViewingOptionOnSessionUpdateManyWithoutViewingOptionNestedInput
  }

  export type ViewingOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
    sessions?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutViewingOptionNestedInput
  }

  export type ViewingOptionCreateManyInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type ViewingOptionUpdateManyMutationInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type ViewingOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionViewingOptionOnSessionCreateInput = {
    session: SessionCreateNestedOneWithoutSessionViewingOptsInput
    viewingOption: ViewingOptionCreateNestedOneWithoutSessionsInput
  }

  export type SessionViewingOptionOnSessionUncheckedCreateInput = {
    sessionId: number
    viewingOptionId: number
  }

  export type SessionViewingOptionOnSessionUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionViewingOptsNestedInput
    viewingOption?: ViewingOptionUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    viewingOptionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionViewingOptionOnSessionCreateManyInput = {
    sessionId: number
    viewingOptionId: number
  }

  export type SessionViewingOptionOnSessionUpdateManyMutationInput = {

  }

  export type SessionViewingOptionOnSessionUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    viewingOptionId?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakerCreateInput = {
    speakerId: string
    name: string
    company?: string | null
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSpeakerInput
    speakerCompanies?: SpeakerCompanyCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUncheckedCreateInput = {
    id?: number
    speakerId: string
    name: string
    company?: string | null
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSpeakerInput
    speakerCompanies?: SpeakerCompanyUncheckedCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUpdateInput = {
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSpeakerNestedInput
    speakerCompanies?: SpeakerCompanyUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSpeakerNestedInput
    speakerCompanies?: SpeakerCompanyUncheckedUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerCreateManyInput = {
    id?: number
    speakerId: string
    name: string
    company?: string | null
  }

  export type SpeakerUpdateManyMutationInput = {
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpeakerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateInput = {
    name: string
    speakerCompanies?: SpeakerCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: number
    name: string
    speakerCompanies?: SpeakerCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    speakerCompanies?: SpeakerCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    speakerCompanies?: SpeakerCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: number
    name: string
  }

  export type CompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SpeakerCompanyCreateInput = {
    speaker: SpeakerCreateNestedOneWithoutSpeakerCompaniesInput
    company: CompanyCreateNestedOneWithoutSpeakerCompaniesInput
  }

  export type SpeakerCompanyUncheckedCreateInput = {
    speakerId: number
    companyId: number
  }

  export type SpeakerCompanyUpdateInput = {
    speaker?: SpeakerUpdateOneRequiredWithoutSpeakerCompaniesNestedInput
    company?: CompanyUpdateOneRequiredWithoutSpeakerCompaniesNestedInput
  }

  export type SpeakerCompanyUncheckedUpdateInput = {
    speakerId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakerCompanyCreateManyInput = {
    speakerId: number
    companyId: number
  }

  export type SpeakerCompanyUpdateManyMutationInput = {

  }

  export type SpeakerCompanyUncheckedUpdateManyInput = {
    speakerId?: IntFieldUpdateOperationsInput | number
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionSpeakerCreateInput = {
    session: SessionCreateNestedOneWithoutSessionSpeakersInput
    speaker: SpeakerCreateNestedOneWithoutSessionSpeakersInput
  }

  export type SessionSpeakerUncheckedCreateInput = {
    sessionId: number
    speakerId: number
  }

  export type SessionSpeakerUpdateInput = {
    session?: SessionUpdateOneRequiredWithoutSessionSpeakersNestedInput
    speaker?: SpeakerUpdateOneRequiredWithoutSessionSpeakersNestedInput
  }

  export type SessionSpeakerUncheckedUpdateInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    speakerId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionSpeakerCreateManyInput = {
    sessionId: number
    speakerId: number
  }

  export type SessionSpeakerUpdateManyMutationInput = {

  }

  export type SessionSpeakerUncheckedUpdateManyInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
    speakerId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SessionTopicListRelationFilter = {
    every?: SessionTopicWhereInput
    some?: SessionTopicWhereInput
    none?: SessionTopicWhereInput
  }

  export type SessionTagListRelationFilter = {
    every?: SessionTagWhereInput
    some?: SessionTagWhereInput
    none?: SessionTagWhereInput
  }

  export type SessionLevelOnSessionListRelationFilter = {
    every?: SessionLevelOnSessionWhereInput
    some?: SessionLevelOnSessionWhereInput
    none?: SessionLevelOnSessionWhereInput
  }

  export type SessionAudienceTypeOnSessionListRelationFilter = {
    every?: SessionAudienceTypeOnSessionWhereInput
    some?: SessionAudienceTypeOnSessionWhereInput
    none?: SessionAudienceTypeOnSessionWhereInput
  }

  export type SessionIndustryOnSessionListRelationFilter = {
    every?: SessionIndustryOnSessionWhereInput
    some?: SessionIndustryOnSessionWhereInput
    none?: SessionIndustryOnSessionWhereInput
  }

  export type SessionDeliveryTypeOnSessionListRelationFilter = {
    every?: SessionDeliveryTypeOnSessionWhereInput
    some?: SessionDeliveryTypeOnSessionWhereInput
    none?: SessionDeliveryTypeOnSessionWhereInput
  }

  export type SessionViewingOptionOnSessionListRelationFilter = {
    every?: SessionViewingOptionOnSessionWhereInput
    some?: SessionViewingOptionOnSessionWhereInput
    none?: SessionViewingOptionOnSessionWhereInput
  }

  export type SessionSpeakerListRelationFilter = {
    every?: SessionSpeakerWhereInput
    some?: SessionSpeakerWhereInput
    none?: SessionSpeakerWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionTopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionLevelOnSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionAudienceTypeOnSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionIndustryOnSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionDeliveryTypeOnSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionViewingOptionOnSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionSpeakerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionInstanceId?: SortOrder
    localizedId?: SortOrder
    sessionCode?: SortOrder
    langLocale?: SortOrder
    title?: SortOrder
    sortTitle?: SortOrder
    description?: SortOrder
    aiDescription?: SortOrder
    location?: SortOrder
    timeSlot?: SortOrder
    startDateTime?: SortOrder
    endDateTime?: SortOrder
    durationInMinutes?: SortOrder
    sessionTypeDisplay?: SortOrder
    sessionTypeLogical?: SortOrder
    reportingTopic?: SortOrder
    onDemandUrl?: SortOrder
    downloadVideoUrl?: SortOrder
    captionFileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    registrationLink?: SortOrder
    hasOnDemand?: SortOrder
    isPopular?: SortOrder
    heroSession?: SortOrder
  }

  export type SessionAvgOrderByAggregateInput = {
    id?: SortOrder
    durationInMinutes?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionInstanceId?: SortOrder
    localizedId?: SortOrder
    sessionCode?: SortOrder
    langLocale?: SortOrder
    title?: SortOrder
    sortTitle?: SortOrder
    description?: SortOrder
    aiDescription?: SortOrder
    location?: SortOrder
    timeSlot?: SortOrder
    startDateTime?: SortOrder
    endDateTime?: SortOrder
    durationInMinutes?: SortOrder
    sessionTypeDisplay?: SortOrder
    sessionTypeLogical?: SortOrder
    reportingTopic?: SortOrder
    onDemandUrl?: SortOrder
    downloadVideoUrl?: SortOrder
    captionFileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    registrationLink?: SortOrder
    hasOnDemand?: SortOrder
    isPopular?: SortOrder
    heroSession?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    sessionInstanceId?: SortOrder
    localizedId?: SortOrder
    sessionCode?: SortOrder
    langLocale?: SortOrder
    title?: SortOrder
    sortTitle?: SortOrder
    description?: SortOrder
    aiDescription?: SortOrder
    location?: SortOrder
    timeSlot?: SortOrder
    startDateTime?: SortOrder
    endDateTime?: SortOrder
    durationInMinutes?: SortOrder
    sessionTypeDisplay?: SortOrder
    sessionTypeLogical?: SortOrder
    reportingTopic?: SortOrder
    onDemandUrl?: SortOrder
    downloadVideoUrl?: SortOrder
    captionFileUrl?: SortOrder
    thumbnailUrl?: SortOrder
    registrationLink?: SortOrder
    hasOnDemand?: SortOrder
    isPopular?: SortOrder
    heroSession?: SortOrder
  }

  export type SessionSumOrderByAggregateInput = {
    id?: SortOrder
    durationInMinutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TopicCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type TopicAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TopicMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type TopicMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type TopicSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessionScalarRelationFilter = {
    is?: SessionWhereInput
    isNot?: SessionWhereInput
  }

  export type TopicScalarRelationFilter = {
    is?: TopicWhereInput
    isNot?: TopicWhereInput
  }

  export type SessionTopicSessionIdTopicIdCompoundUniqueInput = {
    sessionId: number
    topicId: number
  }

  export type SessionTopicCountOrderByAggregateInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
  }

  export type SessionTopicAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
  }

  export type SessionTopicMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
  }

  export type SessionTopicMinOrderByAggregateInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
  }

  export type SessionTopicSumOrderByAggregateInput = {
    sessionId?: SortOrder
    topicId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type SessionTagSessionIdTagIdCompoundUniqueInput = {
    sessionId: number
    tagId: number
  }

  export type SessionTagCountOrderByAggregateInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
  }

  export type SessionTagAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
  }

  export type SessionTagMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
  }

  export type SessionTagMinOrderByAggregateInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
  }

  export type SessionTagSumOrderByAggregateInput = {
    sessionId?: SortOrder
    tagId?: SortOrder
  }

  export type LevelCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type LevelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LevelMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type LevelMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type LevelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LevelScalarRelationFilter = {
    is?: LevelWhereInput
    isNot?: LevelWhereInput
  }

  export type SessionLevelOnSessionSessionIdLevelIdCompoundUniqueInput = {
    sessionId: number
    levelId: number
  }

  export type SessionLevelOnSessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
  }

  export type SessionLevelOnSessionAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
  }

  export type SessionLevelOnSessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
  }

  export type SessionLevelOnSessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
  }

  export type SessionLevelOnSessionSumOrderByAggregateInput = {
    sessionId?: SortOrder
    levelId?: SortOrder
  }

  export type AudienceTypeCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type AudienceTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AudienceTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type AudienceTypeMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type AudienceTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AudienceTypeScalarRelationFilter = {
    is?: AudienceTypeWhereInput
    isNot?: AudienceTypeWhereInput
  }

  export type SessionAudienceTypeOnSessionSessionIdAudienceTypeIdCompoundUniqueInput = {
    sessionId: number
    audienceTypeId: number
  }

  export type SessionAudienceTypeOnSessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
  }

  export type SessionAudienceTypeOnSessionAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
  }

  export type SessionAudienceTypeOnSessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
  }

  export type SessionAudienceTypeOnSessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
  }

  export type SessionAudienceTypeOnSessionSumOrderByAggregateInput = {
    sessionId?: SortOrder
    audienceTypeId?: SortOrder
  }

  export type IndustryCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type IndustryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IndustryMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type IndustryMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type IndustrySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IndustryScalarRelationFilter = {
    is?: IndustryWhereInput
    isNot?: IndustryWhereInput
  }

  export type SessionIndustryOnSessionSessionIdIndustryIdCompoundUniqueInput = {
    sessionId: number
    industryId: number
  }

  export type SessionIndustryOnSessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
  }

  export type SessionIndustryOnSessionAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
  }

  export type SessionIndustryOnSessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
  }

  export type SessionIndustryOnSessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
  }

  export type SessionIndustryOnSessionSumOrderByAggregateInput = {
    sessionId?: SortOrder
    industryId?: SortOrder
  }

  export type DeliveryTypeCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type DeliveryTypeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeliveryTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type DeliveryTypeMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type DeliveryTypeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DeliveryTypeScalarRelationFilter = {
    is?: DeliveryTypeWhereInput
    isNot?: DeliveryTypeWhereInput
  }

  export type SessionDeliveryTypeOnSessionSessionIdDeliveryTypeIdCompoundUniqueInput = {
    sessionId: number
    deliveryTypeId: number
  }

  export type SessionDeliveryTypeOnSessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
  }

  export type SessionDeliveryTypeOnSessionAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
  }

  export type SessionDeliveryTypeOnSessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
  }

  export type SessionDeliveryTypeOnSessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
  }

  export type SessionDeliveryTypeOnSessionSumOrderByAggregateInput = {
    sessionId?: SortOrder
    deliveryTypeId?: SortOrder
  }

  export type ViewingOptionCountOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type ViewingOptionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ViewingOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type ViewingOptionMinOrderByAggregateInput = {
    id?: SortOrder
    logicalValue?: SortOrder
    displayValue?: SortOrder
  }

  export type ViewingOptionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ViewingOptionScalarRelationFilter = {
    is?: ViewingOptionWhereInput
    isNot?: ViewingOptionWhereInput
  }

  export type SessionViewingOptionOnSessionSessionIdViewingOptionIdCompoundUniqueInput = {
    sessionId: number
    viewingOptionId: number
  }

  export type SessionViewingOptionOnSessionCountOrderByAggregateInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
  }

  export type SessionViewingOptionOnSessionAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
  }

  export type SessionViewingOptionOnSessionMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
  }

  export type SessionViewingOptionOnSessionMinOrderByAggregateInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
  }

  export type SessionViewingOptionOnSessionSumOrderByAggregateInput = {
    sessionId?: SortOrder
    viewingOptionId?: SortOrder
  }

  export type SpeakerCompanyListRelationFilter = {
    every?: SpeakerCompanyWhereInput
    some?: SpeakerCompanyWhereInput
    none?: SpeakerCompanyWhereInput
  }

  export type SpeakerCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpeakerCountOrderByAggregateInput = {
    id?: SortOrder
    speakerId?: SortOrder
    name?: SortOrder
    company?: SortOrder
  }

  export type SpeakerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerMaxOrderByAggregateInput = {
    id?: SortOrder
    speakerId?: SortOrder
    name?: SortOrder
    company?: SortOrder
  }

  export type SpeakerMinOrderByAggregateInput = {
    id?: SortOrder
    speakerId?: SortOrder
    name?: SortOrder
    company?: SortOrder
  }

  export type SpeakerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CompanyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CompanySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SpeakerScalarRelationFilter = {
    is?: SpeakerWhereInput
    isNot?: SpeakerWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type SpeakerCompanySpeakerIdCompanyIdCompoundUniqueInput = {
    speakerId: number
    companyId: number
  }

  export type SpeakerCompanyCountOrderByAggregateInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
  }

  export type SpeakerCompanyAvgOrderByAggregateInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
  }

  export type SpeakerCompanyMaxOrderByAggregateInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
  }

  export type SpeakerCompanyMinOrderByAggregateInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
  }

  export type SpeakerCompanySumOrderByAggregateInput = {
    speakerId?: SortOrder
    companyId?: SortOrder
  }

  export type SessionSpeakerSessionIdSpeakerIdCompoundUniqueInput = {
    sessionId: number
    speakerId: number
  }

  export type SessionSpeakerCountOrderByAggregateInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SessionSpeakerAvgOrderByAggregateInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SessionSpeakerMaxOrderByAggregateInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SessionSpeakerMinOrderByAggregateInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SessionSpeakerSumOrderByAggregateInput = {
    sessionId?: SortOrder
    speakerId?: SortOrder
  }

  export type SessionTopicCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTopicCreateWithoutSessionInput, SessionTopicUncheckedCreateWithoutSessionInput> | SessionTopicCreateWithoutSessionInput[] | SessionTopicUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutSessionInput | SessionTopicCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTopicCreateManySessionInputEnvelope
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
  }

  export type SessionTagCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
  }

  export type SessionLevelOnSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutSessionInput, SessionLevelOnSessionUncheckedCreateWithoutSessionInput> | SessionLevelOnSessionCreateWithoutSessionInput[] | SessionLevelOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutSessionInput | SessionLevelOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionLevelOnSessionCreateManySessionInputEnvelope
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
  }

  export type SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionAudienceTypeOnSessionCreateWithoutSessionInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManySessionInputEnvelope
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
  }

  export type SessionIndustryOnSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutSessionInput, SessionIndustryOnSessionUncheckedCreateWithoutSessionInput> | SessionIndustryOnSessionCreateWithoutSessionInput[] | SessionIndustryOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutSessionInput | SessionIndustryOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionIndustryOnSessionCreateManySessionInputEnvelope
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
  }

  export type SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionDeliveryTypeOnSessionCreateWithoutSessionInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManySessionInputEnvelope
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
  }

  export type SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput> | SessionViewingOptionOnSessionCreateWithoutSessionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManySessionInputEnvelope
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
  }

  export type SessionSpeakerCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionSpeakerCreateWithoutSessionInput, SessionSpeakerUncheckedCreateWithoutSessionInput> | SessionSpeakerCreateWithoutSessionInput[] | SessionSpeakerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSessionInput | SessionSpeakerCreateOrConnectWithoutSessionInput[]
    createMany?: SessionSpeakerCreateManySessionInputEnvelope
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
  }

  export type SessionTopicUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTopicCreateWithoutSessionInput, SessionTopicUncheckedCreateWithoutSessionInput> | SessionTopicCreateWithoutSessionInput[] | SessionTopicUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutSessionInput | SessionTopicCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTopicCreateManySessionInputEnvelope
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
  }

  export type SessionTagUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
  }

  export type SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutSessionInput, SessionLevelOnSessionUncheckedCreateWithoutSessionInput> | SessionLevelOnSessionCreateWithoutSessionInput[] | SessionLevelOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutSessionInput | SessionLevelOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionLevelOnSessionCreateManySessionInputEnvelope
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
  }

  export type SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionAudienceTypeOnSessionCreateWithoutSessionInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManySessionInputEnvelope
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
  }

  export type SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutSessionInput, SessionIndustryOnSessionUncheckedCreateWithoutSessionInput> | SessionIndustryOnSessionCreateWithoutSessionInput[] | SessionIndustryOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutSessionInput | SessionIndustryOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionIndustryOnSessionCreateManySessionInputEnvelope
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
  }

  export type SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionDeliveryTypeOnSessionCreateWithoutSessionInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManySessionInputEnvelope
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
  }

  export type SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput> | SessionViewingOptionOnSessionCreateWithoutSessionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManySessionInputEnvelope
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
  }

  export type SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<SessionSpeakerCreateWithoutSessionInput, SessionSpeakerUncheckedCreateWithoutSessionInput> | SessionSpeakerCreateWithoutSessionInput[] | SessionSpeakerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSessionInput | SessionSpeakerCreateOrConnectWithoutSessionInput[]
    createMany?: SessionSpeakerCreateManySessionInputEnvelope
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type SessionTopicUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTopicCreateWithoutSessionInput, SessionTopicUncheckedCreateWithoutSessionInput> | SessionTopicCreateWithoutSessionInput[] | SessionTopicUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutSessionInput | SessionTopicCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTopicUpsertWithWhereUniqueWithoutSessionInput | SessionTopicUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTopicCreateManySessionInputEnvelope
    set?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    disconnect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    delete?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    update?: SessionTopicUpdateWithWhereUniqueWithoutSessionInput | SessionTopicUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTopicUpdateManyWithWhereWithoutSessionInput | SessionTopicUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTopicScalarWhereInput | SessionTopicScalarWhereInput[]
  }

  export type SessionTagUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTagUpsertWithWhereUniqueWithoutSessionInput | SessionTagUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    set?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    disconnect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    delete?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    update?: SessionTagUpdateWithWhereUniqueWithoutSessionInput | SessionTagUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTagUpdateManyWithWhereWithoutSessionInput | SessionTagUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
  }

  export type SessionLevelOnSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutSessionInput, SessionLevelOnSessionUncheckedCreateWithoutSessionInput> | SessionLevelOnSessionCreateWithoutSessionInput[] | SessionLevelOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutSessionInput | SessionLevelOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionLevelOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionLevelOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionLevelOnSessionCreateManySessionInputEnvelope
    set?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    disconnect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    delete?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    update?: SessionLevelOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionLevelOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionLevelOnSessionUpdateManyWithWhereWithoutSessionInput | SessionLevelOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionLevelOnSessionScalarWhereInput | SessionLevelOnSessionScalarWhereInput[]
  }

  export type SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionAudienceTypeOnSessionCreateWithoutSessionInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManySessionInputEnvelope
    set?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    delete?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    update?: SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutSessionInput | SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionAudienceTypeOnSessionScalarWhereInput | SessionAudienceTypeOnSessionScalarWhereInput[]
  }

  export type SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutSessionInput, SessionIndustryOnSessionUncheckedCreateWithoutSessionInput> | SessionIndustryOnSessionCreateWithoutSessionInput[] | SessionIndustryOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutSessionInput | SessionIndustryOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionIndustryOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionIndustryOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionIndustryOnSessionCreateManySessionInputEnvelope
    set?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    disconnect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    delete?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    update?: SessionIndustryOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionIndustryOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionIndustryOnSessionUpdateManyWithWhereWithoutSessionInput | SessionIndustryOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionIndustryOnSessionScalarWhereInput | SessionIndustryOnSessionScalarWhereInput[]
  }

  export type SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionDeliveryTypeOnSessionCreateWithoutSessionInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManySessionInputEnvelope
    set?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    delete?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    update?: SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutSessionInput | SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionDeliveryTypeOnSessionScalarWhereInput | SessionDeliveryTypeOnSessionScalarWhereInput[]
  }

  export type SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput> | SessionViewingOptionOnSessionCreateWithoutSessionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManySessionInputEnvelope
    set?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    disconnect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    delete?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    update?: SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionViewingOptionOnSessionUpdateManyWithWhereWithoutSessionInput | SessionViewingOptionOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionViewingOptionOnSessionScalarWhereInput | SessionViewingOptionOnSessionScalarWhereInput[]
  }

  export type SessionSpeakerUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionSpeakerCreateWithoutSessionInput, SessionSpeakerUncheckedCreateWithoutSessionInput> | SessionSpeakerCreateWithoutSessionInput[] | SessionSpeakerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSessionInput | SessionSpeakerCreateOrConnectWithoutSessionInput[]
    upsert?: SessionSpeakerUpsertWithWhereUniqueWithoutSessionInput | SessionSpeakerUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionSpeakerCreateManySessionInputEnvelope
    set?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    disconnect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    delete?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    update?: SessionSpeakerUpdateWithWhereUniqueWithoutSessionInput | SessionSpeakerUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionSpeakerUpdateManyWithWhereWithoutSessionInput | SessionSpeakerUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionSpeakerScalarWhereInput | SessionSpeakerScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SessionTopicUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTopicCreateWithoutSessionInput, SessionTopicUncheckedCreateWithoutSessionInput> | SessionTopicCreateWithoutSessionInput[] | SessionTopicUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutSessionInput | SessionTopicCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTopicUpsertWithWhereUniqueWithoutSessionInput | SessionTopicUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTopicCreateManySessionInputEnvelope
    set?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    disconnect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    delete?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    update?: SessionTopicUpdateWithWhereUniqueWithoutSessionInput | SessionTopicUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTopicUpdateManyWithWhereWithoutSessionInput | SessionTopicUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTopicScalarWhereInput | SessionTopicScalarWhereInput[]
  }

  export type SessionTagUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput> | SessionTagCreateWithoutSessionInput[] | SessionTagUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutSessionInput | SessionTagCreateOrConnectWithoutSessionInput[]
    upsert?: SessionTagUpsertWithWhereUniqueWithoutSessionInput | SessionTagUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionTagCreateManySessionInputEnvelope
    set?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    disconnect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    delete?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    update?: SessionTagUpdateWithWhereUniqueWithoutSessionInput | SessionTagUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionTagUpdateManyWithWhereWithoutSessionInput | SessionTagUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
  }

  export type SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutSessionInput, SessionLevelOnSessionUncheckedCreateWithoutSessionInput> | SessionLevelOnSessionCreateWithoutSessionInput[] | SessionLevelOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutSessionInput | SessionLevelOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionLevelOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionLevelOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionLevelOnSessionCreateManySessionInputEnvelope
    set?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    disconnect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    delete?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    update?: SessionLevelOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionLevelOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionLevelOnSessionUpdateManyWithWhereWithoutSessionInput | SessionLevelOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionLevelOnSessionScalarWhereInput | SessionLevelOnSessionScalarWhereInput[]
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionAudienceTypeOnSessionCreateWithoutSessionInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManySessionInputEnvelope
    set?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    delete?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    update?: SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutSessionInput | SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionAudienceTypeOnSessionScalarWhereInput | SessionAudienceTypeOnSessionScalarWhereInput[]
  }

  export type SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutSessionInput, SessionIndustryOnSessionUncheckedCreateWithoutSessionInput> | SessionIndustryOnSessionCreateWithoutSessionInput[] | SessionIndustryOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutSessionInput | SessionIndustryOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionIndustryOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionIndustryOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionIndustryOnSessionCreateManySessionInputEnvelope
    set?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    disconnect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    delete?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    update?: SessionIndustryOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionIndustryOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionIndustryOnSessionUpdateManyWithWhereWithoutSessionInput | SessionIndustryOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionIndustryOnSessionScalarWhereInput | SessionIndustryOnSessionScalarWhereInput[]
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput> | SessionDeliveryTypeOnSessionCreateWithoutSessionInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManySessionInputEnvelope
    set?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    delete?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    update?: SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutSessionInput | SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionDeliveryTypeOnSessionScalarWhereInput | SessionDeliveryTypeOnSessionScalarWhereInput[]
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput> | SessionViewingOptionOnSessionCreateWithoutSessionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput[]
    upsert?: SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutSessionInput | SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManySessionInputEnvelope
    set?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    disconnect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    delete?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    update?: SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutSessionInput | SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionViewingOptionOnSessionUpdateManyWithWhereWithoutSessionInput | SessionViewingOptionOnSessionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionViewingOptionOnSessionScalarWhereInput | SessionViewingOptionOnSessionScalarWhereInput[]
  }

  export type SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<SessionSpeakerCreateWithoutSessionInput, SessionSpeakerUncheckedCreateWithoutSessionInput> | SessionSpeakerCreateWithoutSessionInput[] | SessionSpeakerUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSessionInput | SessionSpeakerCreateOrConnectWithoutSessionInput[]
    upsert?: SessionSpeakerUpsertWithWhereUniqueWithoutSessionInput | SessionSpeakerUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: SessionSpeakerCreateManySessionInputEnvelope
    set?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    disconnect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    delete?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    update?: SessionSpeakerUpdateWithWhereUniqueWithoutSessionInput | SessionSpeakerUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: SessionSpeakerUpdateManyWithWhereWithoutSessionInput | SessionSpeakerUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: SessionSpeakerScalarWhereInput | SessionSpeakerScalarWhereInput[]
  }

  export type SessionTopicCreateNestedManyWithoutTopicInput = {
    create?: XOR<SessionTopicCreateWithoutTopicInput, SessionTopicUncheckedCreateWithoutTopicInput> | SessionTopicCreateWithoutTopicInput[] | SessionTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutTopicInput | SessionTopicCreateOrConnectWithoutTopicInput[]
    createMany?: SessionTopicCreateManyTopicInputEnvelope
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
  }

  export type SessionTopicUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<SessionTopicCreateWithoutTopicInput, SessionTopicUncheckedCreateWithoutTopicInput> | SessionTopicCreateWithoutTopicInput[] | SessionTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutTopicInput | SessionTopicCreateOrConnectWithoutTopicInput[]
    createMany?: SessionTopicCreateManyTopicInputEnvelope
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
  }

  export type SessionTopicUpdateManyWithoutTopicNestedInput = {
    create?: XOR<SessionTopicCreateWithoutTopicInput, SessionTopicUncheckedCreateWithoutTopicInput> | SessionTopicCreateWithoutTopicInput[] | SessionTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutTopicInput | SessionTopicCreateOrConnectWithoutTopicInput[]
    upsert?: SessionTopicUpsertWithWhereUniqueWithoutTopicInput | SessionTopicUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: SessionTopicCreateManyTopicInputEnvelope
    set?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    disconnect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    delete?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    update?: SessionTopicUpdateWithWhereUniqueWithoutTopicInput | SessionTopicUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: SessionTopicUpdateManyWithWhereWithoutTopicInput | SessionTopicUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: SessionTopicScalarWhereInput | SessionTopicScalarWhereInput[]
  }

  export type SessionTopicUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<SessionTopicCreateWithoutTopicInput, SessionTopicUncheckedCreateWithoutTopicInput> | SessionTopicCreateWithoutTopicInput[] | SessionTopicUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: SessionTopicCreateOrConnectWithoutTopicInput | SessionTopicCreateOrConnectWithoutTopicInput[]
    upsert?: SessionTopicUpsertWithWhereUniqueWithoutTopicInput | SessionTopicUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: SessionTopicCreateManyTopicInputEnvelope
    set?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    disconnect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    delete?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    connect?: SessionTopicWhereUniqueInput | SessionTopicWhereUniqueInput[]
    update?: SessionTopicUpdateWithWhereUniqueWithoutTopicInput | SessionTopicUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: SessionTopicUpdateManyWithWhereWithoutTopicInput | SessionTopicUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: SessionTopicScalarWhereInput | SessionTopicScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionTopicsInput = {
    create?: XOR<SessionCreateWithoutSessionTopicsInput, SessionUncheckedCreateWithoutSessionTopicsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionTopicsInput
    connect?: SessionWhereUniqueInput
  }

  export type TopicCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TopicCreateWithoutSessionsInput, TopicUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutSessionsInput
    connect?: TopicWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionTopicsNestedInput = {
    create?: XOR<SessionCreateWithoutSessionTopicsInput, SessionUncheckedCreateWithoutSessionTopicsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionTopicsInput
    upsert?: SessionUpsertWithoutSessionTopicsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionTopicsInput, SessionUpdateWithoutSessionTopicsInput>, SessionUncheckedUpdateWithoutSessionTopicsInput>
  }

  export type TopicUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TopicCreateWithoutSessionsInput, TopicUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TopicCreateOrConnectWithoutSessionsInput
    upsert?: TopicUpsertWithoutSessionsInput
    connect?: TopicWhereUniqueInput
    update?: XOR<XOR<TopicUpdateToOneWithWhereWithoutSessionsInput, TopicUpdateWithoutSessionsInput>, TopicUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionTagCreateNestedManyWithoutTagInput = {
    create?: XOR<SessionTagCreateWithoutTagInput, SessionTagUncheckedCreateWithoutTagInput> | SessionTagCreateWithoutTagInput[] | SessionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutTagInput | SessionTagCreateOrConnectWithoutTagInput[]
    createMany?: SessionTagCreateManyTagInputEnvelope
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
  }

  export type SessionTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<SessionTagCreateWithoutTagInput, SessionTagUncheckedCreateWithoutTagInput> | SessionTagCreateWithoutTagInput[] | SessionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutTagInput | SessionTagCreateOrConnectWithoutTagInput[]
    createMany?: SessionTagCreateManyTagInputEnvelope
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
  }

  export type SessionTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<SessionTagCreateWithoutTagInput, SessionTagUncheckedCreateWithoutTagInput> | SessionTagCreateWithoutTagInput[] | SessionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutTagInput | SessionTagCreateOrConnectWithoutTagInput[]
    upsert?: SessionTagUpsertWithWhereUniqueWithoutTagInput | SessionTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: SessionTagCreateManyTagInputEnvelope
    set?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    disconnect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    delete?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    update?: SessionTagUpdateWithWhereUniqueWithoutTagInput | SessionTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: SessionTagUpdateManyWithWhereWithoutTagInput | SessionTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
  }

  export type SessionTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<SessionTagCreateWithoutTagInput, SessionTagUncheckedCreateWithoutTagInput> | SessionTagCreateWithoutTagInput[] | SessionTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: SessionTagCreateOrConnectWithoutTagInput | SessionTagCreateOrConnectWithoutTagInput[]
    upsert?: SessionTagUpsertWithWhereUniqueWithoutTagInput | SessionTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: SessionTagCreateManyTagInputEnvelope
    set?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    disconnect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    delete?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    connect?: SessionTagWhereUniqueInput | SessionTagWhereUniqueInput[]
    update?: SessionTagUpdateWithWhereUniqueWithoutTagInput | SessionTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: SessionTagUpdateManyWithWhereWithoutTagInput | SessionTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionTagsInput = {
    create?: XOR<SessionCreateWithoutSessionTagsInput, SessionUncheckedCreateWithoutSessionTagsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionTagsInput
    connect?: SessionWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TagCreateWithoutSessionsInput, TagUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TagCreateOrConnectWithoutSessionsInput
    connect?: TagWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionTagsNestedInput = {
    create?: XOR<SessionCreateWithoutSessionTagsInput, SessionUncheckedCreateWithoutSessionTagsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionTagsInput
    upsert?: SessionUpsertWithoutSessionTagsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionTagsInput, SessionUpdateWithoutSessionTagsInput>, SessionUncheckedUpdateWithoutSessionTagsInput>
  }

  export type TagUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TagCreateWithoutSessionsInput, TagUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TagCreateOrConnectWithoutSessionsInput
    upsert?: TagUpsertWithoutSessionsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutSessionsInput, TagUpdateWithoutSessionsInput>, TagUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionLevelOnSessionCreateNestedManyWithoutLevelInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutLevelInput, SessionLevelOnSessionUncheckedCreateWithoutLevelInput> | SessionLevelOnSessionCreateWithoutLevelInput[] | SessionLevelOnSessionUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutLevelInput | SessionLevelOnSessionCreateOrConnectWithoutLevelInput[]
    createMany?: SessionLevelOnSessionCreateManyLevelInputEnvelope
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
  }

  export type SessionLevelOnSessionUncheckedCreateNestedManyWithoutLevelInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutLevelInput, SessionLevelOnSessionUncheckedCreateWithoutLevelInput> | SessionLevelOnSessionCreateWithoutLevelInput[] | SessionLevelOnSessionUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutLevelInput | SessionLevelOnSessionCreateOrConnectWithoutLevelInput[]
    createMany?: SessionLevelOnSessionCreateManyLevelInputEnvelope
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
  }

  export type SessionLevelOnSessionUpdateManyWithoutLevelNestedInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutLevelInput, SessionLevelOnSessionUncheckedCreateWithoutLevelInput> | SessionLevelOnSessionCreateWithoutLevelInput[] | SessionLevelOnSessionUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutLevelInput | SessionLevelOnSessionCreateOrConnectWithoutLevelInput[]
    upsert?: SessionLevelOnSessionUpsertWithWhereUniqueWithoutLevelInput | SessionLevelOnSessionUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: SessionLevelOnSessionCreateManyLevelInputEnvelope
    set?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    disconnect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    delete?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    update?: SessionLevelOnSessionUpdateWithWhereUniqueWithoutLevelInput | SessionLevelOnSessionUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: SessionLevelOnSessionUpdateManyWithWhereWithoutLevelInput | SessionLevelOnSessionUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: SessionLevelOnSessionScalarWhereInput | SessionLevelOnSessionScalarWhereInput[]
  }

  export type SessionLevelOnSessionUncheckedUpdateManyWithoutLevelNestedInput = {
    create?: XOR<SessionLevelOnSessionCreateWithoutLevelInput, SessionLevelOnSessionUncheckedCreateWithoutLevelInput> | SessionLevelOnSessionCreateWithoutLevelInput[] | SessionLevelOnSessionUncheckedCreateWithoutLevelInput[]
    connectOrCreate?: SessionLevelOnSessionCreateOrConnectWithoutLevelInput | SessionLevelOnSessionCreateOrConnectWithoutLevelInput[]
    upsert?: SessionLevelOnSessionUpsertWithWhereUniqueWithoutLevelInput | SessionLevelOnSessionUpsertWithWhereUniqueWithoutLevelInput[]
    createMany?: SessionLevelOnSessionCreateManyLevelInputEnvelope
    set?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    disconnect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    delete?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    connect?: SessionLevelOnSessionWhereUniqueInput | SessionLevelOnSessionWhereUniqueInput[]
    update?: SessionLevelOnSessionUpdateWithWhereUniqueWithoutLevelInput | SessionLevelOnSessionUpdateWithWhereUniqueWithoutLevelInput[]
    updateMany?: SessionLevelOnSessionUpdateManyWithWhereWithoutLevelInput | SessionLevelOnSessionUpdateManyWithWhereWithoutLevelInput[]
    deleteMany?: SessionLevelOnSessionScalarWhereInput | SessionLevelOnSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionLevelsInput = {
    create?: XOR<SessionCreateWithoutSessionLevelsInput, SessionUncheckedCreateWithoutSessionLevelsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionLevelsInput
    connect?: SessionWhereUniqueInput
  }

  export type LevelCreateNestedOneWithoutSessionsInput = {
    create?: XOR<LevelCreateWithoutSessionsInput, LevelUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutSessionsInput
    connect?: LevelWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionLevelsNestedInput = {
    create?: XOR<SessionCreateWithoutSessionLevelsInput, SessionUncheckedCreateWithoutSessionLevelsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionLevelsInput
    upsert?: SessionUpsertWithoutSessionLevelsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionLevelsInput, SessionUpdateWithoutSessionLevelsInput>, SessionUncheckedUpdateWithoutSessionLevelsInput>
  }

  export type LevelUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<LevelCreateWithoutSessionsInput, LevelUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: LevelCreateOrConnectWithoutSessionsInput
    upsert?: LevelUpsertWithoutSessionsInput
    connect?: LevelWhereUniqueInput
    update?: XOR<XOR<LevelUpdateToOneWithWhereWithoutSessionsInput, LevelUpdateWithoutSessionsInput>, LevelUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionAudienceTypeOnSessionCreateNestedManyWithoutAudienceTypeInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput> | SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManyAudienceTypeInputEnvelope
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
  }

  export type SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutAudienceTypeInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput> | SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManyAudienceTypeInputEnvelope
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
  }

  export type SessionAudienceTypeOnSessionUpdateManyWithoutAudienceTypeNestedInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput> | SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput[]
    upsert?: SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutAudienceTypeInput | SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutAudienceTypeInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManyAudienceTypeInputEnvelope
    set?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    delete?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    update?: SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutAudienceTypeInput | SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutAudienceTypeInput[]
    updateMany?: SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutAudienceTypeInput | SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutAudienceTypeInput[]
    deleteMany?: SessionAudienceTypeOnSessionScalarWhereInput | SessionAudienceTypeOnSessionScalarWhereInput[]
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutAudienceTypeNestedInput = {
    create?: XOR<SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput> | SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput[] | SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput[]
    connectOrCreate?: SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput | SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput[]
    upsert?: SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutAudienceTypeInput | SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutAudienceTypeInput[]
    createMany?: SessionAudienceTypeOnSessionCreateManyAudienceTypeInputEnvelope
    set?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    delete?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    connect?: SessionAudienceTypeOnSessionWhereUniqueInput | SessionAudienceTypeOnSessionWhereUniqueInput[]
    update?: SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutAudienceTypeInput | SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutAudienceTypeInput[]
    updateMany?: SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutAudienceTypeInput | SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutAudienceTypeInput[]
    deleteMany?: SessionAudienceTypeOnSessionScalarWhereInput | SessionAudienceTypeOnSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionAudienceTypesInput = {
    create?: XOR<SessionCreateWithoutSessionAudienceTypesInput, SessionUncheckedCreateWithoutSessionAudienceTypesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionAudienceTypesInput
    connect?: SessionWhereUniqueInput
  }

  export type AudienceTypeCreateNestedOneWithoutSessionsInput = {
    create?: XOR<AudienceTypeCreateWithoutSessionsInput, AudienceTypeUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AudienceTypeCreateOrConnectWithoutSessionsInput
    connect?: AudienceTypeWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionAudienceTypesNestedInput = {
    create?: XOR<SessionCreateWithoutSessionAudienceTypesInput, SessionUncheckedCreateWithoutSessionAudienceTypesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionAudienceTypesInput
    upsert?: SessionUpsertWithoutSessionAudienceTypesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionAudienceTypesInput, SessionUpdateWithoutSessionAudienceTypesInput>, SessionUncheckedUpdateWithoutSessionAudienceTypesInput>
  }

  export type AudienceTypeUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<AudienceTypeCreateWithoutSessionsInput, AudienceTypeUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: AudienceTypeCreateOrConnectWithoutSessionsInput
    upsert?: AudienceTypeUpsertWithoutSessionsInput
    connect?: AudienceTypeWhereUniqueInput
    update?: XOR<XOR<AudienceTypeUpdateToOneWithWhereWithoutSessionsInput, AudienceTypeUpdateWithoutSessionsInput>, AudienceTypeUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionIndustryOnSessionCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutIndustryInput, SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput> | SessionIndustryOnSessionCreateWithoutIndustryInput[] | SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput | SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput[]
    createMany?: SessionIndustryOnSessionCreateManyIndustryInputEnvelope
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
  }

  export type SessionIndustryOnSessionUncheckedCreateNestedManyWithoutIndustryInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutIndustryInput, SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput> | SessionIndustryOnSessionCreateWithoutIndustryInput[] | SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput | SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput[]
    createMany?: SessionIndustryOnSessionCreateManyIndustryInputEnvelope
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
  }

  export type SessionIndustryOnSessionUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutIndustryInput, SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput> | SessionIndustryOnSessionCreateWithoutIndustryInput[] | SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput | SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput[]
    upsert?: SessionIndustryOnSessionUpsertWithWhereUniqueWithoutIndustryInput | SessionIndustryOnSessionUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SessionIndustryOnSessionCreateManyIndustryInputEnvelope
    set?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    disconnect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    delete?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    update?: SessionIndustryOnSessionUpdateWithWhereUniqueWithoutIndustryInput | SessionIndustryOnSessionUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SessionIndustryOnSessionUpdateManyWithWhereWithoutIndustryInput | SessionIndustryOnSessionUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SessionIndustryOnSessionScalarWhereInput | SessionIndustryOnSessionScalarWhereInput[]
  }

  export type SessionIndustryOnSessionUncheckedUpdateManyWithoutIndustryNestedInput = {
    create?: XOR<SessionIndustryOnSessionCreateWithoutIndustryInput, SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput> | SessionIndustryOnSessionCreateWithoutIndustryInput[] | SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput[]
    connectOrCreate?: SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput | SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput[]
    upsert?: SessionIndustryOnSessionUpsertWithWhereUniqueWithoutIndustryInput | SessionIndustryOnSessionUpsertWithWhereUniqueWithoutIndustryInput[]
    createMany?: SessionIndustryOnSessionCreateManyIndustryInputEnvelope
    set?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    disconnect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    delete?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    connect?: SessionIndustryOnSessionWhereUniqueInput | SessionIndustryOnSessionWhereUniqueInput[]
    update?: SessionIndustryOnSessionUpdateWithWhereUniqueWithoutIndustryInput | SessionIndustryOnSessionUpdateWithWhereUniqueWithoutIndustryInput[]
    updateMany?: SessionIndustryOnSessionUpdateManyWithWhereWithoutIndustryInput | SessionIndustryOnSessionUpdateManyWithWhereWithoutIndustryInput[]
    deleteMany?: SessionIndustryOnSessionScalarWhereInput | SessionIndustryOnSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionIndustriesInput = {
    create?: XOR<SessionCreateWithoutSessionIndustriesInput, SessionUncheckedCreateWithoutSessionIndustriesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionIndustriesInput
    connect?: SessionWhereUniqueInput
  }

  export type IndustryCreateNestedOneWithoutSessionsInput = {
    create?: XOR<IndustryCreateWithoutSessionsInput, IndustryUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSessionsInput
    connect?: IndustryWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionIndustriesNestedInput = {
    create?: XOR<SessionCreateWithoutSessionIndustriesInput, SessionUncheckedCreateWithoutSessionIndustriesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionIndustriesInput
    upsert?: SessionUpsertWithoutSessionIndustriesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionIndustriesInput, SessionUpdateWithoutSessionIndustriesInput>, SessionUncheckedUpdateWithoutSessionIndustriesInput>
  }

  export type IndustryUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<IndustryCreateWithoutSessionsInput, IndustryUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: IndustryCreateOrConnectWithoutSessionsInput
    upsert?: IndustryUpsertWithoutSessionsInput
    connect?: IndustryWhereUniqueInput
    update?: XOR<XOR<IndustryUpdateToOneWithWhereWithoutSessionsInput, IndustryUpdateWithoutSessionsInput>, IndustryUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionDeliveryTypeOnSessionCreateNestedManyWithoutDeliveryTypeInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput> | SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInputEnvelope
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
  }

  export type SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutDeliveryTypeInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput> | SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInputEnvelope
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
  }

  export type SessionDeliveryTypeOnSessionUpdateManyWithoutDeliveryTypeNestedInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput> | SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput[]
    upsert?: SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutDeliveryTypeInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInputEnvelope
    set?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    delete?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    update?: SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutDeliveryTypeInput[]
    updateMany?: SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutDeliveryTypeInput[]
    deleteMany?: SessionDeliveryTypeOnSessionScalarWhereInput | SessionDeliveryTypeOnSessionScalarWhereInput[]
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutDeliveryTypeNestedInput = {
    create?: XOR<SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput> | SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput[] | SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput[]
    connectOrCreate?: SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput[]
    upsert?: SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutDeliveryTypeInput[]
    createMany?: SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInputEnvelope
    set?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    disconnect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    delete?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    connect?: SessionDeliveryTypeOnSessionWhereUniqueInput | SessionDeliveryTypeOnSessionWhereUniqueInput[]
    update?: SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutDeliveryTypeInput[]
    updateMany?: SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutDeliveryTypeInput | SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutDeliveryTypeInput[]
    deleteMany?: SessionDeliveryTypeOnSessionScalarWhereInput | SessionDeliveryTypeOnSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionDeliveryTypesInput = {
    create?: XOR<SessionCreateWithoutSessionDeliveryTypesInput, SessionUncheckedCreateWithoutSessionDeliveryTypesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionDeliveryTypesInput
    connect?: SessionWhereUniqueInput
  }

  export type DeliveryTypeCreateNestedOneWithoutSessionsInput = {
    create?: XOR<DeliveryTypeCreateWithoutSessionsInput, DeliveryTypeUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DeliveryTypeCreateOrConnectWithoutSessionsInput
    connect?: DeliveryTypeWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionDeliveryTypesNestedInput = {
    create?: XOR<SessionCreateWithoutSessionDeliveryTypesInput, SessionUncheckedCreateWithoutSessionDeliveryTypesInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionDeliveryTypesInput
    upsert?: SessionUpsertWithoutSessionDeliveryTypesInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionDeliveryTypesInput, SessionUpdateWithoutSessionDeliveryTypesInput>, SessionUncheckedUpdateWithoutSessionDeliveryTypesInput>
  }

  export type DeliveryTypeUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<DeliveryTypeCreateWithoutSessionsInput, DeliveryTypeUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: DeliveryTypeCreateOrConnectWithoutSessionsInput
    upsert?: DeliveryTypeUpsertWithoutSessionsInput
    connect?: DeliveryTypeWhereUniqueInput
    update?: XOR<XOR<DeliveryTypeUpdateToOneWithWhereWithoutSessionsInput, DeliveryTypeUpdateWithoutSessionsInput>, DeliveryTypeUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionViewingOptionOnSessionCreateNestedManyWithoutViewingOptionInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput> | SessionViewingOptionOnSessionCreateWithoutViewingOptionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManyViewingOptionInputEnvelope
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
  }

  export type SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutViewingOptionInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput> | SessionViewingOptionOnSessionCreateWithoutViewingOptionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManyViewingOptionInputEnvelope
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
  }

  export type SessionViewingOptionOnSessionUpdateManyWithoutViewingOptionNestedInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput> | SessionViewingOptionOnSessionCreateWithoutViewingOptionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput[]
    upsert?: SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutViewingOptionInput | SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutViewingOptionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManyViewingOptionInputEnvelope
    set?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    disconnect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    delete?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    update?: SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutViewingOptionInput | SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutViewingOptionInput[]
    updateMany?: SessionViewingOptionOnSessionUpdateManyWithWhereWithoutViewingOptionInput | SessionViewingOptionOnSessionUpdateManyWithWhereWithoutViewingOptionInput[]
    deleteMany?: SessionViewingOptionOnSessionScalarWhereInput | SessionViewingOptionOnSessionScalarWhereInput[]
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateManyWithoutViewingOptionNestedInput = {
    create?: XOR<SessionViewingOptionOnSessionCreateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput> | SessionViewingOptionOnSessionCreateWithoutViewingOptionInput[] | SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput[]
    connectOrCreate?: SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput | SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput[]
    upsert?: SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutViewingOptionInput | SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutViewingOptionInput[]
    createMany?: SessionViewingOptionOnSessionCreateManyViewingOptionInputEnvelope
    set?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    disconnect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    delete?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    connect?: SessionViewingOptionOnSessionWhereUniqueInput | SessionViewingOptionOnSessionWhereUniqueInput[]
    update?: SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutViewingOptionInput | SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutViewingOptionInput[]
    updateMany?: SessionViewingOptionOnSessionUpdateManyWithWhereWithoutViewingOptionInput | SessionViewingOptionOnSessionUpdateManyWithWhereWithoutViewingOptionInput[]
    deleteMany?: SessionViewingOptionOnSessionScalarWhereInput | SessionViewingOptionOnSessionScalarWhereInput[]
  }

  export type SessionCreateNestedOneWithoutSessionViewingOptsInput = {
    create?: XOR<SessionCreateWithoutSessionViewingOptsInput, SessionUncheckedCreateWithoutSessionViewingOptsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionViewingOptsInput
    connect?: SessionWhereUniqueInput
  }

  export type ViewingOptionCreateNestedOneWithoutSessionsInput = {
    create?: XOR<ViewingOptionCreateWithoutSessionsInput, ViewingOptionUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ViewingOptionCreateOrConnectWithoutSessionsInput
    connect?: ViewingOptionWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionViewingOptsNestedInput = {
    create?: XOR<SessionCreateWithoutSessionViewingOptsInput, SessionUncheckedCreateWithoutSessionViewingOptsInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionViewingOptsInput
    upsert?: SessionUpsertWithoutSessionViewingOptsInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionViewingOptsInput, SessionUpdateWithoutSessionViewingOptsInput>, SessionUncheckedUpdateWithoutSessionViewingOptsInput>
  }

  export type ViewingOptionUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<ViewingOptionCreateWithoutSessionsInput, ViewingOptionUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: ViewingOptionCreateOrConnectWithoutSessionsInput
    upsert?: ViewingOptionUpsertWithoutSessionsInput
    connect?: ViewingOptionWhereUniqueInput
    update?: XOR<XOR<ViewingOptionUpdateToOneWithWhereWithoutSessionsInput, ViewingOptionUpdateWithoutSessionsInput>, ViewingOptionUncheckedUpdateWithoutSessionsInput>
  }

  export type SessionSpeakerCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<SessionSpeakerCreateWithoutSpeakerInput, SessionSpeakerUncheckedCreateWithoutSpeakerInput> | SessionSpeakerCreateWithoutSpeakerInput[] | SessionSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSpeakerInput | SessionSpeakerCreateOrConnectWithoutSpeakerInput[]
    createMany?: SessionSpeakerCreateManySpeakerInputEnvelope
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
  }

  export type SpeakerCompanyCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<SpeakerCompanyCreateWithoutSpeakerInput, SpeakerCompanyUncheckedCreateWithoutSpeakerInput> | SpeakerCompanyCreateWithoutSpeakerInput[] | SpeakerCompanyUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutSpeakerInput | SpeakerCompanyCreateOrConnectWithoutSpeakerInput[]
    createMany?: SpeakerCompanyCreateManySpeakerInputEnvelope
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
  }

  export type SessionSpeakerUncheckedCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<SessionSpeakerCreateWithoutSpeakerInput, SessionSpeakerUncheckedCreateWithoutSpeakerInput> | SessionSpeakerCreateWithoutSpeakerInput[] | SessionSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSpeakerInput | SessionSpeakerCreateOrConnectWithoutSpeakerInput[]
    createMany?: SessionSpeakerCreateManySpeakerInputEnvelope
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
  }

  export type SpeakerCompanyUncheckedCreateNestedManyWithoutSpeakerInput = {
    create?: XOR<SpeakerCompanyCreateWithoutSpeakerInput, SpeakerCompanyUncheckedCreateWithoutSpeakerInput> | SpeakerCompanyCreateWithoutSpeakerInput[] | SpeakerCompanyUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutSpeakerInput | SpeakerCompanyCreateOrConnectWithoutSpeakerInput[]
    createMany?: SpeakerCompanyCreateManySpeakerInputEnvelope
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
  }

  export type SessionSpeakerUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<SessionSpeakerCreateWithoutSpeakerInput, SessionSpeakerUncheckedCreateWithoutSpeakerInput> | SessionSpeakerCreateWithoutSpeakerInput[] | SessionSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSpeakerInput | SessionSpeakerCreateOrConnectWithoutSpeakerInput[]
    upsert?: SessionSpeakerUpsertWithWhereUniqueWithoutSpeakerInput | SessionSpeakerUpsertWithWhereUniqueWithoutSpeakerInput[]
    createMany?: SessionSpeakerCreateManySpeakerInputEnvelope
    set?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    disconnect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    delete?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    update?: SessionSpeakerUpdateWithWhereUniqueWithoutSpeakerInput | SessionSpeakerUpdateWithWhereUniqueWithoutSpeakerInput[]
    updateMany?: SessionSpeakerUpdateManyWithWhereWithoutSpeakerInput | SessionSpeakerUpdateManyWithWhereWithoutSpeakerInput[]
    deleteMany?: SessionSpeakerScalarWhereInput | SessionSpeakerScalarWhereInput[]
  }

  export type SpeakerCompanyUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<SpeakerCompanyCreateWithoutSpeakerInput, SpeakerCompanyUncheckedCreateWithoutSpeakerInput> | SpeakerCompanyCreateWithoutSpeakerInput[] | SpeakerCompanyUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutSpeakerInput | SpeakerCompanyCreateOrConnectWithoutSpeakerInput[]
    upsert?: SpeakerCompanyUpsertWithWhereUniqueWithoutSpeakerInput | SpeakerCompanyUpsertWithWhereUniqueWithoutSpeakerInput[]
    createMany?: SpeakerCompanyCreateManySpeakerInputEnvelope
    set?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    disconnect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    delete?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    update?: SpeakerCompanyUpdateWithWhereUniqueWithoutSpeakerInput | SpeakerCompanyUpdateWithWhereUniqueWithoutSpeakerInput[]
    updateMany?: SpeakerCompanyUpdateManyWithWhereWithoutSpeakerInput | SpeakerCompanyUpdateManyWithWhereWithoutSpeakerInput[]
    deleteMany?: SpeakerCompanyScalarWhereInput | SpeakerCompanyScalarWhereInput[]
  }

  export type SessionSpeakerUncheckedUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<SessionSpeakerCreateWithoutSpeakerInput, SessionSpeakerUncheckedCreateWithoutSpeakerInput> | SessionSpeakerCreateWithoutSpeakerInput[] | SessionSpeakerUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SessionSpeakerCreateOrConnectWithoutSpeakerInput | SessionSpeakerCreateOrConnectWithoutSpeakerInput[]
    upsert?: SessionSpeakerUpsertWithWhereUniqueWithoutSpeakerInput | SessionSpeakerUpsertWithWhereUniqueWithoutSpeakerInput[]
    createMany?: SessionSpeakerCreateManySpeakerInputEnvelope
    set?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    disconnect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    delete?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    connect?: SessionSpeakerWhereUniqueInput | SessionSpeakerWhereUniqueInput[]
    update?: SessionSpeakerUpdateWithWhereUniqueWithoutSpeakerInput | SessionSpeakerUpdateWithWhereUniqueWithoutSpeakerInput[]
    updateMany?: SessionSpeakerUpdateManyWithWhereWithoutSpeakerInput | SessionSpeakerUpdateManyWithWhereWithoutSpeakerInput[]
    deleteMany?: SessionSpeakerScalarWhereInput | SessionSpeakerScalarWhereInput[]
  }

  export type SpeakerCompanyUncheckedUpdateManyWithoutSpeakerNestedInput = {
    create?: XOR<SpeakerCompanyCreateWithoutSpeakerInput, SpeakerCompanyUncheckedCreateWithoutSpeakerInput> | SpeakerCompanyCreateWithoutSpeakerInput[] | SpeakerCompanyUncheckedCreateWithoutSpeakerInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutSpeakerInput | SpeakerCompanyCreateOrConnectWithoutSpeakerInput[]
    upsert?: SpeakerCompanyUpsertWithWhereUniqueWithoutSpeakerInput | SpeakerCompanyUpsertWithWhereUniqueWithoutSpeakerInput[]
    createMany?: SpeakerCompanyCreateManySpeakerInputEnvelope
    set?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    disconnect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    delete?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    update?: SpeakerCompanyUpdateWithWhereUniqueWithoutSpeakerInput | SpeakerCompanyUpdateWithWhereUniqueWithoutSpeakerInput[]
    updateMany?: SpeakerCompanyUpdateManyWithWhereWithoutSpeakerInput | SpeakerCompanyUpdateManyWithWhereWithoutSpeakerInput[]
    deleteMany?: SpeakerCompanyScalarWhereInput | SpeakerCompanyScalarWhereInput[]
  }

  export type SpeakerCompanyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SpeakerCompanyCreateWithoutCompanyInput, SpeakerCompanyUncheckedCreateWithoutCompanyInput> | SpeakerCompanyCreateWithoutCompanyInput[] | SpeakerCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutCompanyInput | SpeakerCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: SpeakerCompanyCreateManyCompanyInputEnvelope
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
  }

  export type SpeakerCompanyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SpeakerCompanyCreateWithoutCompanyInput, SpeakerCompanyUncheckedCreateWithoutCompanyInput> | SpeakerCompanyCreateWithoutCompanyInput[] | SpeakerCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutCompanyInput | SpeakerCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: SpeakerCompanyCreateManyCompanyInputEnvelope
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
  }

  export type SpeakerCompanyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SpeakerCompanyCreateWithoutCompanyInput, SpeakerCompanyUncheckedCreateWithoutCompanyInput> | SpeakerCompanyCreateWithoutCompanyInput[] | SpeakerCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutCompanyInput | SpeakerCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: SpeakerCompanyUpsertWithWhereUniqueWithoutCompanyInput | SpeakerCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SpeakerCompanyCreateManyCompanyInputEnvelope
    set?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    disconnect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    delete?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    update?: SpeakerCompanyUpdateWithWhereUniqueWithoutCompanyInput | SpeakerCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SpeakerCompanyUpdateManyWithWhereWithoutCompanyInput | SpeakerCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SpeakerCompanyScalarWhereInput | SpeakerCompanyScalarWhereInput[]
  }

  export type SpeakerCompanyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SpeakerCompanyCreateWithoutCompanyInput, SpeakerCompanyUncheckedCreateWithoutCompanyInput> | SpeakerCompanyCreateWithoutCompanyInput[] | SpeakerCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SpeakerCompanyCreateOrConnectWithoutCompanyInput | SpeakerCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: SpeakerCompanyUpsertWithWhereUniqueWithoutCompanyInput | SpeakerCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SpeakerCompanyCreateManyCompanyInputEnvelope
    set?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    disconnect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    delete?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    connect?: SpeakerCompanyWhereUniqueInput | SpeakerCompanyWhereUniqueInput[]
    update?: SpeakerCompanyUpdateWithWhereUniqueWithoutCompanyInput | SpeakerCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SpeakerCompanyUpdateManyWithWhereWithoutCompanyInput | SpeakerCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SpeakerCompanyScalarWhereInput | SpeakerCompanyScalarWhereInput[]
  }

  export type SpeakerCreateNestedOneWithoutSpeakerCompaniesInput = {
    create?: XOR<SpeakerCreateWithoutSpeakerCompaniesInput, SpeakerUncheckedCreateWithoutSpeakerCompaniesInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutSpeakerCompaniesInput
    connect?: SpeakerWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutSpeakerCompaniesInput = {
    create?: XOR<CompanyCreateWithoutSpeakerCompaniesInput, CompanyUncheckedCreateWithoutSpeakerCompaniesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSpeakerCompaniesInput
    connect?: CompanyWhereUniqueInput
  }

  export type SpeakerUpdateOneRequiredWithoutSpeakerCompaniesNestedInput = {
    create?: XOR<SpeakerCreateWithoutSpeakerCompaniesInput, SpeakerUncheckedCreateWithoutSpeakerCompaniesInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutSpeakerCompaniesInput
    upsert?: SpeakerUpsertWithoutSpeakerCompaniesInput
    connect?: SpeakerWhereUniqueInput
    update?: XOR<XOR<SpeakerUpdateToOneWithWhereWithoutSpeakerCompaniesInput, SpeakerUpdateWithoutSpeakerCompaniesInput>, SpeakerUncheckedUpdateWithoutSpeakerCompaniesInput>
  }

  export type CompanyUpdateOneRequiredWithoutSpeakerCompaniesNestedInput = {
    create?: XOR<CompanyCreateWithoutSpeakerCompaniesInput, CompanyUncheckedCreateWithoutSpeakerCompaniesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSpeakerCompaniesInput
    upsert?: CompanyUpsertWithoutSpeakerCompaniesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSpeakerCompaniesInput, CompanyUpdateWithoutSpeakerCompaniesInput>, CompanyUncheckedUpdateWithoutSpeakerCompaniesInput>
  }

  export type SessionCreateNestedOneWithoutSessionSpeakersInput = {
    create?: XOR<SessionCreateWithoutSessionSpeakersInput, SessionUncheckedCreateWithoutSessionSpeakersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionSpeakersInput
    connect?: SessionWhereUniqueInput
  }

  export type SpeakerCreateNestedOneWithoutSessionSpeakersInput = {
    create?: XOR<SpeakerCreateWithoutSessionSpeakersInput, SpeakerUncheckedCreateWithoutSessionSpeakersInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutSessionSpeakersInput
    connect?: SpeakerWhereUniqueInput
  }

  export type SessionUpdateOneRequiredWithoutSessionSpeakersNestedInput = {
    create?: XOR<SessionCreateWithoutSessionSpeakersInput, SessionUncheckedCreateWithoutSessionSpeakersInput>
    connectOrCreate?: SessionCreateOrConnectWithoutSessionSpeakersInput
    upsert?: SessionUpsertWithoutSessionSpeakersInput
    connect?: SessionWhereUniqueInput
    update?: XOR<XOR<SessionUpdateToOneWithWhereWithoutSessionSpeakersInput, SessionUpdateWithoutSessionSpeakersInput>, SessionUncheckedUpdateWithoutSessionSpeakersInput>
  }

  export type SpeakerUpdateOneRequiredWithoutSessionSpeakersNestedInput = {
    create?: XOR<SpeakerCreateWithoutSessionSpeakersInput, SpeakerUncheckedCreateWithoutSessionSpeakersInput>
    connectOrCreate?: SpeakerCreateOrConnectWithoutSessionSpeakersInput
    upsert?: SpeakerUpsertWithoutSessionSpeakersInput
    connect?: SpeakerWhereUniqueInput
    update?: XOR<XOR<SpeakerUpdateToOneWithWhereWithoutSessionSpeakersInput, SpeakerUpdateWithoutSessionSpeakersInput>, SpeakerUncheckedUpdateWithoutSessionSpeakersInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type SessionTopicCreateWithoutSessionInput = {
    topic: TopicCreateNestedOneWithoutSessionsInput
  }

  export type SessionTopicUncheckedCreateWithoutSessionInput = {
    topicId: number
  }

  export type SessionTopicCreateOrConnectWithoutSessionInput = {
    where: SessionTopicWhereUniqueInput
    create: XOR<SessionTopicCreateWithoutSessionInput, SessionTopicUncheckedCreateWithoutSessionInput>
  }

  export type SessionTopicCreateManySessionInputEnvelope = {
    data: SessionTopicCreateManySessionInput | SessionTopicCreateManySessionInput[]
  }

  export type SessionTagCreateWithoutSessionInput = {
    tag: TagCreateNestedOneWithoutSessionsInput
  }

  export type SessionTagUncheckedCreateWithoutSessionInput = {
    tagId: number
  }

  export type SessionTagCreateOrConnectWithoutSessionInput = {
    where: SessionTagWhereUniqueInput
    create: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput>
  }

  export type SessionTagCreateManySessionInputEnvelope = {
    data: SessionTagCreateManySessionInput | SessionTagCreateManySessionInput[]
  }

  export type SessionLevelOnSessionCreateWithoutSessionInput = {
    level: LevelCreateNestedOneWithoutSessionsInput
  }

  export type SessionLevelOnSessionUncheckedCreateWithoutSessionInput = {
    levelId: number
  }

  export type SessionLevelOnSessionCreateOrConnectWithoutSessionInput = {
    where: SessionLevelOnSessionWhereUniqueInput
    create: XOR<SessionLevelOnSessionCreateWithoutSessionInput, SessionLevelOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionLevelOnSessionCreateManySessionInputEnvelope = {
    data: SessionLevelOnSessionCreateManySessionInput | SessionLevelOnSessionCreateManySessionInput[]
  }

  export type SessionAudienceTypeOnSessionCreateWithoutSessionInput = {
    audienceType: AudienceTypeCreateNestedOneWithoutSessionsInput
  }

  export type SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput = {
    audienceTypeId: number
  }

  export type SessionAudienceTypeOnSessionCreateOrConnectWithoutSessionInput = {
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    create: XOR<SessionAudienceTypeOnSessionCreateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionAudienceTypeOnSessionCreateManySessionInputEnvelope = {
    data: SessionAudienceTypeOnSessionCreateManySessionInput | SessionAudienceTypeOnSessionCreateManySessionInput[]
  }

  export type SessionIndustryOnSessionCreateWithoutSessionInput = {
    industry: IndustryCreateNestedOneWithoutSessionsInput
  }

  export type SessionIndustryOnSessionUncheckedCreateWithoutSessionInput = {
    industryId: number
  }

  export type SessionIndustryOnSessionCreateOrConnectWithoutSessionInput = {
    where: SessionIndustryOnSessionWhereUniqueInput
    create: XOR<SessionIndustryOnSessionCreateWithoutSessionInput, SessionIndustryOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionIndustryOnSessionCreateManySessionInputEnvelope = {
    data: SessionIndustryOnSessionCreateManySessionInput | SessionIndustryOnSessionCreateManySessionInput[]
  }

  export type SessionDeliveryTypeOnSessionCreateWithoutSessionInput = {
    deliveryType: DeliveryTypeCreateNestedOneWithoutSessionsInput
  }

  export type SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput = {
    deliveryTypeId: number
  }

  export type SessionDeliveryTypeOnSessionCreateOrConnectWithoutSessionInput = {
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    create: XOR<SessionDeliveryTypeOnSessionCreateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionDeliveryTypeOnSessionCreateManySessionInputEnvelope = {
    data: SessionDeliveryTypeOnSessionCreateManySessionInput | SessionDeliveryTypeOnSessionCreateManySessionInput[]
  }

  export type SessionViewingOptionOnSessionCreateWithoutSessionInput = {
    viewingOption: ViewingOptionCreateNestedOneWithoutSessionsInput
  }

  export type SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput = {
    viewingOptionId: number
  }

  export type SessionViewingOptionOnSessionCreateOrConnectWithoutSessionInput = {
    where: SessionViewingOptionOnSessionWhereUniqueInput
    create: XOR<SessionViewingOptionOnSessionCreateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionViewingOptionOnSessionCreateManySessionInputEnvelope = {
    data: SessionViewingOptionOnSessionCreateManySessionInput | SessionViewingOptionOnSessionCreateManySessionInput[]
  }

  export type SessionSpeakerCreateWithoutSessionInput = {
    speaker: SpeakerCreateNestedOneWithoutSessionSpeakersInput
  }

  export type SessionSpeakerUncheckedCreateWithoutSessionInput = {
    speakerId: number
  }

  export type SessionSpeakerCreateOrConnectWithoutSessionInput = {
    where: SessionSpeakerWhereUniqueInput
    create: XOR<SessionSpeakerCreateWithoutSessionInput, SessionSpeakerUncheckedCreateWithoutSessionInput>
  }

  export type SessionSpeakerCreateManySessionInputEnvelope = {
    data: SessionSpeakerCreateManySessionInput | SessionSpeakerCreateManySessionInput[]
  }

  export type SessionTopicUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionTopicWhereUniqueInput
    update: XOR<SessionTopicUpdateWithoutSessionInput, SessionTopicUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionTopicCreateWithoutSessionInput, SessionTopicUncheckedCreateWithoutSessionInput>
  }

  export type SessionTopicUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionTopicWhereUniqueInput
    data: XOR<SessionTopicUpdateWithoutSessionInput, SessionTopicUncheckedUpdateWithoutSessionInput>
  }

  export type SessionTopicUpdateManyWithWhereWithoutSessionInput = {
    where: SessionTopicScalarWhereInput
    data: XOR<SessionTopicUpdateManyMutationInput, SessionTopicUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionTopicScalarWhereInput = {
    AND?: SessionTopicScalarWhereInput | SessionTopicScalarWhereInput[]
    OR?: SessionTopicScalarWhereInput[]
    NOT?: SessionTopicScalarWhereInput | SessionTopicScalarWhereInput[]
    sessionId?: IntFilter<"SessionTopic"> | number
    topicId?: IntFilter<"SessionTopic"> | number
  }

  export type SessionTagUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionTagWhereUniqueInput
    update: XOR<SessionTagUpdateWithoutSessionInput, SessionTagUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionTagCreateWithoutSessionInput, SessionTagUncheckedCreateWithoutSessionInput>
  }

  export type SessionTagUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionTagWhereUniqueInput
    data: XOR<SessionTagUpdateWithoutSessionInput, SessionTagUncheckedUpdateWithoutSessionInput>
  }

  export type SessionTagUpdateManyWithWhereWithoutSessionInput = {
    where: SessionTagScalarWhereInput
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionTagScalarWhereInput = {
    AND?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
    OR?: SessionTagScalarWhereInput[]
    NOT?: SessionTagScalarWhereInput | SessionTagScalarWhereInput[]
    sessionId?: IntFilter<"SessionTag"> | number
    tagId?: IntFilter<"SessionTag"> | number
  }

  export type SessionLevelOnSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionLevelOnSessionWhereUniqueInput
    update: XOR<SessionLevelOnSessionUpdateWithoutSessionInput, SessionLevelOnSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionLevelOnSessionCreateWithoutSessionInput, SessionLevelOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionLevelOnSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionLevelOnSessionWhereUniqueInput
    data: XOR<SessionLevelOnSessionUpdateWithoutSessionInput, SessionLevelOnSessionUncheckedUpdateWithoutSessionInput>
  }

  export type SessionLevelOnSessionUpdateManyWithWhereWithoutSessionInput = {
    where: SessionLevelOnSessionScalarWhereInput
    data: XOR<SessionLevelOnSessionUpdateManyMutationInput, SessionLevelOnSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionLevelOnSessionScalarWhereInput = {
    AND?: SessionLevelOnSessionScalarWhereInput | SessionLevelOnSessionScalarWhereInput[]
    OR?: SessionLevelOnSessionScalarWhereInput[]
    NOT?: SessionLevelOnSessionScalarWhereInput | SessionLevelOnSessionScalarWhereInput[]
    sessionId?: IntFilter<"SessionLevelOnSession"> | number
    levelId?: IntFilter<"SessionLevelOnSession"> | number
  }

  export type SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    update: XOR<SessionAudienceTypeOnSessionUpdateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionAudienceTypeOnSessionCreateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    data: XOR<SessionAudienceTypeOnSessionUpdateWithoutSessionInput, SessionAudienceTypeOnSessionUncheckedUpdateWithoutSessionInput>
  }

  export type SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutSessionInput = {
    where: SessionAudienceTypeOnSessionScalarWhereInput
    data: XOR<SessionAudienceTypeOnSessionUpdateManyMutationInput, SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionAudienceTypeOnSessionScalarWhereInput = {
    AND?: SessionAudienceTypeOnSessionScalarWhereInput | SessionAudienceTypeOnSessionScalarWhereInput[]
    OR?: SessionAudienceTypeOnSessionScalarWhereInput[]
    NOT?: SessionAudienceTypeOnSessionScalarWhereInput | SessionAudienceTypeOnSessionScalarWhereInput[]
    sessionId?: IntFilter<"SessionAudienceTypeOnSession"> | number
    audienceTypeId?: IntFilter<"SessionAudienceTypeOnSession"> | number
  }

  export type SessionIndustryOnSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionIndustryOnSessionWhereUniqueInput
    update: XOR<SessionIndustryOnSessionUpdateWithoutSessionInput, SessionIndustryOnSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionIndustryOnSessionCreateWithoutSessionInput, SessionIndustryOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionIndustryOnSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionIndustryOnSessionWhereUniqueInput
    data: XOR<SessionIndustryOnSessionUpdateWithoutSessionInput, SessionIndustryOnSessionUncheckedUpdateWithoutSessionInput>
  }

  export type SessionIndustryOnSessionUpdateManyWithWhereWithoutSessionInput = {
    where: SessionIndustryOnSessionScalarWhereInput
    data: XOR<SessionIndustryOnSessionUpdateManyMutationInput, SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionIndustryOnSessionScalarWhereInput = {
    AND?: SessionIndustryOnSessionScalarWhereInput | SessionIndustryOnSessionScalarWhereInput[]
    OR?: SessionIndustryOnSessionScalarWhereInput[]
    NOT?: SessionIndustryOnSessionScalarWhereInput | SessionIndustryOnSessionScalarWhereInput[]
    sessionId?: IntFilter<"SessionIndustryOnSession"> | number
    industryId?: IntFilter<"SessionIndustryOnSession"> | number
  }

  export type SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    update: XOR<SessionDeliveryTypeOnSessionUpdateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionDeliveryTypeOnSessionCreateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    data: XOR<SessionDeliveryTypeOnSessionUpdateWithoutSessionInput, SessionDeliveryTypeOnSessionUncheckedUpdateWithoutSessionInput>
  }

  export type SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutSessionInput = {
    where: SessionDeliveryTypeOnSessionScalarWhereInput
    data: XOR<SessionDeliveryTypeOnSessionUpdateManyMutationInput, SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionDeliveryTypeOnSessionScalarWhereInput = {
    AND?: SessionDeliveryTypeOnSessionScalarWhereInput | SessionDeliveryTypeOnSessionScalarWhereInput[]
    OR?: SessionDeliveryTypeOnSessionScalarWhereInput[]
    NOT?: SessionDeliveryTypeOnSessionScalarWhereInput | SessionDeliveryTypeOnSessionScalarWhereInput[]
    sessionId?: IntFilter<"SessionDeliveryTypeOnSession"> | number
    deliveryTypeId?: IntFilter<"SessionDeliveryTypeOnSession"> | number
  }

  export type SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionViewingOptionOnSessionWhereUniqueInput
    update: XOR<SessionViewingOptionOnSessionUpdateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionViewingOptionOnSessionCreateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutSessionInput>
  }

  export type SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionViewingOptionOnSessionWhereUniqueInput
    data: XOR<SessionViewingOptionOnSessionUpdateWithoutSessionInput, SessionViewingOptionOnSessionUncheckedUpdateWithoutSessionInput>
  }

  export type SessionViewingOptionOnSessionUpdateManyWithWhereWithoutSessionInput = {
    where: SessionViewingOptionOnSessionScalarWhereInput
    data: XOR<SessionViewingOptionOnSessionUpdateManyMutationInput, SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionViewingOptionOnSessionScalarWhereInput = {
    AND?: SessionViewingOptionOnSessionScalarWhereInput | SessionViewingOptionOnSessionScalarWhereInput[]
    OR?: SessionViewingOptionOnSessionScalarWhereInput[]
    NOT?: SessionViewingOptionOnSessionScalarWhereInput | SessionViewingOptionOnSessionScalarWhereInput[]
    sessionId?: IntFilter<"SessionViewingOptionOnSession"> | number
    viewingOptionId?: IntFilter<"SessionViewingOptionOnSession"> | number
  }

  export type SessionSpeakerUpsertWithWhereUniqueWithoutSessionInput = {
    where: SessionSpeakerWhereUniqueInput
    update: XOR<SessionSpeakerUpdateWithoutSessionInput, SessionSpeakerUncheckedUpdateWithoutSessionInput>
    create: XOR<SessionSpeakerCreateWithoutSessionInput, SessionSpeakerUncheckedCreateWithoutSessionInput>
  }

  export type SessionSpeakerUpdateWithWhereUniqueWithoutSessionInput = {
    where: SessionSpeakerWhereUniqueInput
    data: XOR<SessionSpeakerUpdateWithoutSessionInput, SessionSpeakerUncheckedUpdateWithoutSessionInput>
  }

  export type SessionSpeakerUpdateManyWithWhereWithoutSessionInput = {
    where: SessionSpeakerScalarWhereInput
    data: XOR<SessionSpeakerUpdateManyMutationInput, SessionSpeakerUncheckedUpdateManyWithoutSessionInput>
  }

  export type SessionSpeakerScalarWhereInput = {
    AND?: SessionSpeakerScalarWhereInput | SessionSpeakerScalarWhereInput[]
    OR?: SessionSpeakerScalarWhereInput[]
    NOT?: SessionSpeakerScalarWhereInput | SessionSpeakerScalarWhereInput[]
    sessionId?: IntFilter<"SessionSpeaker"> | number
    speakerId?: IntFilter<"SessionSpeaker"> | number
  }

  export type SessionTopicCreateWithoutTopicInput = {
    session: SessionCreateNestedOneWithoutSessionTopicsInput
  }

  export type SessionTopicUncheckedCreateWithoutTopicInput = {
    sessionId: number
  }

  export type SessionTopicCreateOrConnectWithoutTopicInput = {
    where: SessionTopicWhereUniqueInput
    create: XOR<SessionTopicCreateWithoutTopicInput, SessionTopicUncheckedCreateWithoutTopicInput>
  }

  export type SessionTopicCreateManyTopicInputEnvelope = {
    data: SessionTopicCreateManyTopicInput | SessionTopicCreateManyTopicInput[]
  }

  export type SessionTopicUpsertWithWhereUniqueWithoutTopicInput = {
    where: SessionTopicWhereUniqueInput
    update: XOR<SessionTopicUpdateWithoutTopicInput, SessionTopicUncheckedUpdateWithoutTopicInput>
    create: XOR<SessionTopicCreateWithoutTopicInput, SessionTopicUncheckedCreateWithoutTopicInput>
  }

  export type SessionTopicUpdateWithWhereUniqueWithoutTopicInput = {
    where: SessionTopicWhereUniqueInput
    data: XOR<SessionTopicUpdateWithoutTopicInput, SessionTopicUncheckedUpdateWithoutTopicInput>
  }

  export type SessionTopicUpdateManyWithWhereWithoutTopicInput = {
    where: SessionTopicScalarWhereInput
    data: XOR<SessionTopicUpdateManyMutationInput, SessionTopicUncheckedUpdateManyWithoutTopicInput>
  }

  export type SessionCreateWithoutSessionTopicsInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionTopicsInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionTopicsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionTopicsInput, SessionUncheckedCreateWithoutSessionTopicsInput>
  }

  export type TopicCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type TopicUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type TopicCreateOrConnectWithoutSessionsInput = {
    where: TopicWhereUniqueInput
    create: XOR<TopicCreateWithoutSessionsInput, TopicUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionTopicsInput = {
    update: XOR<SessionUpdateWithoutSessionTopicsInput, SessionUncheckedUpdateWithoutSessionTopicsInput>
    create: XOR<SessionCreateWithoutSessionTopicsInput, SessionUncheckedCreateWithoutSessionTopicsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionTopicsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionTopicsInput, SessionUncheckedUpdateWithoutSessionTopicsInput>
  }

  export type SessionUpdateWithoutSessionTopicsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionTopicsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TopicUpsertWithoutSessionsInput = {
    update: XOR<TopicUpdateWithoutSessionsInput, TopicUncheckedUpdateWithoutSessionsInput>
    create: XOR<TopicCreateWithoutSessionsInput, TopicUncheckedCreateWithoutSessionsInput>
    where?: TopicWhereInput
  }

  export type TopicUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TopicWhereInput
    data: XOR<TopicUpdateWithoutSessionsInput, TopicUncheckedUpdateWithoutSessionsInput>
  }

  export type TopicUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type TopicUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionTagCreateWithoutTagInput = {
    session: SessionCreateNestedOneWithoutSessionTagsInput
  }

  export type SessionTagUncheckedCreateWithoutTagInput = {
    sessionId: number
  }

  export type SessionTagCreateOrConnectWithoutTagInput = {
    where: SessionTagWhereUniqueInput
    create: XOR<SessionTagCreateWithoutTagInput, SessionTagUncheckedCreateWithoutTagInput>
  }

  export type SessionTagCreateManyTagInputEnvelope = {
    data: SessionTagCreateManyTagInput | SessionTagCreateManyTagInput[]
  }

  export type SessionTagUpsertWithWhereUniqueWithoutTagInput = {
    where: SessionTagWhereUniqueInput
    update: XOR<SessionTagUpdateWithoutTagInput, SessionTagUncheckedUpdateWithoutTagInput>
    create: XOR<SessionTagCreateWithoutTagInput, SessionTagUncheckedCreateWithoutTagInput>
  }

  export type SessionTagUpdateWithWhereUniqueWithoutTagInput = {
    where: SessionTagWhereUniqueInput
    data: XOR<SessionTagUpdateWithoutTagInput, SessionTagUncheckedUpdateWithoutTagInput>
  }

  export type SessionTagUpdateManyWithWhereWithoutTagInput = {
    where: SessionTagScalarWhereInput
    data: XOR<SessionTagUpdateManyMutationInput, SessionTagUncheckedUpdateManyWithoutTagInput>
  }

  export type SessionCreateWithoutSessionTagsInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionTagsInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionTagsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionTagsInput, SessionUncheckedCreateWithoutSessionTagsInput>
  }

  export type TagCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type TagUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type TagCreateOrConnectWithoutSessionsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutSessionsInput, TagUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionTagsInput = {
    update: XOR<SessionUpdateWithoutSessionTagsInput, SessionUncheckedUpdateWithoutSessionTagsInput>
    create: XOR<SessionCreateWithoutSessionTagsInput, SessionUncheckedCreateWithoutSessionTagsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionTagsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionTagsInput, SessionUncheckedUpdateWithoutSessionTagsInput>
  }

  export type SessionUpdateWithoutSessionTagsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TagUpsertWithoutSessionsInput = {
    update: XOR<TagUpdateWithoutSessionsInput, TagUncheckedUpdateWithoutSessionsInput>
    create: XOR<TagCreateWithoutSessionsInput, TagUncheckedCreateWithoutSessionsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutSessionsInput, TagUncheckedUpdateWithoutSessionsInput>
  }

  export type TagUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type TagUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionLevelOnSessionCreateWithoutLevelInput = {
    session: SessionCreateNestedOneWithoutSessionLevelsInput
  }

  export type SessionLevelOnSessionUncheckedCreateWithoutLevelInput = {
    sessionId: number
  }

  export type SessionLevelOnSessionCreateOrConnectWithoutLevelInput = {
    where: SessionLevelOnSessionWhereUniqueInput
    create: XOR<SessionLevelOnSessionCreateWithoutLevelInput, SessionLevelOnSessionUncheckedCreateWithoutLevelInput>
  }

  export type SessionLevelOnSessionCreateManyLevelInputEnvelope = {
    data: SessionLevelOnSessionCreateManyLevelInput | SessionLevelOnSessionCreateManyLevelInput[]
  }

  export type SessionLevelOnSessionUpsertWithWhereUniqueWithoutLevelInput = {
    where: SessionLevelOnSessionWhereUniqueInput
    update: XOR<SessionLevelOnSessionUpdateWithoutLevelInput, SessionLevelOnSessionUncheckedUpdateWithoutLevelInput>
    create: XOR<SessionLevelOnSessionCreateWithoutLevelInput, SessionLevelOnSessionUncheckedCreateWithoutLevelInput>
  }

  export type SessionLevelOnSessionUpdateWithWhereUniqueWithoutLevelInput = {
    where: SessionLevelOnSessionWhereUniqueInput
    data: XOR<SessionLevelOnSessionUpdateWithoutLevelInput, SessionLevelOnSessionUncheckedUpdateWithoutLevelInput>
  }

  export type SessionLevelOnSessionUpdateManyWithWhereWithoutLevelInput = {
    where: SessionLevelOnSessionScalarWhereInput
    data: XOR<SessionLevelOnSessionUpdateManyMutationInput, SessionLevelOnSessionUncheckedUpdateManyWithoutLevelInput>
  }

  export type SessionCreateWithoutSessionLevelsInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionLevelsInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionLevelsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionLevelsInput, SessionUncheckedCreateWithoutSessionLevelsInput>
  }

  export type LevelCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type LevelUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type LevelCreateOrConnectWithoutSessionsInput = {
    where: LevelWhereUniqueInput
    create: XOR<LevelCreateWithoutSessionsInput, LevelUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionLevelsInput = {
    update: XOR<SessionUpdateWithoutSessionLevelsInput, SessionUncheckedUpdateWithoutSessionLevelsInput>
    create: XOR<SessionCreateWithoutSessionLevelsInput, SessionUncheckedCreateWithoutSessionLevelsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionLevelsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionLevelsInput, SessionUncheckedUpdateWithoutSessionLevelsInput>
  }

  export type SessionUpdateWithoutSessionLevelsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionLevelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type LevelUpsertWithoutSessionsInput = {
    update: XOR<LevelUpdateWithoutSessionsInput, LevelUncheckedUpdateWithoutSessionsInput>
    create: XOR<LevelCreateWithoutSessionsInput, LevelUncheckedCreateWithoutSessionsInput>
    where?: LevelWhereInput
  }

  export type LevelUpdateToOneWithWhereWithoutSessionsInput = {
    where?: LevelWhereInput
    data: XOR<LevelUpdateWithoutSessionsInput, LevelUncheckedUpdateWithoutSessionsInput>
  }

  export type LevelUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type LevelUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput = {
    session: SessionCreateNestedOneWithoutSessionAudienceTypesInput
  }

  export type SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput = {
    sessionId: number
  }

  export type SessionAudienceTypeOnSessionCreateOrConnectWithoutAudienceTypeInput = {
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    create: XOR<SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput>
  }

  export type SessionAudienceTypeOnSessionCreateManyAudienceTypeInputEnvelope = {
    data: SessionAudienceTypeOnSessionCreateManyAudienceTypeInput | SessionAudienceTypeOnSessionCreateManyAudienceTypeInput[]
  }

  export type SessionAudienceTypeOnSessionUpsertWithWhereUniqueWithoutAudienceTypeInput = {
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    update: XOR<SessionAudienceTypeOnSessionUpdateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedUpdateWithoutAudienceTypeInput>
    create: XOR<SessionAudienceTypeOnSessionCreateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedCreateWithoutAudienceTypeInput>
  }

  export type SessionAudienceTypeOnSessionUpdateWithWhereUniqueWithoutAudienceTypeInput = {
    where: SessionAudienceTypeOnSessionWhereUniqueInput
    data: XOR<SessionAudienceTypeOnSessionUpdateWithoutAudienceTypeInput, SessionAudienceTypeOnSessionUncheckedUpdateWithoutAudienceTypeInput>
  }

  export type SessionAudienceTypeOnSessionUpdateManyWithWhereWithoutAudienceTypeInput = {
    where: SessionAudienceTypeOnSessionScalarWhereInput
    data: XOR<SessionAudienceTypeOnSessionUpdateManyMutationInput, SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutAudienceTypeInput>
  }

  export type SessionCreateWithoutSessionAudienceTypesInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionAudienceTypesInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionAudienceTypesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionAudienceTypesInput, SessionUncheckedCreateWithoutSessionAudienceTypesInput>
  }

  export type AudienceTypeCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type AudienceTypeUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type AudienceTypeCreateOrConnectWithoutSessionsInput = {
    where: AudienceTypeWhereUniqueInput
    create: XOR<AudienceTypeCreateWithoutSessionsInput, AudienceTypeUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionAudienceTypesInput = {
    update: XOR<SessionUpdateWithoutSessionAudienceTypesInput, SessionUncheckedUpdateWithoutSessionAudienceTypesInput>
    create: XOR<SessionCreateWithoutSessionAudienceTypesInput, SessionUncheckedCreateWithoutSessionAudienceTypesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionAudienceTypesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionAudienceTypesInput, SessionUncheckedUpdateWithoutSessionAudienceTypesInput>
  }

  export type SessionUpdateWithoutSessionAudienceTypesInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionAudienceTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type AudienceTypeUpsertWithoutSessionsInput = {
    update: XOR<AudienceTypeUpdateWithoutSessionsInput, AudienceTypeUncheckedUpdateWithoutSessionsInput>
    create: XOR<AudienceTypeCreateWithoutSessionsInput, AudienceTypeUncheckedCreateWithoutSessionsInput>
    where?: AudienceTypeWhereInput
  }

  export type AudienceTypeUpdateToOneWithWhereWithoutSessionsInput = {
    where?: AudienceTypeWhereInput
    data: XOR<AudienceTypeUpdateWithoutSessionsInput, AudienceTypeUncheckedUpdateWithoutSessionsInput>
  }

  export type AudienceTypeUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type AudienceTypeUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionIndustryOnSessionCreateWithoutIndustryInput = {
    session: SessionCreateNestedOneWithoutSessionIndustriesInput
  }

  export type SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput = {
    sessionId: number
  }

  export type SessionIndustryOnSessionCreateOrConnectWithoutIndustryInput = {
    where: SessionIndustryOnSessionWhereUniqueInput
    create: XOR<SessionIndustryOnSessionCreateWithoutIndustryInput, SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput>
  }

  export type SessionIndustryOnSessionCreateManyIndustryInputEnvelope = {
    data: SessionIndustryOnSessionCreateManyIndustryInput | SessionIndustryOnSessionCreateManyIndustryInput[]
  }

  export type SessionIndustryOnSessionUpsertWithWhereUniqueWithoutIndustryInput = {
    where: SessionIndustryOnSessionWhereUniqueInput
    update: XOR<SessionIndustryOnSessionUpdateWithoutIndustryInput, SessionIndustryOnSessionUncheckedUpdateWithoutIndustryInput>
    create: XOR<SessionIndustryOnSessionCreateWithoutIndustryInput, SessionIndustryOnSessionUncheckedCreateWithoutIndustryInput>
  }

  export type SessionIndustryOnSessionUpdateWithWhereUniqueWithoutIndustryInput = {
    where: SessionIndustryOnSessionWhereUniqueInput
    data: XOR<SessionIndustryOnSessionUpdateWithoutIndustryInput, SessionIndustryOnSessionUncheckedUpdateWithoutIndustryInput>
  }

  export type SessionIndustryOnSessionUpdateManyWithWhereWithoutIndustryInput = {
    where: SessionIndustryOnSessionScalarWhereInput
    data: XOR<SessionIndustryOnSessionUpdateManyMutationInput, SessionIndustryOnSessionUncheckedUpdateManyWithoutIndustryInput>
  }

  export type SessionCreateWithoutSessionIndustriesInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionIndustriesInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionIndustriesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionIndustriesInput, SessionUncheckedCreateWithoutSessionIndustriesInput>
  }

  export type IndustryCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type IndustryUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type IndustryCreateOrConnectWithoutSessionsInput = {
    where: IndustryWhereUniqueInput
    create: XOR<IndustryCreateWithoutSessionsInput, IndustryUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionIndustriesInput = {
    update: XOR<SessionUpdateWithoutSessionIndustriesInput, SessionUncheckedUpdateWithoutSessionIndustriesInput>
    create: XOR<SessionCreateWithoutSessionIndustriesInput, SessionUncheckedCreateWithoutSessionIndustriesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionIndustriesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionIndustriesInput, SessionUncheckedUpdateWithoutSessionIndustriesInput>
  }

  export type SessionUpdateWithoutSessionIndustriesInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionIndustriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type IndustryUpsertWithoutSessionsInput = {
    update: XOR<IndustryUpdateWithoutSessionsInput, IndustryUncheckedUpdateWithoutSessionsInput>
    create: XOR<IndustryCreateWithoutSessionsInput, IndustryUncheckedCreateWithoutSessionsInput>
    where?: IndustryWhereInput
  }

  export type IndustryUpdateToOneWithWhereWithoutSessionsInput = {
    where?: IndustryWhereInput
    data: XOR<IndustryUpdateWithoutSessionsInput, IndustryUncheckedUpdateWithoutSessionsInput>
  }

  export type IndustryUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type IndustryUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput = {
    session: SessionCreateNestedOneWithoutSessionDeliveryTypesInput
  }

  export type SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput = {
    sessionId: number
  }

  export type SessionDeliveryTypeOnSessionCreateOrConnectWithoutDeliveryTypeInput = {
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    create: XOR<SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput>
  }

  export type SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInputEnvelope = {
    data: SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInput | SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInput[]
  }

  export type SessionDeliveryTypeOnSessionUpsertWithWhereUniqueWithoutDeliveryTypeInput = {
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    update: XOR<SessionDeliveryTypeOnSessionUpdateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedUpdateWithoutDeliveryTypeInput>
    create: XOR<SessionDeliveryTypeOnSessionCreateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedCreateWithoutDeliveryTypeInput>
  }

  export type SessionDeliveryTypeOnSessionUpdateWithWhereUniqueWithoutDeliveryTypeInput = {
    where: SessionDeliveryTypeOnSessionWhereUniqueInput
    data: XOR<SessionDeliveryTypeOnSessionUpdateWithoutDeliveryTypeInput, SessionDeliveryTypeOnSessionUncheckedUpdateWithoutDeliveryTypeInput>
  }

  export type SessionDeliveryTypeOnSessionUpdateManyWithWhereWithoutDeliveryTypeInput = {
    where: SessionDeliveryTypeOnSessionScalarWhereInput
    data: XOR<SessionDeliveryTypeOnSessionUpdateManyMutationInput, SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutDeliveryTypeInput>
  }

  export type SessionCreateWithoutSessionDeliveryTypesInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionDeliveryTypesInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionDeliveryTypesInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionDeliveryTypesInput, SessionUncheckedCreateWithoutSessionDeliveryTypesInput>
  }

  export type DeliveryTypeCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type DeliveryTypeUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type DeliveryTypeCreateOrConnectWithoutSessionsInput = {
    where: DeliveryTypeWhereUniqueInput
    create: XOR<DeliveryTypeCreateWithoutSessionsInput, DeliveryTypeUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionDeliveryTypesInput = {
    update: XOR<SessionUpdateWithoutSessionDeliveryTypesInput, SessionUncheckedUpdateWithoutSessionDeliveryTypesInput>
    create: XOR<SessionCreateWithoutSessionDeliveryTypesInput, SessionUncheckedCreateWithoutSessionDeliveryTypesInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionDeliveryTypesInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionDeliveryTypesInput, SessionUncheckedUpdateWithoutSessionDeliveryTypesInput>
  }

  export type SessionUpdateWithoutSessionDeliveryTypesInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionDeliveryTypesInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type DeliveryTypeUpsertWithoutSessionsInput = {
    update: XOR<DeliveryTypeUpdateWithoutSessionsInput, DeliveryTypeUncheckedUpdateWithoutSessionsInput>
    create: XOR<DeliveryTypeCreateWithoutSessionsInput, DeliveryTypeUncheckedCreateWithoutSessionsInput>
    where?: DeliveryTypeWhereInput
  }

  export type DeliveryTypeUpdateToOneWithWhereWithoutSessionsInput = {
    where?: DeliveryTypeWhereInput
    data: XOR<DeliveryTypeUpdateWithoutSessionsInput, DeliveryTypeUncheckedUpdateWithoutSessionsInput>
  }

  export type DeliveryTypeUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type DeliveryTypeUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionViewingOptionOnSessionCreateWithoutViewingOptionInput = {
    session: SessionCreateNestedOneWithoutSessionViewingOptsInput
  }

  export type SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput = {
    sessionId: number
  }

  export type SessionViewingOptionOnSessionCreateOrConnectWithoutViewingOptionInput = {
    where: SessionViewingOptionOnSessionWhereUniqueInput
    create: XOR<SessionViewingOptionOnSessionCreateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput>
  }

  export type SessionViewingOptionOnSessionCreateManyViewingOptionInputEnvelope = {
    data: SessionViewingOptionOnSessionCreateManyViewingOptionInput | SessionViewingOptionOnSessionCreateManyViewingOptionInput[]
  }

  export type SessionViewingOptionOnSessionUpsertWithWhereUniqueWithoutViewingOptionInput = {
    where: SessionViewingOptionOnSessionWhereUniqueInput
    update: XOR<SessionViewingOptionOnSessionUpdateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedUpdateWithoutViewingOptionInput>
    create: XOR<SessionViewingOptionOnSessionCreateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedCreateWithoutViewingOptionInput>
  }

  export type SessionViewingOptionOnSessionUpdateWithWhereUniqueWithoutViewingOptionInput = {
    where: SessionViewingOptionOnSessionWhereUniqueInput
    data: XOR<SessionViewingOptionOnSessionUpdateWithoutViewingOptionInput, SessionViewingOptionOnSessionUncheckedUpdateWithoutViewingOptionInput>
  }

  export type SessionViewingOptionOnSessionUpdateManyWithWhereWithoutViewingOptionInput = {
    where: SessionViewingOptionOnSessionScalarWhereInput
    data: XOR<SessionViewingOptionOnSessionUpdateManyMutationInput, SessionViewingOptionOnSessionUncheckedUpdateManyWithoutViewingOptionInput>
  }

  export type SessionCreateWithoutSessionViewingOptsInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionViewingOptsInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionViewingOptsInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionViewingOptsInput, SessionUncheckedCreateWithoutSessionViewingOptsInput>
  }

  export type ViewingOptionCreateWithoutSessionsInput = {
    logicalValue: string
    displayValue: string
  }

  export type ViewingOptionUncheckedCreateWithoutSessionsInput = {
    id?: number
    logicalValue: string
    displayValue: string
  }

  export type ViewingOptionCreateOrConnectWithoutSessionsInput = {
    where: ViewingOptionWhereUniqueInput
    create: XOR<ViewingOptionCreateWithoutSessionsInput, ViewingOptionUncheckedCreateWithoutSessionsInput>
  }

  export type SessionUpsertWithoutSessionViewingOptsInput = {
    update: XOR<SessionUpdateWithoutSessionViewingOptsInput, SessionUncheckedUpdateWithoutSessionViewingOptsInput>
    create: XOR<SessionCreateWithoutSessionViewingOptsInput, SessionUncheckedCreateWithoutSessionViewingOptsInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionViewingOptsInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionViewingOptsInput, SessionUncheckedUpdateWithoutSessionViewingOptsInput>
  }

  export type SessionUpdateWithoutSessionViewingOptsInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionViewingOptsInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type ViewingOptionUpsertWithoutSessionsInput = {
    update: XOR<ViewingOptionUpdateWithoutSessionsInput, ViewingOptionUncheckedUpdateWithoutSessionsInput>
    create: XOR<ViewingOptionCreateWithoutSessionsInput, ViewingOptionUncheckedCreateWithoutSessionsInput>
    where?: ViewingOptionWhereInput
  }

  export type ViewingOptionUpdateToOneWithWhereWithoutSessionsInput = {
    where?: ViewingOptionWhereInput
    data: XOR<ViewingOptionUpdateWithoutSessionsInput, ViewingOptionUncheckedUpdateWithoutSessionsInput>
  }

  export type ViewingOptionUpdateWithoutSessionsInput = {
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type ViewingOptionUncheckedUpdateWithoutSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    logicalValue?: StringFieldUpdateOperationsInput | string
    displayValue?: StringFieldUpdateOperationsInput | string
  }

  export type SessionSpeakerCreateWithoutSpeakerInput = {
    session: SessionCreateNestedOneWithoutSessionSpeakersInput
  }

  export type SessionSpeakerUncheckedCreateWithoutSpeakerInput = {
    sessionId: number
  }

  export type SessionSpeakerCreateOrConnectWithoutSpeakerInput = {
    where: SessionSpeakerWhereUniqueInput
    create: XOR<SessionSpeakerCreateWithoutSpeakerInput, SessionSpeakerUncheckedCreateWithoutSpeakerInput>
  }

  export type SessionSpeakerCreateManySpeakerInputEnvelope = {
    data: SessionSpeakerCreateManySpeakerInput | SessionSpeakerCreateManySpeakerInput[]
  }

  export type SpeakerCompanyCreateWithoutSpeakerInput = {
    company: CompanyCreateNestedOneWithoutSpeakerCompaniesInput
  }

  export type SpeakerCompanyUncheckedCreateWithoutSpeakerInput = {
    companyId: number
  }

  export type SpeakerCompanyCreateOrConnectWithoutSpeakerInput = {
    where: SpeakerCompanyWhereUniqueInput
    create: XOR<SpeakerCompanyCreateWithoutSpeakerInput, SpeakerCompanyUncheckedCreateWithoutSpeakerInput>
  }

  export type SpeakerCompanyCreateManySpeakerInputEnvelope = {
    data: SpeakerCompanyCreateManySpeakerInput | SpeakerCompanyCreateManySpeakerInput[]
  }

  export type SessionSpeakerUpsertWithWhereUniqueWithoutSpeakerInput = {
    where: SessionSpeakerWhereUniqueInput
    update: XOR<SessionSpeakerUpdateWithoutSpeakerInput, SessionSpeakerUncheckedUpdateWithoutSpeakerInput>
    create: XOR<SessionSpeakerCreateWithoutSpeakerInput, SessionSpeakerUncheckedCreateWithoutSpeakerInput>
  }

  export type SessionSpeakerUpdateWithWhereUniqueWithoutSpeakerInput = {
    where: SessionSpeakerWhereUniqueInput
    data: XOR<SessionSpeakerUpdateWithoutSpeakerInput, SessionSpeakerUncheckedUpdateWithoutSpeakerInput>
  }

  export type SessionSpeakerUpdateManyWithWhereWithoutSpeakerInput = {
    where: SessionSpeakerScalarWhereInput
    data: XOR<SessionSpeakerUpdateManyMutationInput, SessionSpeakerUncheckedUpdateManyWithoutSpeakerInput>
  }

  export type SpeakerCompanyUpsertWithWhereUniqueWithoutSpeakerInput = {
    where: SpeakerCompanyWhereUniqueInput
    update: XOR<SpeakerCompanyUpdateWithoutSpeakerInput, SpeakerCompanyUncheckedUpdateWithoutSpeakerInput>
    create: XOR<SpeakerCompanyCreateWithoutSpeakerInput, SpeakerCompanyUncheckedCreateWithoutSpeakerInput>
  }

  export type SpeakerCompanyUpdateWithWhereUniqueWithoutSpeakerInput = {
    where: SpeakerCompanyWhereUniqueInput
    data: XOR<SpeakerCompanyUpdateWithoutSpeakerInput, SpeakerCompanyUncheckedUpdateWithoutSpeakerInput>
  }

  export type SpeakerCompanyUpdateManyWithWhereWithoutSpeakerInput = {
    where: SpeakerCompanyScalarWhereInput
    data: XOR<SpeakerCompanyUpdateManyMutationInput, SpeakerCompanyUncheckedUpdateManyWithoutSpeakerInput>
  }

  export type SpeakerCompanyScalarWhereInput = {
    AND?: SpeakerCompanyScalarWhereInput | SpeakerCompanyScalarWhereInput[]
    OR?: SpeakerCompanyScalarWhereInput[]
    NOT?: SpeakerCompanyScalarWhereInput | SpeakerCompanyScalarWhereInput[]
    speakerId?: IntFilter<"SpeakerCompany"> | number
    companyId?: IntFilter<"SpeakerCompany"> | number
  }

  export type SpeakerCompanyCreateWithoutCompanyInput = {
    speaker: SpeakerCreateNestedOneWithoutSpeakerCompaniesInput
  }

  export type SpeakerCompanyUncheckedCreateWithoutCompanyInput = {
    speakerId: number
  }

  export type SpeakerCompanyCreateOrConnectWithoutCompanyInput = {
    where: SpeakerCompanyWhereUniqueInput
    create: XOR<SpeakerCompanyCreateWithoutCompanyInput, SpeakerCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type SpeakerCompanyCreateManyCompanyInputEnvelope = {
    data: SpeakerCompanyCreateManyCompanyInput | SpeakerCompanyCreateManyCompanyInput[]
  }

  export type SpeakerCompanyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SpeakerCompanyWhereUniqueInput
    update: XOR<SpeakerCompanyUpdateWithoutCompanyInput, SpeakerCompanyUncheckedUpdateWithoutCompanyInput>
    create: XOR<SpeakerCompanyCreateWithoutCompanyInput, SpeakerCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type SpeakerCompanyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SpeakerCompanyWhereUniqueInput
    data: XOR<SpeakerCompanyUpdateWithoutCompanyInput, SpeakerCompanyUncheckedUpdateWithoutCompanyInput>
  }

  export type SpeakerCompanyUpdateManyWithWhereWithoutCompanyInput = {
    where: SpeakerCompanyScalarWhereInput
    data: XOR<SpeakerCompanyUpdateManyMutationInput, SpeakerCompanyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SpeakerCreateWithoutSpeakerCompaniesInput = {
    speakerId: string
    name: string
    company?: string | null
    sessionSpeakers?: SessionSpeakerCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUncheckedCreateWithoutSpeakerCompaniesInput = {
    id?: number
    speakerId: string
    name: string
    company?: string | null
    sessionSpeakers?: SessionSpeakerUncheckedCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerCreateOrConnectWithoutSpeakerCompaniesInput = {
    where: SpeakerWhereUniqueInput
    create: XOR<SpeakerCreateWithoutSpeakerCompaniesInput, SpeakerUncheckedCreateWithoutSpeakerCompaniesInput>
  }

  export type CompanyCreateWithoutSpeakerCompaniesInput = {
    name: string
  }

  export type CompanyUncheckedCreateWithoutSpeakerCompaniesInput = {
    id?: number
    name: string
  }

  export type CompanyCreateOrConnectWithoutSpeakerCompaniesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSpeakerCompaniesInput, CompanyUncheckedCreateWithoutSpeakerCompaniesInput>
  }

  export type SpeakerUpsertWithoutSpeakerCompaniesInput = {
    update: XOR<SpeakerUpdateWithoutSpeakerCompaniesInput, SpeakerUncheckedUpdateWithoutSpeakerCompaniesInput>
    create: XOR<SpeakerCreateWithoutSpeakerCompaniesInput, SpeakerUncheckedCreateWithoutSpeakerCompaniesInput>
    where?: SpeakerWhereInput
  }

  export type SpeakerUpdateToOneWithWhereWithoutSpeakerCompaniesInput = {
    where?: SpeakerWhereInput
    data: XOR<SpeakerUpdateWithoutSpeakerCompaniesInput, SpeakerUncheckedUpdateWithoutSpeakerCompaniesInput>
  }

  export type SpeakerUpdateWithoutSpeakerCompaniesInput = {
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    sessionSpeakers?: SessionSpeakerUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerUncheckedUpdateWithoutSpeakerCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    sessionSpeakers?: SessionSpeakerUncheckedUpdateManyWithoutSpeakerNestedInput
  }

  export type CompanyUpsertWithoutSpeakerCompaniesInput = {
    update: XOR<CompanyUpdateWithoutSpeakerCompaniesInput, CompanyUncheckedUpdateWithoutSpeakerCompaniesInput>
    create: XOR<CompanyCreateWithoutSpeakerCompaniesInput, CompanyUncheckedCreateWithoutSpeakerCompaniesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSpeakerCompaniesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSpeakerCompaniesInput, CompanyUncheckedUpdateWithoutSpeakerCompaniesInput>
  }

  export type CompanyUpdateWithoutSpeakerCompaniesInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUncheckedUpdateWithoutSpeakerCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateWithoutSessionSpeakersInput = {
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionCreateNestedManyWithoutSessionInput
  }

  export type SessionUncheckedCreateWithoutSessionSpeakersInput = {
    id?: number
    sessionId: string
    sessionInstanceId?: string | null
    localizedId?: string | null
    sessionCode?: string | null
    langLocale?: string | null
    title: string
    sortTitle?: string | null
    description?: string | null
    aiDescription?: string | null
    location?: string | null
    timeSlot?: string | null
    startDateTime?: Date | string | null
    endDateTime?: Date | string | null
    durationInMinutes?: number | null
    sessionTypeDisplay?: string | null
    sessionTypeLogical?: string | null
    reportingTopic?: string | null
    onDemandUrl?: string | null
    downloadVideoUrl?: string | null
    captionFileUrl?: string | null
    thumbnailUrl?: string | null
    registrationLink?: string | null
    hasOnDemand?: boolean
    isPopular?: boolean
    heroSession?: boolean
    sessionTopics?: SessionTopicUncheckedCreateNestedManyWithoutSessionInput
    sessionTags?: SessionTagUncheckedCreateNestedManyWithoutSessionInput
    sessionLevels?: SessionLevelOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedCreateNestedManyWithoutSessionInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type SessionCreateOrConnectWithoutSessionSpeakersInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutSessionSpeakersInput, SessionUncheckedCreateWithoutSessionSpeakersInput>
  }

  export type SpeakerCreateWithoutSessionSpeakersInput = {
    speakerId: string
    name: string
    company?: string | null
    speakerCompanies?: SpeakerCompanyCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerUncheckedCreateWithoutSessionSpeakersInput = {
    id?: number
    speakerId: string
    name: string
    company?: string | null
    speakerCompanies?: SpeakerCompanyUncheckedCreateNestedManyWithoutSpeakerInput
  }

  export type SpeakerCreateOrConnectWithoutSessionSpeakersInput = {
    where: SpeakerWhereUniqueInput
    create: XOR<SpeakerCreateWithoutSessionSpeakersInput, SpeakerUncheckedCreateWithoutSessionSpeakersInput>
  }

  export type SessionUpsertWithoutSessionSpeakersInput = {
    update: XOR<SessionUpdateWithoutSessionSpeakersInput, SessionUncheckedUpdateWithoutSessionSpeakersInput>
    create: XOR<SessionCreateWithoutSessionSpeakersInput, SessionUncheckedCreateWithoutSessionSpeakersInput>
    where?: SessionWhereInput
  }

  export type SessionUpdateToOneWithWhereWithoutSessionSpeakersInput = {
    where?: SessionWhereInput
    data: XOR<SessionUpdateWithoutSessionSpeakersInput, SessionUncheckedUpdateWithoutSessionSpeakersInput>
  }

  export type SessionUpdateWithoutSessionSpeakersInput = {
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUpdateManyWithoutSessionNestedInput
  }

  export type SessionUncheckedUpdateWithoutSessionSpeakersInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessionId?: StringFieldUpdateOperationsInput | string
    sessionInstanceId?: NullableStringFieldUpdateOperationsInput | string | null
    localizedId?: NullableStringFieldUpdateOperationsInput | string | null
    sessionCode?: NullableStringFieldUpdateOperationsInput | string | null
    langLocale?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    sortTitle?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    aiDescription?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    timeSlot?: NullableStringFieldUpdateOperationsInput | string | null
    startDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDateTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    durationInMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    sessionTypeDisplay?: NullableStringFieldUpdateOperationsInput | string | null
    sessionTypeLogical?: NullableStringFieldUpdateOperationsInput | string | null
    reportingTopic?: NullableStringFieldUpdateOperationsInput | string | null
    onDemandUrl?: NullableStringFieldUpdateOperationsInput | string | null
    downloadVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    captionFileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    registrationLink?: NullableStringFieldUpdateOperationsInput | string | null
    hasOnDemand?: BoolFieldUpdateOperationsInput | boolean
    isPopular?: BoolFieldUpdateOperationsInput | boolean
    heroSession?: BoolFieldUpdateOperationsInput | boolean
    sessionTopics?: SessionTopicUncheckedUpdateManyWithoutSessionNestedInput
    sessionTags?: SessionTagUncheckedUpdateManyWithoutSessionNestedInput
    sessionLevels?: SessionLevelOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionAudienceTypes?: SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionIndustries?: SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionDeliveryTypes?: SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionNestedInput
    sessionViewingOpts?: SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type SpeakerUpsertWithoutSessionSpeakersInput = {
    update: XOR<SpeakerUpdateWithoutSessionSpeakersInput, SpeakerUncheckedUpdateWithoutSessionSpeakersInput>
    create: XOR<SpeakerCreateWithoutSessionSpeakersInput, SpeakerUncheckedCreateWithoutSessionSpeakersInput>
    where?: SpeakerWhereInput
  }

  export type SpeakerUpdateToOneWithWhereWithoutSessionSpeakersInput = {
    where?: SpeakerWhereInput
    data: XOR<SpeakerUpdateWithoutSessionSpeakersInput, SpeakerUncheckedUpdateWithoutSessionSpeakersInput>
  }

  export type SpeakerUpdateWithoutSessionSpeakersInput = {
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    speakerCompanies?: SpeakerCompanyUpdateManyWithoutSpeakerNestedInput
  }

  export type SpeakerUncheckedUpdateWithoutSessionSpeakersInput = {
    id?: IntFieldUpdateOperationsInput | number
    speakerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    company?: NullableStringFieldUpdateOperationsInput | string | null
    speakerCompanies?: SpeakerCompanyUncheckedUpdateManyWithoutSpeakerNestedInput
  }

  export type SessionTopicCreateManySessionInput = {
    topicId: number
  }

  export type SessionTagCreateManySessionInput = {
    tagId: number
  }

  export type SessionLevelOnSessionCreateManySessionInput = {
    levelId: number
  }

  export type SessionAudienceTypeOnSessionCreateManySessionInput = {
    audienceTypeId: number
  }

  export type SessionIndustryOnSessionCreateManySessionInput = {
    industryId: number
  }

  export type SessionDeliveryTypeOnSessionCreateManySessionInput = {
    deliveryTypeId: number
  }

  export type SessionViewingOptionOnSessionCreateManySessionInput = {
    viewingOptionId: number
  }

  export type SessionSpeakerCreateManySessionInput = {
    speakerId: number
  }

  export type SessionTopicUpdateWithoutSessionInput = {
    topic?: TopicUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionTopicUncheckedUpdateWithoutSessionInput = {
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTopicUncheckedUpdateManyWithoutSessionInput = {
    topicId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTagUpdateWithoutSessionInput = {
    tag?: TagUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionTagUncheckedUpdateWithoutSessionInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTagUncheckedUpdateManyWithoutSessionInput = {
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionLevelOnSessionUpdateWithoutSessionInput = {
    level?: LevelUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionLevelOnSessionUncheckedUpdateWithoutSessionInput = {
    levelId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionLevelOnSessionUncheckedUpdateManyWithoutSessionInput = {
    levelId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionAudienceTypeOnSessionUpdateWithoutSessionInput = {
    audienceType?: AudienceTypeUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateWithoutSessionInput = {
    audienceTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutSessionInput = {
    audienceTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionIndustryOnSessionUpdateWithoutSessionInput = {
    industry?: IndustryUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionIndustryOnSessionUncheckedUpdateWithoutSessionInput = {
    industryId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionIndustryOnSessionUncheckedUpdateManyWithoutSessionInput = {
    industryId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionDeliveryTypeOnSessionUpdateWithoutSessionInput = {
    deliveryType?: DeliveryTypeUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateWithoutSessionInput = {
    deliveryTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutSessionInput = {
    deliveryTypeId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionViewingOptionOnSessionUpdateWithoutSessionInput = {
    viewingOption?: ViewingOptionUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateWithoutSessionInput = {
    viewingOptionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateManyWithoutSessionInput = {
    viewingOptionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionSpeakerUpdateWithoutSessionInput = {
    speaker?: SpeakerUpdateOneRequiredWithoutSessionSpeakersNestedInput
  }

  export type SessionSpeakerUncheckedUpdateWithoutSessionInput = {
    speakerId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionSpeakerUncheckedUpdateManyWithoutSessionInput = {
    speakerId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTopicCreateManyTopicInput = {
    sessionId: number
  }

  export type SessionTopicUpdateWithoutTopicInput = {
    session?: SessionUpdateOneRequiredWithoutSessionTopicsNestedInput
  }

  export type SessionTopicUncheckedUpdateWithoutTopicInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTopicUncheckedUpdateManyWithoutTopicInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTagCreateManyTagInput = {
    sessionId: number
  }

  export type SessionTagUpdateWithoutTagInput = {
    session?: SessionUpdateOneRequiredWithoutSessionTagsNestedInput
  }

  export type SessionTagUncheckedUpdateWithoutTagInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionTagUncheckedUpdateManyWithoutTagInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionLevelOnSessionCreateManyLevelInput = {
    sessionId: number
  }

  export type SessionLevelOnSessionUpdateWithoutLevelInput = {
    session?: SessionUpdateOneRequiredWithoutSessionLevelsNestedInput
  }

  export type SessionLevelOnSessionUncheckedUpdateWithoutLevelInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionLevelOnSessionUncheckedUpdateManyWithoutLevelInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionAudienceTypeOnSessionCreateManyAudienceTypeInput = {
    sessionId: number
  }

  export type SessionAudienceTypeOnSessionUpdateWithoutAudienceTypeInput = {
    session?: SessionUpdateOneRequiredWithoutSessionAudienceTypesNestedInput
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateWithoutAudienceTypeInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionAudienceTypeOnSessionUncheckedUpdateManyWithoutAudienceTypeInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionIndustryOnSessionCreateManyIndustryInput = {
    sessionId: number
  }

  export type SessionIndustryOnSessionUpdateWithoutIndustryInput = {
    session?: SessionUpdateOneRequiredWithoutSessionIndustriesNestedInput
  }

  export type SessionIndustryOnSessionUncheckedUpdateWithoutIndustryInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionIndustryOnSessionUncheckedUpdateManyWithoutIndustryInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionDeliveryTypeOnSessionCreateManyDeliveryTypeInput = {
    sessionId: number
  }

  export type SessionDeliveryTypeOnSessionUpdateWithoutDeliveryTypeInput = {
    session?: SessionUpdateOneRequiredWithoutSessionDeliveryTypesNestedInput
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateWithoutDeliveryTypeInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionDeliveryTypeOnSessionUncheckedUpdateManyWithoutDeliveryTypeInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionViewingOptionOnSessionCreateManyViewingOptionInput = {
    sessionId: number
  }

  export type SessionViewingOptionOnSessionUpdateWithoutViewingOptionInput = {
    session?: SessionUpdateOneRequiredWithoutSessionViewingOptsNestedInput
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateWithoutViewingOptionInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionViewingOptionOnSessionUncheckedUpdateManyWithoutViewingOptionInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionSpeakerCreateManySpeakerInput = {
    sessionId: number
  }

  export type SpeakerCompanyCreateManySpeakerInput = {
    companyId: number
  }

  export type SessionSpeakerUpdateWithoutSpeakerInput = {
    session?: SessionUpdateOneRequiredWithoutSessionSpeakersNestedInput
  }

  export type SessionSpeakerUncheckedUpdateWithoutSpeakerInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SessionSpeakerUncheckedUpdateManyWithoutSpeakerInput = {
    sessionId?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakerCompanyUpdateWithoutSpeakerInput = {
    company?: CompanyUpdateOneRequiredWithoutSpeakerCompaniesNestedInput
  }

  export type SpeakerCompanyUncheckedUpdateWithoutSpeakerInput = {
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakerCompanyUncheckedUpdateManyWithoutSpeakerInput = {
    companyId?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakerCompanyCreateManyCompanyInput = {
    speakerId: number
  }

  export type SpeakerCompanyUpdateWithoutCompanyInput = {
    speaker?: SpeakerUpdateOneRequiredWithoutSpeakerCompaniesNestedInput
  }

  export type SpeakerCompanyUncheckedUpdateWithoutCompanyInput = {
    speakerId?: IntFieldUpdateOperationsInput | number
  }

  export type SpeakerCompanyUncheckedUpdateManyWithoutCompanyInput = {
    speakerId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}